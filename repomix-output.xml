This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/Core, src/Rendering, src/Utility, include/Core, include/Rendering, include/Utility
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
include/Core/Application.h
include/Core/ConfigManager.h
include/Core/Logger.h
include/Core/MemoryManager.h
include/Core/MemoryPool.h
include/Core/Resource.h
include/Core/ResourceManager.h
include/Core/Subsystem.h
include/Core/ThreadSafeQueue.h
include/Rendering/Camera/Camera.h
include/Rendering/Camera/CameraAnimator.h
include/Rendering/Camera/FPSCameraController.h
include/Rendering/Camera/OrthographicCamera.h
include/Rendering/Camera/PerspectiveCamera.h
include/Rendering/GeometryStage.h
include/Rendering/LightManager.h
include/Rendering/Material.h
include/Rendering/Mesh.h
include/Rendering/PaletteManager.h
include/Rendering/RenderContext.h
include/Rendering/RenderPipeline.h
include/Rendering/RenderStage.h
include/Rendering/RenderSystem.h
include/Rendering/RenderTarget.h
include/Rendering/Shader.h
include/Rendering/ShaderManager.h
include/Rendering/Texture.h
include/Utility/AABB.h
include/Utility/Color.h
include/Utility/DebugDraw.h
include/Utility/FileSystem.h
include/Utility/Frustum.h
include/Utility/Math.h
include/Utility/Profiler.h
include/Utility/Random.h
include/Utility/Ray.h
include/Utility/StringUtils.h
include/Utility/Transform.h
src/Core/Application.cpp
src/Core/ConfigManager.cpp
src/Core/Logger.cpp
src/Core/MemoryManager.cpp
src/Core/MemoryPool.cpp
src/Core/Resource.cpp
src/Core/ResourceManager.cpp
src/Core/Subsystem.cpp
src/Rendering/Camera/Camera.cpp
src/Rendering/Camera/CameraAnimator.cpp
src/Rendering/Camera/FPSCameraController.cpp
src/Rendering/Camera/OrthographicCamera.cpp
src/Rendering/Camera/PerspectiveCamera.cpp
src/Rendering/GeometryStage.cpp
src/Rendering/LightManager.cpp
src/Rendering/Material.cpp
src/Rendering/Material.inl
src/Rendering/Mesh.cpp
src/Rendering/PaletteManager.cpp
src/Rendering/RenderContext.cpp
src/Rendering/RenderPipeline.cpp
src/Rendering/RenderStage.cpp
src/Rendering/RenderStage.inl
src/Rendering/RenderSystem.cpp
src/Rendering/RenderTarget.cpp
src/Rendering/Shader.cpp
src/Rendering/ShaderManager.cpp
src/Rendering/Texture.cpp
src/Utility/AABB.cpp
src/Utility/Color.cpp
src/Utility/DebugDraw.cpp
src/Utility/FileSystem.cpp
src/Utility/Frustum_SIMD.cpp
src/Utility/Frustum.cpp
src/Utility/Math.cpp
src/Utility/Profiler.cpp
src/Utility/Random.cpp
src/Utility/Ray.cpp
src/Utility/StringUtils.cpp
src/Utility/Transform.cpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="include/Core/Application.h">
// -------------------------------------------------------------------------
// Application.h
⋮----
/**
     * @brief Central engine controller with modular subsystem management
     */
⋮----
/**
         * @brief Get the singleton instance of the Application
         * @return Reference to the Application instance
         */
⋮----
/**
         * @brief Deleted copy constructor to enforce singleton
         */
⋮----
/**
         * @brief Deleted assignment operator to enforce singleton
         */
⋮----
/**
         * @brief Initialize the application and still unregistered subsystems
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Run the main application loop
         */
void run();
⋮----
/**
         * @brief Update all subsystems for a single frame
         * @param deltaTime Time since last update
         */
void update(float deltaTime);
⋮----
/**
         * @brief Render a single frame
         */
void render();
⋮----
/**
         * @brief Shut down the application and all subsystems
         */
void shutdown();
⋮----
/**
         * @brief Request the application to quit
         */
void quit();
⋮----
/**
         * @brief Get the time elapsed since the last frame
         * @return Delta time in seconds
         */
float getDeltaTime() const;
⋮----
/**
         * @brief Get a subsystem by type
         * @tparam T Type of subsystem to retrieve
         * @return Shared pointer to the requested subsystem
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
/**
         * @brief Register a subsystem with the application
         * @tparam T Type of subsystem to register
         * @param subsystem Shared pointer to the subsystem
         * @return True if registration was successful
         */
⋮----
/**
         * @brief Private constructor to enforce singleton
         */
⋮----
/**
         * @brief Sort subsystems based on their dependencies
         * @return True if dependencies could be resolved without cycles
         */
bool sortSubsystemDependencies();
⋮----
/**
         * @brief Initialize a specific subsystem and its dependencies
         * @param typeIndex Type index of the subsystem to initialize
         * @param initializedSystems Set of already initialized subsystems
         * @return True if initialization was successful
         */
bool initializeSubsystem(const std::type_index& typeIndex, std::set<std::type_index>& initializedSystems);
⋮----
// Member variables
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ConfigManager.h">
// -------------------------------------------------------------------------
// ConfigManager.h
⋮----
// Forward delcarations
⋮----
/**
     * @brief Engine and game configuration with hot-reloading support
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the ConfigManager instance
         */
⋮----
/**
         * @brief Initialize the configuration system
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the configuration system to check for file system
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Shut down the configuration system
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the subsystem dependencies
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Load configuration from file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         * @return True if loading was successful
         */
⋮----
/**
         * @brief Save configuration to a file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         * @return True if saving was successful
         */
bool saveConfig(const std::string& filename, const std::string& section = "");
⋮----
/**
         * @brief Get a configuration value with type safety
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Configuration value or default if not found
         */
⋮----
T get(const std::string& key, const T& defaultValue = T()) const;
⋮----
/**
         * @brief Get an integer configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Integer value or default if not found
         */
int getInt(const std::string& key, int defaultValue = 0) const;
⋮----
/**
         * @brief Get a float configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Float value or default if not found
         */
float getFloat(const std::string& key, float defaultValue = 0.0f) const;
⋮----
/**
         * @brief Get a boolean configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Boolean value or default if not found
         */
bool getBool(const std::string& key, bool defaultValue = false) const;
⋮----
/**
         * @brief Get a string configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return String value or default if not found
         */
std::string getString(const std::string& key, const std::string& defaultValue = "") const;
⋮----
/**
         * @brief Get a vec2 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec2 value or default if not found
         */
glm::vec2 getVec2(const std::string& key, const glm::vec2& defaultValue = glm::vec2(0.0f)) const;
⋮----
/**
         * @brief Get a vec3 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec3 value or default if not found
         */
glm::vec3 getVec3(const std::string& key, const glm::vec3& defaultValue = glm::vec3(0.0f)) const;
⋮----
/**
         * @brief Get a vec4 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec4 value or default if not found
         */
glm::vec4 getVec4(const std::string& key, const glm::vec4& defaultValue = glm::vec4(0.0f)) const;
⋮----
/**
         * @brief Set a configuration value
         * @param key Configuration key
         * @param value Value to set
         */
⋮----
void set(const std::string& key, const T& value);
⋮----
/**
         * @brief Check if a configuration key exists
         * @param key Configuration key
         * @return True if the key exists
         */
bool hasKey(const std::string& key) const;
⋮----
/**
         * @brief Watch a configuration file for changes
         * @param filename Path to the configuration file
         * @param enable Whether to enable disable watching
         */
void watch(const std::string& filename, bool enable = true);
⋮----
/**
         * @brief Callback type for configuration changes
         */
⋮----
/**
         * @brief Register a callback for configuration changes
         * @param callback Function to call when configuration changes
         * @return Callback ID for unregistering
         */
uint64_t registerChangeCallback(const ConfigChangeCallback& callback);
⋮----
/**
         * @brief Unregister a change callback
         * @param callbackId ID from registerChangeCallback
         */
void unregisterChangeCallback(uint64_t callbackId);
⋮----
/**
         * @brief Private constructor for singleton
         */
ConfigManager();
⋮----
/**
         * @brief Private destructor for singleton
         */
⋮----
/**
         * @brief Check watched files for changes
         */
void checkWatchedFiles();
⋮----
/**
         * @brief Parse a configuration file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         */
void parseConfigFile(const std::string& filename, const std::string& section);
⋮----
/**
         * @brief Notify callbacks about configuration changes
         * @param key Changed configuration key
         * @param section Section containing the key
         */
void notifyConfigChange(const std::string& key, const std::string& section);
⋮----
/**
         * @brief Determine file format from extension
         * @param filename Path to the configuration file
         * @return String indicating the format ("json", "yaml", etc.)
         */
std::string getFileFormat(const std::string& filename) const;
⋮----
/**
         * @brief Convert string to appropriate variant type
         * @param value String representation of value
         * @param type Type hint string ("int", "float", etc.)
         * @return Variant containing the converted value
         */
⋮----
stringToVariant(const std::string& value, const std::string& type) const;
⋮----
// Config storage - maps keys to values of various types
⋮----
// Maps sections to filename
⋮----
// Maps filenames to section
⋮----
// Set of files being watched for changes
⋮----
// File watcher implementation
⋮----
// Callback management
⋮----
// Threading protection
⋮----
// Last check time for file changes
⋮----
// Check interval for file changes in seconds
⋮----
// Singleton instance
⋮----
/**
     * @brief Event for configuration changes
     */
⋮----
/**
         * @brief Constructor
         * @param key Changed configuration key
         * @param section Section containing the key
         */
⋮----
/**
         * @brief Get the changed key
         * @return Configuration key
         */
const std::string& getKey() const
⋮----
/**
         * @brief Get the section
         * @return Section name
         */
const std::string& getSection() const
⋮----
/**
         * @brief Get the event type name
         * @return Type name string
         */
⋮----
/**
         * @brief Get the event type index
         * @return Type index for event system
         */
static std::type_index getTypeIndex()
⋮----
/**
     * @brief Helper for file change monitoring
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Add a file to watch
         * @param filename Path to the file
         */
void addWatch(const std::string& filename);
⋮----
/**
         * @brief Remove a file from watching
         * @param filename Path to the file
         */
void removeWatch(const std::string& filename);
⋮----
/**
         * @brief Check if any watched files have changed
         * @return Vector of changed filenames
         */
⋮----
// Maps filenames to last modification times
⋮----
// Template implementation for get
⋮----
// Template implementation for set
⋮----
// Find which section this key belongs to
for (const auto& [sec, file] : m_configFiles)
⋮----
if (!sec.empty())
⋮----
// If the key starts with the section name and a dot
⋮----
// Notify about the change
⋮----
// Template specializations for common types
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Logger.h">
// -------------------------------------------------------------------------
// Logger.h
⋮----
/**
     * @brief Log severity levels
     */
enum class LogLevel
⋮----
Debug,   // Detailed information for debugging
Info,    // General information about system operation
Warning, // Potential issues that aren't critical errors
Error,   // Errors that affect functionality but don't crash
Fatal,   // Critical errors that prevent operation
⋮----
/**
     * @brief Abstract base class for log output channels
     */
⋮----
/**
         * @brief Write a log message to the channel
         * @param level The severity level of the message
         * @param message The formatted message to write
         */
virtual void write(LogLevel level, const std::string& message) = 0;
⋮----
/**
         * @brief Flush any buffered messages
         */
virtual void flush() = 0;
⋮----
/**
     * Channel for logging to console output
     */
⋮----
void write(LogLevel level, const std::string& message) override;
void flush() override;
⋮----
/**
     * @brief Channel for logging to a file
     */
⋮----
/**
         * @brief Constructor
         * @param filename Path to the log file
         */
⋮----
/**
     * @brief Thread-safe logging system with multiple output channels
     */
⋮----
/**
         * @brief Get the singleton logger instance
         * @return Reference to the logger instance
         */
⋮----
/**
         * @brief Initialize the logging system
         * @return True if initialization succeeded
         */
bool initialize();
⋮----
/**
         * @brief Shut down the logging system and flush all channels
         */
void shutdown();
⋮----
/**
         * @brief Set the minimum severity level for logging
         * @param level The minimum level to log
         */
void setLogLevel(LogLevel level);
⋮----
/**
         * @brief Get the current minimum severity level
         * @return The current log level
         */
LogLevel getLogLevel() const;
⋮----
/**
         * @brief Add an output channel
         * @param channel Shared pointer to a log channel
         */
void addChannel(std::shared_ptr<LogChannel> channel);
⋮----
/**
         * @brief Remove an output channel
         * @param channel Shared pointer to the channel to remove
         */
void removeChannel(std::shared_ptr<LogChannel> channel);
⋮----
/**
         * @brief Set a category for subsequent log messages
         * @param category The category name
         */
void setCategory(const std::string& category);
⋮----
/**
         * @brief Clear the current category
         */
void clearCategory();
⋮----
/**
         * @brief Log a message with specific severity
         * @param level The severity level
         * @param message The message to log
         */
void log(LogLevel level, const std::string& message);
⋮----
/**
         * @brief Log a debug message
         * @param message The message to log
         */
void debug(const std::string& message);
⋮----
/**
         * @brief Log an info message
         * @param message The message to log
         */
void info(const std::string& message);
⋮----
/**
         * @brief Log a warning message
         * @param message The message to log
         */
void warn(const std::string& message);
⋮----
/**
         * @brief Log an error message
         * @param message The message to log
         */
void error(const std::string& message);
⋮----
/**
         * @brief Log a fatal error message
         * @param message The message to log
         */
void fatal(const std::string& message);
⋮----
Logger();
⋮----
// Prevent copying
⋮----
/**
         * @brief Format a log message with timestamp and context
         * @param level The severity level
         * @param message The raw message
         * @return Formatted message ready for output
         */
std::string formatMessage(LogLevel level, const std::string& message);
⋮----
/**
         * @brief Convert a log level to its string representation
         * @param level The log level
         * @return String representation of the log level
         */
std::string logLevelToString(LogLevel level);
⋮----
// Global convenience functions
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/MemoryManager.h">
// -------------------------------------------------------------------------
// MemoryManager.h
⋮----
/**
     * @brief Central memory management system with pooling, defragmentation, and diagnostics
     * 
     * Manages multiple typed memory pools, provides custom allocators for smart pointers,
     * and tracks memory usage throughout the engine.
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the MemoryManager instance
         */
⋮----
/**
         * @brief Initialize the memory manager
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the memory manager and release all memory
         */
void shutdown();
⋮----
/**
         * @brief Create a memory pool for a specific type
         * @tparam T Type of objects to be allocated from the pool
         * @param initialCapacity Initial number of objects the pool can hold
         * @return Pointer to the created memory pool
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
// Return existing pool if already created
⋮----
// Create new pool
⋮----
// Update statistics
⋮----
/**
         * @brief Get an existing memory pool for a specific type
         * @tparam T Type of objects allocated from the pool
         * @return Pointer to the memory pool or nullptr if not found
         */
⋮----
/**
         * @brief Allocate a single object of type T from its pool
         * @tparam T Type of object to allocate
         * @return Pointer to the allocated object (nullptr if allocation failed)
         */
⋮----
// Construct the object in-place
⋮----
/**
         * @brief Deallocate an object previously allocated from a pool
         * @tparam T Type of object to deallocate
         * @param ptr Pointer to the object
         */
⋮----
// Call destructor
⋮----
// Return memory to the pool
⋮----
/**
         * @brief Structure for tracking memory allocation statistics
         */
struct AllocationStats
⋮----
size_t totalAllocated{0};     // Total bytes allocated since startup
size_t totalFreed{0};         // Total bytes freed since startup
size_t currentUsage{0};       // Current memory usage in bytes
size_t peakUsage{0};          // Peak memory usage in bytes
size_t totalCapacity{0};      // Total capacity of all pools in bytes
int activePoolCount{0};       // Number of active memory pools
int allocationCount{0};       // Number of allocation operations
int deallocationCount{0};     // Number of deallocation operations
⋮----
/**
         * @brief Get current memory allocation statistics
         * @return Statistics structure with allocation data
         */
AllocationStats getAllocStats() const;
⋮----
/**
         * @brief Defragment all memory pools
         * 
         * This is a potentially expensive operation and should be used during
         * loading screens or other non-performance-critical moments.
         */
void defragmentAll();
⋮----
/**
         * @brief Release all unused memory pools
         * @return Number of pools released
         */
int releaseUnused();
⋮----
/**
         * @brief Custom deleter for use with smart pointers
         * @tparam T Type of object to delete
         */
⋮----
void operator()(T* ptr) const
⋮----
/**
         * @brief Create a shared_ptr using pool allocation
         * @tparam T Type of object to create
         * @tparam Args Constructor argument types
         * @param args Constructor arguments
         * @return shared_ptr to the newly created object
         */
⋮----
// Placement new with constructor arguments
new(ptr) T(std::forward<Args>(args)...);
⋮----
// Create shared_ptr with custom deleter
⋮----
/**
         * @brief Create a unique_ptr using pool allocation
         * @tparam T Type of object to create
         * @tparam Args Constructor argument types
         * @param args Constructor arguments
         * @return unique_ptr to the newly created object
         */
⋮----
// Create unique_ptr with custom deleter
⋮----
/**
         * @brief Private constructor for singleton pattern
         */
⋮----
/**
         * @brief Private destructor for singleton pattern
         */
⋮----
// Delete copy/move constructors and assignment operators
⋮----
/**
     * @brief Convenience function to create a shared_ptr using the memory manager
     * @tparam T Type of object to create
     * @tparam Args Constructor argument types
     * @param args Constructor arguments
     * @return shared_ptr to he newly created object
     */
⋮----
/**
     * @brief Convenience function to create a unique_ptr using the memory manager
     * @tparam T Type of object to create
     * @tparam Args Constructor argument types
     * @param args Constructor arguments
     * @return unique_ptr to the newly created object
     */
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/MemoryPool.h">
// -------------------------------------------------------------------------
// MemoryPool.h
⋮----
/**
     * @brief Type-specific memory pool for efficient allocation and deallocation
     * 
     * Provides a contiguous block of memory for fixed-size objects with
     * minimal overhead. Supports defragmentation, reserving capacity, and
     * tracking allocation statistics.
     */
⋮----
/**
         * @brief Constructor
         * @param objectSize Size of each object in bytes
         * @param initialCapacity Initial number of objects the pool can hold
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Allocate a block of memory from the pool
         * @return Pointer to allocated memory or nullptr if allocation failed
         */
void* allocate();
⋮----
/**
         * @brief Return a block of memory to the pool
         * @param ptr Pointer to memory previously allocated by this pool
         */
void deallocate(void* ptr);
⋮----
/**
         * @brief Get the number of currently used blocks
         * @return Number of allocated blocks
         */
size_t getUsedBlocks() const;
⋮----
/**
         * @brief Get the number of free blocks
         * @return Number of unallocated blocks
         */
size_t getFreeBlocks() const;
⋮----
/**
         * @brief Get the total capacity of the pool
         * @return Total number of blocks (used + free)
         */
size_t getCapacity() const;
⋮----
/**
         * @brief Get the size of each object in the pool
         * @return Size in bytes of each object
         */
size_t getObjectSize() const;
⋮----
/**
         * @brief Ensure the pool has at least the specified capacity
         * @param newCapacity Minimum number of objects the pool should hold
         */
void reserve(size_t newCapacity);
⋮----
/**
         * @brief Defragment the memory pool to consolidate free blocks
         * 
         * This operation may be expensive and should be used sparingly,
         * typically during loading screens or other non-performance-critical moments
         */
void defragment();
⋮----
/**
         * @brief Check if a pointer belongs to this memory pool
         * @param ptr Pointer to check
         * @return True if the pointer was allocated from this pool
         */
bool owns(void* ptr) const;
⋮----
/**
         * @brief Structure for tracking memory pool statistics
         */
struct PoolStats
⋮----
size_t objectSize;        // Size of each object in bytes
size_t capacity;          // Total capacity in objects
size_t usedBlocks;        // Number of allocated objects
size_t freeBlocks;        // Number of available objects
size_t memoryUsage;       // Total memory usage in bytes
size_t fragmentationRatio;// Fragmentation percentage (0-100)
⋮----
/**
         * @brief Get statistics about the memory pool
         * @return PoolStats structure with current statistics
         */
PoolStats getStats() const;
⋮----
/**
         * @brief Grow the pool by allocating more memory
         * @param additionalCapacity Number of objects to add
         * @return True if growth was successful
         */
bool grow(size_t additionalCapacity);
⋮----
/**
         * @brief Check if the pointer is aligned and within the pool's memory range
         * @param ptr Pointer to validate
         * @return True if the pointer is valid for this pool
         */
bool isValidPointer(void* ptr) const;
⋮----
size_t m_objectSize;               // Size of each object in bytes
size_t m_capacity;                 // Total numbers of objects the pool can hold
std::atomic<size_t> m_usedBlocks;  // Number of currently allocated blocks
⋮----
unsigned char* m_memory;           // Raw memory block
std::vector<void*> m_freeBlocks;   // Stack of free block pointers
⋮----
mutable std::mutex m_mutex;        // Mutex for thread safety
bool m_initialized;                // Flag to track initialization status
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Resource.h">
// -------------------------------------------------------------------------
// Resource.h
⋮----
/**
     * @brief Base class for all engine resources with reference coutings
     */
⋮----
/**
         * @brief Constructor
         * @param path The file path for this resource
         */
⋮----
/**
         * @brief Virtual destructor
         */
virtual ~Resource();
⋮----
/**
         * @brief Load the resource from its path
         * @return True if loading was successful
         */
virtual bool load() = 0;
⋮----
/**
         * @brief Unload the resource and free memory
         */
virtual void unload() = 0;
⋮----
/**
         * @brief Check if the resource is currently loaded
         * @return True if the resource is loaded
         */
bool isLoaded() const
⋮----
/**
         * @brief Get the file path for this resource
         * @return The resource file path
         */
const std::string& getPath() const
⋮----
/**
         * @brief Get the name of this resource
         * @return The resource name
         */
const std::string& getName() const
⋮----
/**
         * @brief Get the current reference count
         * @return Number of references to this resource
         */
int getRefCount() const
⋮----
/**
         * @brief Called when hot-reloading this resource
         * @return True if reloading was successful
         */
virtual bool onReload();
⋮----
/**
         * @brief Increment the reference count
         * @return The new reference count
         */
int addRef()
⋮----
/**
         * @brief Decrement the reference count
         * @return The new reference count
         */
int releaseRef()
⋮----
std::string m_path;    ///< File path of the resource
std::string m_name;    ///< Name of the resource (derived from path)
bool m_loaded;         ///< Whether the resource is currently loaded
std::atomic<int> m_refCount; ///< Reference count for memory management
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ResourceManager.h">
// -------------------------------------------------------------------------
// ResourceManager.h
⋮----
/**
     * @brief Unified resource loading, caching, and hot-reloading
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the ResourceManager instance
         */
⋮----
/**
         * @brief Initialize the resource manager
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the resource manager and release resources
         */
void shutdown();
⋮----
/**
         * @brief Load a resource of the specified type
         * @param path The file path of the resource
         * @return Shared pointer to the loaded resource
         */
⋮----
// Check if already loaded
⋮----
// Create and load the resources
⋮----
resource->addRef(); // Initial reference
⋮----
// Queue for async loading
⋮----
// Load synchronously
⋮----
// Store file modification time for hot reloading
⋮----
// Store in the resource map
⋮----
/**
         * @brief Load a resource asynchronously
         * @param path The file path of the resource
         * @param callback Function to call when loading completes
         */
⋮----
// Create the resource
⋮----
/**
         * @brief Unload a resource and release memory
         * @param path The file path of the resource to unload
         */
⋮----
// Decrement reference count
⋮----
// If no more reference, unload and remove from map
⋮----
// If no more resources of this type, remove the type map
⋮----
// Actually unload the resource outside the lock to prevent deadlocks
⋮----
/**
         * @brief Get a resource without loading it
         * @param path The file path of the resource
         * @return Shared pointer to the resource or nullptr if not found
         */
⋮----
/**
         * @brief Create a new resource without a file path
         * @param name The name of the resource
         * @return Shared pointer to the created resource
         */
⋮----
// Create the resource with a virtual path
⋮----
// Check if already exists
⋮----
/**
         * @brief Check for modified resources and reload them
         */
void reloadModified();
⋮----
/**
         * @brief Enable or disable asynchronous loading
         * @param enabled True to enable async loading, false for synchronous
         */
void setAsyncLoading(bool enabled);
⋮----
/**
         * @brief Constructor (private for singleton)
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
// Prevent copying
⋮----
/**
         * @brief Async loading thread function
         */
void asyncLoadingThreadFunc();
⋮----
// Type-specific resource maps
⋮----
// File modification times for hot reloading
⋮----
// Async loading queue
struct ResourceTask
⋮----
std::type_index typeIndex = typeid(void); // Default to void type
⋮----
// Mutex for resource map access
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Subsystem.h">
// -------------------------------------------------------------------------
// Subsystem.h
⋮----
/**
     * @brief Base class for all engine subsystems with standardized lifecycle.
     * 
     * Provides a common interface for initialization, updating, rendering,
     * and shutdown that all engine subsystems must implement.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Virtual destructor for proper cleanup of derived classes
         */
virtual ~Subsystem();
⋮----
/**
         * @brief Initialize the subsystem
         * @return True if initialization was successful, false otherwise
         */
virtual bool initialize() = 0;
⋮----
/**
         * @brief Update the subsystem logic
         * @param deltaTime Time elapsed since the last update in seconds
         */
virtual void update(float deltaTime) = 0;
⋮----
/**
         * @brief Render any visual elements of the subsystem
         */
virtual void render() = 0;
⋮----
/**
         * @brief Shutdown the subsystem and release resources
         */
virtual void shutdown() = 0;
⋮----
/**
         * @brief Check if the subsystem has been initialized
         * @return True if initialized, false otherwise
         */
bool isInitialized() const;
⋮----
/**
         * @brief Check if the subsystem is currently active
         * @return True if active, false otherwise
         */
bool isActive() const;
⋮----
/**
         * @brief Set the active state of the subsystem
         * @param active The new active state
         */
void setActive(bool active);
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name as a string
         */
virtual std::string getName() const = 0;
⋮----
/**
         * @brief Get the dependencies of this subsystem
         * @return Vector of the subsystem names that this subsystem depends on
         */
virtual std::vector<std::string> getDependencies() const;
⋮----
/** @brief Flag indicating whether the subsystem has been initialized */
⋮----
/** @brief Flag indicating whether the subsystem is active */
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ThreadSafeQueue.h">
// -------------------------------------------------------------------------
// ThreadSafeQueue.h
⋮----
/**
     * @brief Thread-safe queue for asynchronous resource loading
     */
⋮----
/**
         * @brief Add an item to the queue
         * @param item The item to add
         */
⋮----
/**
         * @brief Wait and pop an item from the queue
         * @param item Output parameter for the popped item
         */
void waitAndPop(T& item)
⋮----
/**
         * @brief Signal shutdown to wake up any waiting threads
         */
void shutdown()
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Rendering/Camera/Camera.h">
// -------------------------------------------------------------------------
// Camera.h
⋮----
/**
     * @brief Abstract base camera class that defines view and projection transformations
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Virtual destructor
         */
virtual ~Camera();
⋮----
/**
         * @brief Get the view matrix for this camera
         * @return The view matrix
         */
virtual const glm::mat4& getViewMatrix() const;
⋮----
/**
         * @brief Get the projection matrix for this camera
         * @return The projection matrix
         */
virtual const glm::mat4& getProjectionMatrix() const;
⋮----
/**
         * @brief Get the combined view-projection matrix
         * @return The view-projection matrix
         */
virtual const glm::mat4& getViewProjectionMatrix() const;
⋮----
/**
         * @brief Get the frustum for this camera
         * @return The frustum
         */
virtual const Utility::Frustum& getFrustum() const;
⋮----
/**
         * @brief Set the position of the camera
         * @param position The new position
         */
virtual void setPosition(const glm::vec3& position);
⋮----
/**
         * @brief Get the current position of the camera
         * @return The current position
         */
virtual const glm::vec3& getPosition() const;
⋮----
/**
         * @brief Set the rotation of the camera
         * @param rotation The new rotation as a quaternion
         */
virtual void setRotation(const glm::quat& rotation);
⋮----
/**
         * @brief Get the current rotation of the camera
         * @return The current rotation as a quaternion
         */
virtual const glm::quat& getRotation() const;
⋮----
/**
         * @brief Orient the camera to look at a specific target
         * @param target The point to look at
         * @param up The up direction vector, defaults to world up (0,1,0)
         */
virtual void lookAt(const glm::vec3& target, const glm::vec3& up = glm::vec3(0.0f, 1.0f, 0.0f));
⋮----
/**
         * @brief Set the target point the camera is looking at
         * @param target The target point
         */
virtual void setTarget(const glm::vec3& target);
⋮----
/**
         * @brief Get the target point the camera is looking at
         * @return The target point
         */
virtual const glm::vec3& getTarget() const;
⋮----
/**
         * @brief Get the forward direction vector of the camera
         * @return The forward direction vector
         */
virtual glm::vec3 getForward() const;
⋮----
/**
         * @brief Get the right direction vector of the camera
         * @return The right direction vector
         */
virtual glm::vec3 getRight() const;
⋮----
/**
         * @brief Get the up direction vector of the camera
         * @return The up direction vector
         */
virtual glm::vec3 getUp() const;
⋮----
/**
         * @brief Move the camera by the given offset
         * @param offset The offset to move by
         */
virtual void move(const glm::vec3& offset);
⋮----
/**
         * @brief Move the camera forward by the given distance
         * @param distance The distance to move
         */
virtual void moveForward(float distance);
⋮----
/**
         * @brief Move the camera right by the given distance
         * @param distance The distance to move
         */
virtual void moveRight(float distance);
⋮----
/**
         * @brief Move the camera up by the given distance
         * @param distance The distance to move
         */
virtual void moveUp(float distance);
⋮----
/**
         * @brief Rotate the camera by the given quaternion
         * @param rotation The rotation to apply
         */
virtual void rotate(const glm::quat& rotation);
⋮----
/**
         * @brief Rotate the camera around the world up axis (yaw)
         * @param angle The angle to rotate by in radians
         */
virtual void rotateYaw(float angle);
⋮----
/**
         * @brief Rotate the camera around its local right axis (pitch)
         * @param angle The angle to rotate by in radians
         */
virtual void rotatePitch(float angle);
⋮----
/**
         * @brief Rotate the camera around its local forward axis (roll)
         * @param angle The angle to rotate by in radians
         */
virtual void rotateRoll(float angle);
⋮----
/**
         * @brief Set the aspect ratio of the camera
         * @param aspectRatio The new aspect ratio (width/height)
         */
virtual void setAspectRatio(float aspectRatio);
⋮----
/**
         * @brief Get the current aspect ratio of the camera
         * @return The current aspect ratio
         */
virtual float getAspectRatio() const;
⋮----
/**
         * @brief Set the near clipping plane distance
         * @param nearPlane The new near plane distance
         */
virtual void setNearPlane(float nearPlane);
⋮----
/**
         * @brief Get the current near clipping plane distance
         * @return The current near plane distance
         */
virtual float getNearPlane() const;
⋮----
/**
         * @brief Set the far clipping plane distance
         * @param farPlane The new far plane distance
         */
virtual void setFarPlane(float farPlane);
⋮----
/**
         * @brief Get the current far clipping plane distance
         * @return The current far plane distance
         */
virtual float getFarPlane() const;
⋮----
/**
         * @brief Update the camera state
         * This method should be called once per frame to ensure
         * the camera's internal state is up to date
         */
virtual void update();
⋮----
/**
         * @brief Cast a ray from a screen point into the world
         * @param screenPoint The screen point in normalized device coordinates (0,0 to 1,1)
         * @return A ray from the camera through the given screen point
         */
virtual Utility::Ray screenPointToRay(const glm::vec2& screenPoint) const;
⋮----
/**
         * @brief Convert a screen point to a world point at the given depth
         * @param screenPoint The screen point in normalized device coordinates (0,0 to 1,1)
         * @param depth The depth value (0.0 for near plane, 1.0 for far plane)
         * @return The world point
         */
virtual glm::vec3 screenToWorldPoint(const glm::vec2& screenPoint, float depth = 1.0f) const;
⋮----
/**
         * @brief Convert a world point to a screen point
         * @param worldPoint The world point
         * @return The screen point in normalized device coordinates (0,0 to 1,1)
         */
virtual glm::vec2 worldToScreenPoint(const glm::vec3& worldPoint) const;
⋮----
/**
         * @brief Update the view matrix if it's dirty
         * This is called internally by getViewMatrix() when needed
         */
virtual void updateViewMatrix() const;
⋮----
/**
         * @brief Update the projection matrix if it's dirty
         * This is called internally by getProjectionMatrix() when needed
         */
virtual void updateProjectionMatrix() const;
⋮----
/**
         * @brief Update the view-projection matrix if it's dirty
         * This is called internally by getViewProjectionMatrix() when needed
         */
virtual void updateViewProjectionMatrix() const;
⋮----
/**
         * @brief Update the frustum if it's dirty
         * This is called internally by getFrustum() when needed
         */
virtual void updateFrustum() const;
⋮----
// Camera position and orientation
⋮----
// Camera properties
⋮----
// Cached matrices
⋮----
// Dirty flags for lazy evaluation
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Camera/CameraAnimator.h">
// -------------------------------------------------------------------------
// CameraAnimator.h
⋮----
/**
     * @brief Animator for smooth camera transitions
     */
⋮----
/**
         * @brief Constructor
         * @param camera The camera to animate
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set a target position for animation
         * @param position The target position
         * @param duration The animation duration in seconds
         */
void setTargetPosition(const glm::vec3& position, float duration = 1.0f);
⋮----
/**
         * @brief Set a target rotation for animation
         * @param rotation The target rotation
         * @param duration The animation duration in seconds
         */
void setTargetRotation(const glm::quat& rotation, float duration = 1.0f);
⋮----
/**
         * @brief Set a target look-at point for animation
         * @param target The point to look at
         * @param duration The animation duration in seconds
         */
void setTargetLookAt(const glm::vec3& target, float duration = 1.0f);
⋮----
/**
         * @brief Animate to a position and rotation
         * @param position The target position
         * @param rotation The target rotation
         * @param duration The animation duration in seconds
         */
void animateTo(const glm::vec3& position, const glm::quat& rotation, float duration = 1.0f);
⋮----
/**
         * @brief Animate to match another camera
         * @param targetCamera The camera to match
         * @param duration The animation duration in seconds
         */
void animateTo(const Camera& targetCamera, float duration = 1.0f);
⋮----
/**
         * @brief Start playing the animation
         */
void play();
⋮----
/**
         * @brief Pause the animation
         */
void pause();
⋮----
/**
         * @brief Stop the animation and reset
         */
void stop();
⋮----
/**
         * @brief Check if the animation is currently playing
         * @return True if playing, false otherwise
         */
bool isPlaying() const;
⋮----
/**
         * @brief Get the current animation progress
         * @return Progress as a value between 0.0 and 1.0
         */
float getProgress() const;
⋮----
/**
         * @brief Update the animation
         * @param deltaTime Time since last update in seconds
         */
void update(float deltaTime);
⋮----
/**
         * @brief Apply smooth easing to a linear progress value
         * @param t Linear progress (0.0 to 1.0)
         * @return Eased progress
         */
float easeInOut(float t) const;
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Camera/FPSCameraController.h">
// -------------------------------------------------------------------------
// FPSCameraController.h
⋮----
/**
     * @brief Controller for first-person camera movement
     */
⋮----
/**
         * @brief Constructor
         * @param camera The camera to control
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set the camera to control
         * @param camera The new camera
         */
void setCamera(std::shared_ptr<Camera> camera);
⋮----
/**
         * @brief Get the currently controlled camera
         * @return The camera
         */
⋮----
/**
         * @brief Set the movement speed
         * @param speed The new movement speed in units per second
         */
void setMoveSpeed(float speed);
⋮----
/**
         * @brief Get the current movement speed
         * @return The movement speed in units per second
         */
float getMoveSpeed() const;
⋮----
/**
         * @brief Set the rotation speed
         * @param speed The new rotation speed in radians per pixel
         */
void setRotationSpeed(float speed);
⋮----
/**
         * @brief Get the current rotation speed
         * @return The rotation speed in radians per pixel
         */
float getRotationSpeed() const;
⋮----
/**
         * @brief Handle keyboard input
         * @param deltaTime Time since last update in seconds
         */
void handleKeyboard(float deltaTime);
⋮----
/**
         * @brief Handle mouse motion
         * @param deltaX Horizontal mouse movement in pixels
         * @param deltaY Vertical mouse movement in pixels
         */
void handleMouseMotion(float deltaX, float deltaY);
⋮----
/**
         * @brief Update the controller
         * @param deltaTime Time since last update in seconds
         */
void update(float deltaTime);
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Camera/OrthographicCamera.h">
// -------------------------------------------------------------------------
// OrthographicCamera.h
⋮----
/**
     * @brief Orthographic camera with projection based on size or explicit boundaries
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Constructor with initialization parameters
         * @param size The half-height of the camera view (width is determined by aspect ratio)
         * @param aspectRatio Aspect ratio (width/height)
         * @param nearPlane Near plane distance
         * @param farPlane Far plane distance
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set the size of the orthographic projection
         * @param size The half-height of the camera view
         */
void setSize(float size);
⋮----
/**
         * @brief Get the current size of the orthographic projection
         * @return The half-height of the camera view
         */
float getSize() const;
⋮----
/**
         * @brief Set the explicit boundaries of the orthographic projection
         * @param left Left boundary
         * @param right Right boundary
         * @param bottom Bottom boundary
         * @param top Top boundary
         */
void setRect(float left, float right, float bottom, float top);
⋮----
/**
         * @brief Update the projection matrix for orthographic projection
         */
⋮----
float m_size; // Half-height of the view
mutable float m_left, m_right, m_bottom, m_top; // Explicit boundaries
bool m_useExplicitRect; // Whether to use explicit boundaries or derive from size
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Camera/PerspectiveCamera.h">
// -------------------------------------------------------------------------
// PerspectiveCamera.h
⋮----
/**
     * @brief Perspective camera with projection based on field of view
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Constructor with initialization parameters
         * @param fov Field of view in radians
         * @param aspectRatio Aspect ratio (width/height)
         * @param nearPlane Near plane distance
         * @param farPlane Far plane distance
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set the field of view
         * @param fov Field of view in radians
         */
void setFOV(float fov);
⋮----
/**
         * @brief Get the current field of view
         * @return Field of view in radians
         */
float getFOV() const;
⋮----
/**
         * @brief Update the projection matrix for perspective projection
         */
⋮----
float m_fov; // Field of view in radians
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/GeometryStage.h">
// -------------------------------------------------------------------------
// GeometryStage.h
⋮----
/**
     * @brief Render stage for geometry rendering
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the geometry stage
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Clean up resources
         */
void shutdown() override;
⋮----
/**
         * @brief Execute the geometry rendering
         * @param context Current render context
         */
void execute(const RenderContext& context) override;
⋮----
/**
         * @brief Set the shader to use for rendering
         * @param shader Shader program
         */
void setShader(std::shared_ptr<Shader> shader);
⋮----
/**
         * @brief Get the current shader
         * @return Shader program
         */
std::shared_ptr<Shader> getShader() const;
⋮----
/**
         * @brief Set the entity registry to render from
         * @param registry Entity registry
         */
void setRegistry(std::shared_ptr<ECS::Registry> registry);
⋮----
/** Shader for rendering */
⋮----
/** Entity registry */
⋮----
/** Render only opaque geometry */
⋮----
/** Render only transparent geometry */
⋮----
/** Whether depth testing is enabled */
⋮----
/** Whether depth writing is enabled */
⋮----
/** Whether to use instancing when possible */
⋮----
/** Whether to sort objects before rendering */
⋮----
/** Profiling marker for performance tracking */
⋮----
/**
         * @brief Render a single object
         * @param context Render context
         * @param entity Entity ID
         */
void renderObject(const RenderContext& context, ECS::EntityID entity);
⋮----
/**
         * @brief Setup render states
         */
void setupRenderState();
⋮----
/**
         * @brief Restore render states
         */
void restoreRenderState();
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/LightManager.h">
// -------------------------------------------------------------------------
// LightManager.h
⋮----
/**
     * @brief Types of light sources supported by the engine
     */
enum class LightType
⋮----
Directional,  ///< Directional light (sun, moon)
Point,        ///< Point light (omnidirectional)
Spot,         ///< Spot light (cone)
Area          ///< Area light (rectangular)
⋮----
/**
     * @brief Data structure for light properties optimized for GPU use
     *
     * This structure is designed to be directly uploaded to a GPU buffer
     * for efficient use in shaders.
     */
struct LightData
⋮----
glm::vec3 position;    ///< World position of the light
float range;           ///< Maximum range/radius of the light
glm::vec3 color;       ///< RGB color of the light
float intensity;       ///< Brightness multiplier
glm::vec3 direction;   ///< Forward direction of directional/spot lights
float spotAngle;       ///< Cosine of outer spot angle (for spot lights)
glm::vec2 areaSize;    ///< Width and height of area lights
uint32_t shadowIndex;  ///< Index to shadow map in shadow array
LightType type;        ///< Type of light
bool castShadows;      ///< Whether this light casts shadows
⋮----
/**
     * @brief Light source with customizable properties
     *
     * Represents a single light source in the scene with properties
     * specific to each light type (directional, point, spot, area).
     */
⋮----
/**
         * @brief Constructor
         * @param type The type of light to create
         */
⋮----
/**
         * @brief Virtual destructor
         */
virtual ~Light();
⋮----
// Light properties
/**
         * @brief Set the world position of the light
         * @param position The new position
         */
void setPosition(const glm::vec3& position);
⋮----
/**
         * @brief Set the direction the light is pointing
         * @param direction The new direction (will be normalized)
         */
void setDirection(const glm::vec3& direction);
⋮----
/**
         * @brief Set the RGB color of the light
         * @param color The new color
         */
void setColor(const glm::vec3& color);
⋮----
/**
         * @brief Set the brightness multiplier of the light
         * @param intensity The new intensity (must be non-negative)
         */
void setIntensity(float intensity);
⋮----
/**
         * @brief Set the maximum range/radius of the light
         * @param range The new range (must be positive)
         */
void setRange(float range);
⋮----
/**
         * @brief Set whether this light casts shadows
         * @param castShadows True if the light should cast shadows
         */
void setCastShadows(bool castShadows);
⋮----
// Type-specific setters
/**
         * @brief Set the inner and outer angles for spot lights
         * @param innerAngle The inner cone angle in radians
         * @param outerAngle The outer cone angle in radians
         */
void setSpotAngle(float innerAngle, float outerAngle);
⋮----
/**
         * @brief Set the dimensions for area lights
         * @param size Width and height of the area light
         */
void setAreaSize(const glm::vec2& size);
⋮----
// Getters
/**
         * @brief Get the type of this light
         * @return The light type
         */
LightType getType() const;
⋮----
/**
         * @brief Get the world position of the light
         * @return The light position
         */
const glm::vec3& getPosition() const;
⋮----
/**
         * @brief Get the direction the light is pointing
         * @return The normalized light direction
         */
const glm::vec3& getDirection() const;
⋮----
/**
         * @brief Get the RGB color of the light
         * @return The light color
         */
const glm::vec3& getColor() const;
⋮----
/**
         * @brief Get the brightness multiplier of the light
         * @return The light intensity
         */
float getIntensity() const;
⋮----
/**
         * @brief Get the maximum range/radius of the light
         * @return The light range
         */
float getRange() const;
⋮----
/**
         * @brief Check if this light casts shadows
         * @return True if the light casts shadows
         */
bool getCastShadows() const;
⋮----
/**
         * @brief Get the area light dimensions
         * @return Width and height of the area light
         */
const glm::vec2& getAreaSize() const;
⋮----
// Utility methods
/**
         * @brief Get the view matrix for shadow mapping
         * @return View matrix from the light's perspective
         */
glm::mat4 getViewMatrix() const;
⋮----
/**
         * @brief Get the projection matrix for shadow mapping
         * @return Projection matrix appropriate for the light type
         */
glm::mat4 getProjectionMatrix() const;
⋮----
// Shadow parameters
/**
         * @brief Set the shadow bias to prevent shadow acne
         * @param bias The shadow depth bias value
         */
void setShadowBias(float bias);
⋮----
/**
         * @brief Set the resolution of this light's shadow map
         * @param resolution The shadow map resolution (will be rounded to power of 2)
         */
void setShadowResolution(int resolution);
⋮----
/**
         * @brief Pack light data for shader use
         * @return Packed light data structure for GPU
         */
LightData packLightData() const;
⋮----
// Spot light properties
⋮----
// Area light properties
⋮----
// Shadow properties
⋮----
/**
     * @brief Data structure for clustered lighting
     *
     * Contains information about the 3D grid of clusters and the
     * assignment of lights to each cluster.
     */
struct ClusterData
⋮----
glm::ivec3 dimensions;           ///< 3D dimensions of the cluster grid (x, y, z)
glm::vec3 minBounds;             ///< Minimum world bounds of the cluster volume
glm::vec3 maxBounds;             ///< Maximum world bounds of the cluster volume
std::vector<uint32_t> lightGrid;  ///< Grid data: start index and count packed into 32 bits
std::vector<uint32_t> lightIndices; ///< Indices into the visible lights array
⋮----
/**
     * @brief Manager for light sources and shadows in the rendering system
     *
     * The LightManager handles different types of light sources (directional, point, spot, area),
     * manages shadow mapping, implements clustered lighting for performance optimization,
     * performs light culling against the view frustum, and provides efficient GPU buffer updates.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the light manager
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the light manager and release resources
         */
void shutdown();
⋮----
/**
         * @brief Create a light of the specified type
         * @param type The type of light to create
         * @return A shared pointer to the created light
         */
⋮----
/**
         * @brief Remove a light from the manager
         * @param light The light to remove
         */
void removeLight(std::shared_ptr<Light> light);
⋮----
/**
         * @brief Get all lights managed by this LightManager
         * @return A vector of all lights
         */
const std::vector<std::shared_ptr<Light>>& getLights() const;
⋮----
/**
         * @brief Get lights that are currently visible in the view frustum
         * @return A vector of visible lights
         */
const std::vector<std::shared_ptr<Light>>& getVisibleLights() const;
⋮----
/**
         * @brief Setup light clustering with the specified dimensions
         * @param dimensions The dimensions of the cluster grid (x, y, z)
         */
void setupClusters(const glm::ivec3& dimensions);
⋮----
/**
         * @brief Update the light clusters based on the current render context
         * @param context The current render context
         */
void updateClusters(const RenderContext& context);
⋮----
/**
         * @brief Get the current cluster data
         * @return The cluster data structure
         */
const ClusterData& getClusterData() const;
⋮----
/**
         * @brief Prepare shadow maps for all shadow-casting lights
         * @param context The current render context
         */
void prepareShadowMaps(const RenderContext& context);
⋮----
/**
         * @brief Get the shadow map for a specific index
         * @param index The shadow map index
         * @return A shared pointer to the render target containing the shadow map
         */
std::shared_ptr<RenderTarget> getShadowMap(size_t index) const;
⋮----
/**
         * @brief Setup cascaded shadow maps for directional lights
         * @param cascadeCount The number of cascades to use
         * @param splitLambda Lambda factor for cascade split calculation (0.0 to 1.0)
         */
void setupCascadedShadowMaps(int cascadeCount, float splitLambda = 0.5f);
⋮----
/**
         * @brief Get the view-projection matrices for all cascades
         * @return A vector of cascade view-projection matrices
         */
const std::vector<glm::mat4>& getCascadeViewProjections() const;
⋮----
/**
         * @brief Get the cascade split distances
         * @return A vector of cascade split distances
         */
const std::vector<float>& getCascadeSplits() const;
⋮----
/**
         * @brief Update the list of visible lights based on the view frustum
         * @param frustum The current view frustum
         */
void updateVisibleLights(const Utility::Frustum& frustum);
⋮----
/**
         * @brief Update the GPU buffers with the current light data
         */
void updateGPUBuffers();
⋮----
/**
         * @brief Get the GPU buffer containing light data
         * @return The light data buffer ID
         */
uint32_t getLightDataBuffer() const;
⋮----
/**
         * @brief Get the GPU buffer containing cluster data
         * @return The cluster data buffer ID
         */
uint32_t getClusterDataBuffer() const;
⋮----
/**
         * @brief Assign lights to clusters based on their positions and ranges
         *
         * This method performs spatial tests to determine which lights affect each
         * cluster in the 3D grid, and builds the data structures for efficient
         * lookup in shaders.
         */
void assignLightsToClusters();
⋮----
/**
         * @brief Create or update a shadow map for the specified light
         * @param light The light that needs a shadow map
         *
         * Creates an appropriately sized and formatted shadow map render target
         * based on the light type (cubemap for point lights, 2D for others)
         * and registers it in the shadow map index.
         */
void createShadowMapForLight(std::shared_ptr<Light> light);
⋮----
/**
         * @brief Calculate cascade split distances based on the render context
         * @param context The current render context
         *
         * Uses a logarithmic distribution controlled by m_cascadeSplitLambda
         * to calculate optimal cascade split distances and updates the
         * cascade view-projection matrices.
         */
void calculateCascadeSplits(const RenderContext& context);
⋮----
// All managed lights
⋮----
// Lights visible in the current view frustum
⋮----
// Light type-specific lists for optimization
⋮----
// Clustering
⋮----
// Shadow mapping
⋮----
// Cascaded shadow mapping for directional lights
⋮----
// GPU buffers
⋮----
// Initialization state
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Material.h">
// -------------------------------------------------------------------------
// Material.h
⋮----
/**
     * @brief Defines the blending mode for material rendering
     */
enum class BlendMode
⋮----
Opaque,     ///< No blending (default)
Transparent, ///< Alpha blending
Additive,   ///< Additive blending
Multiply,   ///< Multiply blending
Screen      ///< Screen blending
⋮----
/**
     * @brief Defines face culling mode for material rendering
     */
enum class CullMode
⋮----
None,       ///< No face culling
Front,      ///< Cull front faces
Back        ///< Cull back faces (default)
⋮----
/**
     * @brief Defines standard texture slots for materials
     */
enum class TextureSlot
⋮----
Albedo,          ///< Base color/diffuse texture
Normal,          ///< Normal map texture
Metallic,        ///< Metallic texture
Roughness,       ///< Roughness texture
AmbientOcclusion, ///< Ambient occlusion texture
Emissive,        ///< Emissive texture
Height,          ///< Height/displacement map
User0,           ///< Custom user texture slot 0
User1,           ///< Custom user texture slot 1
User2,           ///< Custom user texture slot 2
User3            ///< Custom user texture slot 3
⋮----
/**
     * @brief Represents surface appearance properties and shader parameters
     *
     * The Material class manages shader parameters, textures, and render states
     * for rendering 3D objects. It supports PBR (Physically Based Rendering)
     * properties and material inheritance.
     */
⋮----
/**
         * @brief Constructor
         * @param name Name of the material
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~Material();
⋮----
// Resource implementation
/**
         * @brief Load the material
         * @return True if successful
         */
bool load() override;
⋮----
/**
         * @brief Unload the material
         */
void unload() override;
⋮----
/**
         * @brief Handle material reload
         * @return True if reload was successful
         */
bool onReload() override;
⋮----
// Shader management
/**
         * @brief Set the shader for this material
         * @param shader Shader to use
         */
void setShader(std::shared_ptr<Shader> shader);
⋮----
/**
         * @brief Get the current shader
         * @return The shader used by this material
         */
std::shared_ptr<Shader> getShader() const;
⋮----
// Parameter management
/**
         * @brief Set a parameter value of any supported type
         * @param name Parameter name
         * @param value Parameter value
         */
⋮----
void setParameter(const std::string& name, const T& value);
⋮----
/**
         * @brief Get a parameter value
         * @param name Parameter name
         * @param defaultValue Default value to return if parameter doesn't exist
         * @return Parameter value or default value
         */
⋮----
T getParameter(const std::string& name, const T& defaultValue = T()) const;
⋮----
/**
         * @brief Check if a parameter exists
         * @param name Parameter name
         * @return True if parameter exists
         */
bool hasParameter(const std::string& name) const;
⋮----
// Specialized parameter setters (for common types)
/**
         * @brief Set a float parameter
         * @param name Parameter name
         * @param value Float value
         */
void setFloat(const std::string& name, float value);
⋮----
/**
         * @brief Set an integer parameter
         * @param name Parameter name
         * @param value Integer value
         */
void setInt(const std::string& name, int value);
⋮----
/**
         * @brief Set a 2D vector parameter
         * @param name Parameter name
         * @param value Vector2 value
         */
void setVector2(const std::string& name, const glm::vec2& value);
⋮----
/**
         * @brief Set a 3D vector parameter
         * @param name Parameter name
         * @param value Vector3 value
         */
void setVector3(const std::string& name, const glm::vec3& value);
⋮----
/**
         * @brief Set a 4D vector parameter
         * @param name Parameter name
         * @param value Vector4 value
         */
void setVector4(const std::string& name, const glm::vec4& value);
⋮----
/**
         * @brief Set a 4x4 matrix parameter
         * @param name Parameter name
         * @param value Matrix4x4 value
         */
void setMatrix4(const std::string& name, const glm::mat4& value);
⋮----
/**
         * @brief Set a color parameter
         * @param name Parameter name
         * @param value Color as Vector4 (RGBA)
         */
void setColor(const std::string& name, const glm::vec4& value);
⋮----
// Texture management
/**
         * @brief Set a texture in a standard slot
         * @param slot Texture slot
         * @param texture Texture to set
         */
void setTexture(TextureSlot slot, std::shared_ptr<Texture> texture);
⋮----
/**
         * @brief Get a texture from a standard slot
         * @param slot Texture slot
         * @return Texture in the slot or nullptr
         */
std::shared_ptr<Texture> getTexture(TextureSlot slot) const;
⋮----
/**
         * @brief Set a texture with a custom name
         * @param name Custom texture name
         * @param texture Texture to set
         */
void setTextureByName(const std::string& name, std::shared_ptr<Texture> texture);
⋮----
/**
         * @brief Get a texture by custom name
         * @param name Custom texture name
         * @return Texture with the name or nullptr
         */
std::shared_ptr<Texture> getTextureByName(const std::string& name) const;
⋮----
// PBR properties convenience methods
/**
         * @brief Set the base color (albedo)
         * @param color Base color as Vector3 (RGB)
         */
void setBaseColor(const glm::vec3& color);
⋮----
/**
         * @brief Set the metallic value
         * @param metallic Metallic value [0-1]
         */
void setMetallic(float metallic);
⋮----
/**
         * @brief Set the roughness value
         * @param roughness Roughness value [0-1]
         */
void setRoughness(float roughness);
⋮----
/**
         * @brief Set the emissive color
         * @param emissive Emissive color as Vector3 (RGB)
         */
void setEmissive(const glm::vec3& emissive);
⋮----
/**
         * @brief Get the base color
         * @return Base color as Vector3 (RGB)
         */
glm::vec3 getBaseColor() const;
⋮----
/**
         * @brief Get the metallic value
         * @return Metallic value [0-1]
         */
float getMetallic() const;
⋮----
/**
         * @brief Get the roughness value
         * @return Roughness value [0-1]
         */
float getRoughness() const;
⋮----
/**
         * @brief Get the emissive color
         * @return Emissive color as Vector3 (RGB)
         */
glm::vec3 getEmissive() const;
⋮----
// Render state
/**
         * @brief Set the blending mode
         * @param mode Blend mode to use
         */
void setBlendMode(BlendMode mode);
⋮----
/**
         * @brief Set the face culling mode
         * @param mode Culling mode to use
         */
void setCullMode(CullMode mode);
⋮----
/**
         * @brief Enable or disable depth testing
         * @param enabled True to enable depth testing
         */
void setDepthTest(bool enabled);
⋮----
/**
         * @brief Enable or disable depth writing
         * @param enabled True to enable depth writing
         */
void setDepthWrite(bool enabled);
⋮----
/**
         * @brief Get the current blend mode
         * @return Current blend mode
         */
BlendMode getBlendMode() const;
⋮----
/**
         * @brief Get the current cull mode
         * @return Current cull mode
         */
CullMode getCullMode() const;
⋮----
/**
         * @brief Check if depth testing is enabled
         * @return True if depth testing is enabled
         */
bool getDepthTest() const;
⋮----
/**
         * @brief Check if depth writing is enabled
         * @return True if depth writing is enabled
         */
bool getDepthWrite() const;
⋮----
// Material inheritance
/**
         * @brief Set a parent material for inheritance
         * @param parent Parent material
         */
void setParent(std::shared_ptr<Material> parent);
⋮----
/**
         * @brief Get the parent material
         * @return Parent material or nullptr
         */
std::shared_ptr<Material> getParent() const;
⋮----
/**
         * @brief Create a clone of this material
         * @return New material instance with same properties
         */
std::shared_ptr<Material> clone() const;
⋮----
// Binding
/**
         * @brief Bind the material for rendering
         */
void bind();
⋮----
/**
         * @brief Unbind the material after rendering
         */
void unbind();
⋮----
struct ParameterValue
⋮----
/**
         * @brief Apply the current render state
         */
void bindRenderState();
⋮----
/**
         * @brief Bind all textures to their shader uniforms
         */
void bindTextures();
⋮----
/**
         * @brief Bind all parameters to their shader uniforms
         */
void bindParameters();
⋮----
/**
         * @brief Find a parameter value including inheritance
         * @param name Parameter name
         * @param outValue Output parameter value
         * @return True if parameter was found
         */
bool findParameter(const std::string& name, ParameterValue& outValue) const;
⋮----
/**
         * @brief Find a texture including inheritance
         * @param slot Texture slot
         * @param outTexture Output texture
         * @return True if texture was found
         */
bool findTexture(TextureSlot slot, std::shared_ptr<Texture>& outTexture) const;
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Mesh.h">
// -------------------------------------------------------------------------
// Mesh.h
⋮----
/**
     * @brief Defines the primitive type for rendering
     */
enum class PrimitiveType
⋮----
/**
     * @brief Defines the semantic meaning of vertex attributes
     */
enum class VertexAttributeSemantic
⋮----
/**
     * @brief Describes a single vertex attribute
     */
struct VertexAttribute
⋮----
int size;      // Components per vertex (1-4)
unsigned int type;   // GL_FLOAT, GL_INT, etc.
⋮----
std::string name; // For custom attributes
⋮----
/**
     * @brief Collection of vertex attributes defining a vertex layout
     */
struct VertexAttributes
⋮----
/**
     * @brief 3D geometry data with efficient GPU storage
     *
     * Manages vertex and index buffer objects with support for different vertex
     * attribute layouts, dynamic updates, and automatic geometry calculations.
     */
⋮----
/**
         * @brief Constructor
         * @param name Resource name for identification
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~Mesh();
⋮----
/**
         * @brief Load the mesh resource
         * @return True if loading was successful
         */
bool load() override;
⋮----
/**
         * @brief Unload the mesh resource and free GPU resources
         */
void unload() override;
⋮----
/**
         * @brief Called when the resource needs to be reloaded
         * @return True if reload was successful
         */
bool onReload() override;
⋮----
/**
         * @brief Create a mesh from vertex and index data
         *
         * @param vertices Pointer to vertex data
         * @param vertexCount Number of vertices
         * @param indices Pointer to index data (can be nullptr for non-indexed geometry)
         * @param indexCount Number of indices (0 for non-indexed geometry)
         * @param attributes Vertex attribute layout
         * @param primitiveType Primitive type to use for rendering
         * @return True if creation was successful
         */
bool createFromData(const void* vertices, uint32_t vertexCount,
⋮----
/**
         * @brief Bind the mesh for rendering
         */
void bind();
⋮----
/**
         * @brief Unbind the mesh after rendering
         */
void unbind();
⋮----
/**
         * @brief Draw the mesh
         */
void draw();
⋮----
/**
         * @brief Draw the mesh multiple times
         * @param instanceCount Number of instances to draw
         */
void drawInstanced(uint32_t instanceCount);
⋮----
/**
         * @brief Update a portion of the vertex data
         *
         * @param data Pointer to new vertex data
         * @param size Size of data in bytes
         * @param offset Byte offset into the vertex buffer
         */
void updateVertexData(const void* data, uint32_t size, uint32_t offset = 0);
⋮----
/**
         * @brief Update a portion of the index data
         *
         * @param indices Pointer to new index data
         * @param count Number of indices to update
         * @param offset Index offset into the index buffer
         */
void updateIndexData(const uint32_t* indices, uint32_t count, uint32_t offset = 0);
⋮----
/**
         * @brief Calculate vertex normals based on triangles
         *
         * Requires Position and Normal vertex attributes.
         */
void calculateNormals();
⋮----
/**
         * @brief Calculate tangent vectors for normal mapping
         *
         * Requires Position, Normal, TexCoord0, and Tangent vertex attributes.
         */
void calculateTangents();
⋮----
/**
         * @brief Calculate axis-aligned bounding box
         *
         * Requires Position vertex attribute.
         */
void calculateBounds();
⋮----
/**
         * @brief Get the number of vertices
         * @return Vertex count
         */
uint32_t getVertexCount() const;
⋮----
/**
         * @brief Get the number of indices
         * @return Index count (0 for non-indexed geometry)
         */
uint32_t getIndexCount() const;
⋮----
/**
         * @brief Get the primitive type
         * @return Primitive type used for rendering
         */
PrimitiveType getPrimitiveType() const;
⋮----
/**
         * @brief Get the vertex attribute layout
         * @return Vertex attributes
         */
const VertexAttributes& getAttributes() const;
⋮----
/**
         * @brief Get the bounding box
         * @return Axis-aligned bounding box
         */
const Utility::AABB& getBounds() const;
⋮----
uint32_t m_vao;     // Vertex Array Object
uint32_t m_vbo;     // Vertex Buffer Object
uint32_t m_ebo;     // Element Buffer Object (indices)
⋮----
/**
         * @brief Set up vertex attribute pointers
         */
void setupVertexAttributes();
⋮----
/**
         * @brief Convert primitive type to GL enum
         * @return OpenGL primitive type enum
         */
unsigned int getPrimitiveTypeGL() const;
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/PaletteManager.h">
// -------------------------------------------------------------------------
// PaletteManager.h
⋮----
enum class DitheringPattern
⋮----
/**
     * @brief Manages color palettes for pixel art rendering
     *
     * The PaletteManager handles loading, saving, and managing color palettes
     * for pixel art rendering. It supports palette constraints, dithering, palette
     * swapping, time-of-day variations, and integration with the shader system.
     */
⋮----
/**
         * @brief Constructs a new PaletteManager with default settings
         */
⋮----
/**
         * @brief Destructor that ensures proper cleanup
         */
⋮----
/**
         * @brief Initializes the palette manager and creates default palettes
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Releases all resources and resets the manager state
         */
void shutdown();
⋮----
/**
         * @brief Loads a palette from a file (supports PAL, GPL, and HEX formats)
         * @param name Unique identifier for the palette
         * @param filepath Path to the palette file
         * @return True if the palette was loaded successfully
         */
bool loadPalette(const std::string& name, const std::string& filepath);
⋮----
/**
         * @brief Creates a palette from an array of colors
         * @param name Unique identifier for the palette
         * @param colors Vector of RGBA colors (0.0-1.0 range)
         * @return True if the palette was created successfully
         */
bool createPalette(const std::string& name, const std::vector<glm::vec4>& colors);
⋮----
/**
         * @brief Saves a palette to a file (supports PAL, GPL, and HEX formats)
         * @param name The palette to save
         * @param filepath Destination file path
         * @return True if the palette was saved successfully
         */
bool savePalette(const std::string& name, const std::string& filepath);
⋮----
/**
         * @brief Removes a palette from memory
         * @param name The palette to delete
         * @return True if the palette was deleted successfully
         */
bool deletePalette(const std::string& name);
⋮----
/**
         * @brief Checks if a palette with the given name exists
         * @param name The palette name to check
         * @return True if the palette exists
         */
bool hasPalette(const std::string& name) const;
⋮----
/**
         * @brief Gets the array of colors in a palette
         * @param name The palette name
         * @return Const reference to the array of colors
         */
const std::vector<glm::vec4>& getPaletteColors(const std::string& name) const;
⋮----
/**
         * @brief Gets a palette as a texture for use in shaders
         * @param name The palette name
         * @return Shared pointer to the palette texture
         */
⋮----
/**
         * @brief Gets the names of all available palettes
         * @return Vector of palette names
         */
⋮----
/**
         * @brief Sets the active palette for rendering
         * @param name The palette to set as active
         */
void setActivePalette(const std::string& name);
⋮----
/**
         * @brief Gets the name of the currently active palette
         * @return The active palette name
         */
const std::string& getActivePalette() const;
⋮----
/**
         * @brief Enables or disables palette constraint for rendering
         * @param enabled Whether to enable palette constraint
         */
void enablePaletteConstraint(bool enabled);
⋮----
/**
         * @brief Checks if palette constraint is enabled
         * @return True if palette constraint is enabled
         */
bool isPaletteConstraintEnabled() const;
⋮----
/**
         * @brief Sets the strength of the palette constraint
         * @param strength Value between 0.0 (no constraint) and 1.0 (full constraint)
         */
void setConstraintStrength(float strength);
⋮----
/**
         * @brief Gets the current constraint strength
         * @return The constraint strength value
         */
float getConstraintStrength() const;
⋮----
/**
         * @brief Sets the dithering pattern to use for color transitions
         * @param pattern The dithering pattern to use
         */
void setDitheringPattern(DitheringPattern pattern);
⋮----
/**
         * @brief Sets the strength of the dithering effect
         * @param strength Value between 0.0 (no dithering) and 1.0 (full dithering)
         */
void setDitheringStrength(float strength);
⋮----
/**
         * @brief Gets the current dithering pattern
         * @return The current dithering pattern
         */
DitheringPattern getDitheringPattern() const;
⋮----
/**
         * @brief Gets the current dithering strength
         * @return The dithering strength value
         */
float getDitheringStrength() const;
⋮----
/**
         * @brief Generates a palette algorithmically
         * @param name Name for the new palette
         * @param colorCount Number of colors to generate
         * @param includeTransparency Whether to include a transparent color
         * @return True if the palette was generated successfully
         */
bool generatePalette(const std::string& name, int colorCount, bool includeTransparency = false);
⋮----
/**
         * @brief Extracts a color palette from an image file
         * @param name Name for the new palette
         * @param imagePath Path to the source image
         * @param maxColors Maximum number of colors to extract
         * @return True if the palette was extracted successfully
         */
bool extractPaletteFromImage(const std::string& name, const std::string& imagePath, int maxColors = 16);
⋮----
/**
         * @brief Adds a color to an existing palette
         * @param name The palette to modify
         * @param color The color to add
         * @return True if the color was added successfully
         */
bool addColorToPalette(const std::string& name, const glm::vec4& color);
⋮----
/**
         * @brief Removes a color from a palette
         * @param name The palette to modify
         * @param index The index of the color to remove
         * @return True if the color was removed successfully
         */
bool removeColorFromPalette(const std::string& name, int index);
⋮----
/**
         * @brief Updates a color in a palette
         * @param name The palette to modify
         * @param index The index of the color to update
         * @param color The new color value
         * @return True if the color was updated successfully
         */
bool updateColorInPalette(const std::string& name, int index, const glm::vec4& color);
⋮----
/**
         * @brief Finds the nearest color in a palette to a given color
         * @param color The color to match
         * @param paletteName The palette to search (uses active palette if empty)
         * @return The nearest color in the palette
         */
glm::vec4 findNearestColor(const glm::vec4& color, const std::string& paletteName = "") const;
⋮----
/**
         * @brief Finds the index of the nearest color in a palette
         * @param color The color to match
         * @param paletteName The palette to search (uses active palette if empty)
         * @return The index of the nearest color, or -1 if not found
         */
int findNearestColorIndex(const glm::vec4& color, const std::string& paletteName = "") const;
⋮----
/**
         * @brief Adds a time-of-day variant of a palette
         * @param basePalette The base palette name
         * @param timeOfDay Time value (0.0-24.0) for the variant
         * @param variantPalette The palette to use at this time
         */
void addTimeOfDayVariant(const std::string& basePalette, float timeOfDay, const std::string& variantPalette);
⋮----
/**
         * @brief Updates the time of day to blend between variants
         * @param timeOfDay Current time value (0.0-24.0)
         */
void updateTimeOfDay(float timeOfDay);
⋮----
/**
         * @brief Starts a smooth transition to another palette
         * @param targetPalette The palette to blend to
         * @param duration Duration of the blend in seconds
         */
void blendToPalette(const std::string& targetPalette, float duration);
⋮----
/**
         * @brief Updates the palette blending process
         * @param deltaTime Time elapsed since last update in seconds
         */
void updatePaletteBlend(float deltaTime);
⋮----
/**
         * @brief Gets the current blend progress
         * @return Value between 0.0 (start) and 1.0 (complete)
         */
float getPaletteBlendProgress() const;
⋮----
/**
         * @brief Binds palette textures to a shader
         * @param shader The shader to bind textures to
         */
void bindPaletteTextures(std::shared_ptr<Shader> shader);
⋮----
// Palette storage
⋮----
// Active palette tracking
⋮----
// Palette constraint settings
⋮----
// Dithering settings
⋮----
// Time of day variants
⋮----
/**
         * @brief Updates or creates the texture for a palette
         * @param name The palette name
         */
void updatePaletteTexture(const std::string& name);
⋮----
/**
         * @brief Creates textures for all dithering patterns
         */
void createDitheringTextures();
⋮----
/**
         * @brief Helper method to create a dithering texture from pattern data
         * @param pattern The dithering pattern data
         * @param width Width of the pattern
         * @param height Height of the pattern
         */
void createDitheringTexture(const std::vector<float>& pattern, int width, int height);
⋮----
/**
         * @brief Calculates the perceptual distance between two colors
         * @param a First color
         * @param b Second color
         * @return The distance value (lower means more similar)
         */
float colorDistance(const glm::vec4& a, const glm::vec4& b) const;
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/RenderContext.h">
// -------------------------------------------------------------------------
// RenderContext.h
⋮----
// Forward declaration
⋮----
/**
     * @brief Manages rendering state including matrices, camera info, and viewport
     * 
     * RenderContext stores and manages the current rendering state including view and
     * projection matrices, camera information, and other rendering parameters.
     */
⋮----
/**
         * @brief Constructor with default initialization
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set the view matrix
         * @param view The new view matrix
         */
void setViewMatrix(const glm::mat4& view);
⋮----
/**
         * @brief Set the projection matrix
         * @param projection The new projection matrix
         */
void setProjectionMatrix(const glm::mat4& projection);
⋮----
/**
         * @brief Update the combined view-projection matrix
         */
void updateMatrices();
⋮----
/**
         * @brief Get the current view matrix
         * @return The view matrix
         */
const glm::mat4& getViewMatrix() const;
⋮----
/**
         * @brief Get the current projection matrix
         * @return The projection matrix
         */
const glm::mat4& getProjectionMatrix() const;
⋮----
/**
         * @brief Get the combined view-projection matrix
         * @return The view-projection matrix
         */
const glm::mat4& getViewProjectionMatrix() const;
⋮----
/**
         * @brief Set the camera position
         * @param position The new camera position in world space
         */
void setCameraPosition(const glm::vec3& position);
⋮----
/**
         * @brief Set the camera direction
         * @param direction The new camera direction vector
         */
void setCameraDirection(const glm::vec3& direction);
⋮----
/**
         * @brief Get the current camera position
         * @return The camera position in world space
         */
const glm::vec3& getCameraPosition() const;
⋮----
/**
         * @brief Get the current camera direction
         * @return The camera direction vector
         */
const glm::vec3& getCameraDirection() const;
⋮----
/**
         * @brief Set the viewport dimensions
         * @param x The x-coordinate of the viewport
         * @param y The y-coordinate of the viewport
         * @param width The width of the viewport
         * @param height The height of the viewport
         */
void setViewport(int x, int y, int width, int height);
⋮----
/**
         * @brief Set the rendering resolution
         * @param width The width of the render target
         * @param height The height of the render target
         */
void setRenderSize(int width, int height);
⋮----
/**
         * @brief Get the current viewport
         * @return The viewport as (x, y, width, height)
         */
const glm::ivec4& getViewport() const;
⋮----
/**
         * @brief Get the current render size
         * @return The render size as (width, height)
         */
const glm::ivec2& getRenderSize() const;
⋮----
/**
         * @brief Get the view frustum for culling
         * @return The current view frustum
         */
const Utility::Frustum& getFrustum() const;
⋮----
/**
         * @brief Update the view frustum based on current matrices
         */
void updateFrustum();
⋮----
/**
         * @brief Bind common uniforms to a shader
         * @param shader The shader to bind uniforms to
         */
void bindShaderUniforms(std::shared_ptr<Shader> shader);
⋮----
/**
         * @brief Transform a point from world space to view space
         * @param worldPos The point in world space
         * @return The point in view space
         */
glm::vec3 worldToViewSpace(const glm::vec3& worldPos) const;
⋮----
/**
         * @brief Transform a point from world space to clip space
         * @param worldPos The point in world space
         * @return The point in clip space
         */
glm::vec4 worldToClipSpace(const glm::vec3& worldPos) const;
⋮----
// Matrix data
⋮----
// Camera information
⋮----
// Viewport imformation
glm::ivec4 m_viewport;  // (x, y, width, height)
glm::ivec2 m_renderSize; // (width, height)
⋮----
// Frustum for culling
⋮----
// Dirty flags for efficient updates
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/RenderPipeline.h">
// -------------------------------------------------------------------------
// RenderPipeline.h
⋮----
/**
     * @brief Configurable multi-stage rendering pipeline
     *
     * The RenderPipeline orchestrates multiple render stages into a complete
     * rendering pipeline, managing dependencies, intermediate targets, and execution.
     */
⋮----
/**
         * @brief Constructor
         * @param name The name of the pipeline
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~RenderPipeline();
⋮----
/**
         * @brief Initialize the pipeline
         * @return True if initialization was successful
         */
virtual bool initialize();
⋮----
/**
         * @brief Shut down the pipeline and release resources
         */
void shutdown();
⋮----
/**
         * @brief Execute the pipeline with the provided context
         * @param context The rendering context
         */
void render(const RenderContext& context);
⋮----
/**
         * @brief Add a render stage to the pipeline
         * @param stage The render stage to add
         */
void addStage(std::shared_ptr<RenderStage> stage);
⋮----
/**
         * @brief Remove a render stage by name
         * @param stageName The name of the stage to remove
         */
void removeStage(const std::string& stageName);
⋮----
/**
         * @brief Remove all render stages from the pipeline
         */
void clearStages();
⋮----
/**
         * @brief Get a stage by name with type casting
         * @param stageName The name of the stage to retrieve
         * @return The render stage, or nullptr if not found
         */
⋮----
auto stage = getStageByName(stageName);
⋮----
/**
         * @brief Get a stage by name
         * @param stageName The name of the stage to retrieve
         * @return The render stage, or nullptr if not found
         */
⋮----
/**
         * @brief Get all stages in the pipeline
         * @return Vector of render stages
         */
const std::vector<std::shared_ptr<RenderStage>>& getStages() const;
⋮----
/**
         * @brief Set the final output target of the pipeline
         * @param target The render target to output to
         */
void setOutput(std::shared_ptr<RenderTarget> target);
⋮----
/**
         * @brief Get the final output target
         * @return The output render target
         */
std::shared_ptr<RenderTarget> getOutput() const;
⋮----
/**
         * @brief Create an intermediate render target
         * @param name The name of the target
         * @param width Width in pixels
         * @param height Height in pixels
         * @param colorFormat Format for the color attachment
         * @param createDepth Whether to create a depth attachment
         * @param multisampled Whether to enable multisampling
         * @return The created render target
         */
std::shared_ptr<RenderTarget> createIntermediateTarget(
⋮----
/**
         * @brief Get an intermediate render target by name
         * @param name The name of the target to retrieve
         * @return The render target, or nullptr if not found
         */
std::shared_ptr<RenderTarget> getIntermediateTarget(const std::string& name);
⋮----
/**
         * @brief Set a parameter value for the entire pipeline
         * @param name The name of the parameter
         * @param value The value to set
         */
⋮----
void setParameter(const std::string& name, const T& value)
⋮----
// Propagate the parameter to all stages
⋮----
stage->setParameter(name, value);
⋮----
/**
         * @brief Validate the pipeline configuration
         * @return True if valid, false if invalid
         */
bool validate();
⋮----
/**
         * @brief Save the pipeline configuration to a file
         * @param filepath The path to save to
         */
void saveToFile(const std::string& filepath);
⋮----
/**
         * @brief Load the pipeline configuration from a file
         * @param filepath The path to load from
         * @return True if successful, false otherwise
         */
bool loadFromFile(const std::string& filepath);
⋮----
/**
         * @brief Debug visualization of the pipeline
         * @param position Screen position to draw at
         * @param scale Scaling factor for the visualization
         */
void debugDrawPipeline(const glm::vec2& position, float scale = 1.0f);
⋮----
/**
         * @brief Get the name of the pipeline
         * @return The pipeline name
         */
const std::string& getName() const;
⋮----
/**
         * @brief Set up connections between stages
         */
⋮----
/**
         * @brief Resize all intermediate targets
         * @param width New width
         * @param height New height
         */
void resizeIntermediateTargets(int width, int height);
⋮----
/**
         * @brief Validate stage dependencies
         * @return True if valid, false if invalid
         */
bool validateStageDependencies();
⋮----
// Member variables
⋮----
/**
     * @brief Specialized pipeline for forward rendering
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Initialize the forward rendering pipeline
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Create the default stages for forward rendering
         */
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/RenderStage.h">
// -------------------------------------------------------------------------
// RenderStage.h
⋮----
/**
     * @brief Base class for a single pass in a rendering pipeline
     */
⋮----
/**
         * @brief Constructor
         * @param name Name of the render stage
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~RenderStage();
⋮----
/**
         * @brief Initialize the render stage
         * @return True if initialization was successful
         */
virtual bool initialize() = 0;
⋮----
/**
         * @brief Clean up resources used by the render stage
         */
virtual void shutdown() = 0;
⋮----
/**
         * @brief Execute the render stage
         * @param context Current render context
         */
virtual void execute(const RenderContext& context) = 0;
⋮----
/**
         * @brief Set an input render target
         * @param input Render target to use as input
         * @param index Index of the input (for multiple inputs)
         */
void setInput(std::shared_ptr<RenderTarget> input, int index = 0);
⋮----
/**
         * @brief Set the output render target
         * @param output Render target to use as output
         */
void setOutput(std::shared_ptr<RenderTarget> output);
⋮----
/**
         * @brief Get an input render target
         * @param index Index of the input
         * @return Shared pointer to the render target
         */
⋮----
/**
         * @brief Get the output render target
         * @return Shared pointer to the render target
         */
⋮----
/**
         * @brief Set a parameter value
         * @param name Name of the parameter
         * @param value Value to set
         */
⋮----
/**
         * @brief Get a parameter value
         * @param name Name of the parameter
         * @param defaultValue Default value to return if parameter doesn't exist
         * @return Parameter value or default value
         */
⋮----
/**
         * @brief Check if a parameter exists
         * @param name Name of the parameter
         * @return True if parameter exists
         */
bool hasParameter(const std::string& name) const;
⋮----
/**
         * @brief Enable or disable the render stage
         * @param enabled Whether the stage should be enabled
         */
void setEnabled(bool enabled);
⋮----
/**
         * @brief Check if the render stage is enabled
         * @return True if enabled
         */
bool isEnabled() const;
⋮----
/**
         * @brief Get the name of the render stage
         * @return Name of the render stage
         */
const std::string& getName() const;
⋮----
/** Stage name */
⋮----
/** Whether the stage is enabled */
⋮----
/** Input render targets */
⋮----
/** Output render target */
⋮----
/** Parameter storage */
struct ParameterValue
⋮----
/** Map of parameters by name */
⋮----
/**
         * @brief Bind an input render target
         * @param index Index of the input
         */
void bindInput(int index = 0);
⋮----
/**
         * @brief Bind the output render target
         */
void bindOutput();
⋮----
/**
         * @brief Clear the output render target
         * @param clearColor Whether to clear color buffers
         * @param clearDepth Whether to clear depth buffer
         * @param clearStencil Whether to clear stencil buffer
         */
void clearOutput(bool clearColor = true, bool clearDepth = true, bool clearStencil = false);
⋮----
/**
         * @brief Set the viewport
         * @param x X coordinate
         * @param y Y coordinate
         * @param width Width of viewport
         * @param height Height of viewport
         */
void setViewport(int x, int y, int width, int height);
⋮----
/**
         * @brief Reset viewport to output dimensions
         */
void resetViewport();
⋮----
// Template implementation
⋮----
void RenderStage::setParameter(const std::string& name, const T& value)
⋮----
T RenderStage::getParameter(const std::string& name, const T& defaultValue) const
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/RenderSystem.h">
// -------------------------------------------------------------------------
// RenderSystem.h
⋮----
/**
     * @brief Represents an object that can be rendered
     */
struct RenderableObject
⋮----
std::shared_ptr<Mesh> mesh;               ///< The mesh to render
std::shared_ptr<Material> material;       ///< The material to use for rendering
glm::mat4 transform;                      ///< The transformation matrix
Utility::AABB bounds;                     ///< Bounds for culling
uint32_t layer;                           ///< Render layer
bool castShadows;                         ///< Whether the object casts shadows
bool receiveShadows;                      ///< Whether the object receives shadows
⋮----
/**
     * @brief Rendering layers for categorizing objects
     */
enum class RenderLayer
⋮----
Default = 1,       ///< Default rendering layer
Transparent = 2,   ///< Transparent objects
UI = 4,            ///< User interface elements
Overlay = 8,       ///< Overlay elements
Debug = 16,        ///< Debug visualization
// Add more as needed
⋮----
/**
     * @brief Core rendering subsystem with pipeline management
     *
     * The RenderSystem is responsible for managing rendering pipelines,
     * handling rendering resources, and coordinating all rendering operations.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the rendering subsystem
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the rendering state
         * @param deltaTime Time elapsed since the last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Render the scene
         */
void render() override;
⋮----
/**
         * @brief Clean up resources and shutdown the rendering subsystem
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the dependencies required by this subsystem
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Create a new render pipeline
         * @param name The name of the pipeline
         * @param pipeline The pipeline to register
         */
void createRenderPipeline(const std::string& name, std::shared_ptr<RenderPipeline> pipeline);
⋮----
/**
         * @brief Get a render pipeline by name
         * @param name The name of the pipeline to retrieve
         * @return The requested pipeline or nullptr if not found
         */
std::shared_ptr<RenderPipeline> getRenderPipeline(const std::string& name);
⋮----
/**
         * @brief Set the active render pipeline
         * @param name The name of the pipeline to set as active
         */
void setActivePipeline(const std::string& name);
⋮----
/**
         * @brief Get the name of the currently active pipeline
         * @return The name of the active pipeline
         */
const std::string& getActivePipeline() const;
⋮----
/**
         * @brief Submit an object to the render queue
         * @param renderable The object to render
         */
void submitRenderable(const RenderableObject& renderable);
⋮----
/**
         * @brief Clear all render queues
         */
void clearRenderQueue();
⋮----
/**
         * @brief Set the main camera for rendering
         * @param camera The camera to use for rendering
         */
void setMainCamera(const Camera& camera);
⋮----
/**
         * @brief Set the viewport dimensions
         * @param x The x coordinate of the viewport
         * @param y The y coordinate of the viewport
         * @param width The width of the viewport
         * @param height The height of the viewport
         */
void setViewport(int x, int y, int width, int height);
⋮----
/**
         * @brief Create a new shader
         * @param name The name of the shader
         * @return The created shader
         */
std::shared_ptr<Shader> createShader(const std::string& name);
⋮----
/**
         * @brief Create a new texture
         * @param name The name of the texture
         * @return The created texture
         */
std::shared_ptr<Texture> createTexture(const std::string& name);
⋮----
/**
         * @brief Create a new material
         * @param name The name of the material
         * @return The created material
         */
std::shared_ptr<Material> createMaterial(const std::string& name);
⋮----
/**
         * @brief Create a new mesh
         * @param name The name of the mesh
         * @return The created mesh
         */
std::shared_ptr<Mesh> createMesh(const std::string& name);
⋮----
/**
         * @brief Get the light manager
         * @return Reference to the light manager
         */
LightManager& getLightManager();
⋮----
/**
         * @brief Get the palette manager
         * @return Reference to the palette manager
         */
PaletteManager& getPaletteManager();
⋮----
/**
         * @brief Draw a debug line
         * @param start The start point of the line
         * @param end The end point of the line
         * @param color The color of the line
         */
void drawLine(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color);
⋮----
/**
         * @brief Draw a debug box
         * @param box The box to draw
         * @param color The color of the box
         */
void drawBox(const Utility::AABB& box, const glm::vec3& color);
⋮----
/**
         * @brief Draw a debug sphere
         * @param center The center of the sphere
         * @param radius The radius of the sphere
         * @param color The color of the sphere
         */
void drawSphere(const glm::vec3& center, float radius, const glm::vec3& color);
⋮----
/**
         * @brief Take a screenshot
         * @param filepath The path to save the screenshot to
         */
void takeScreenshot(const std::string& filepath);
⋮----
/**
         * @brief Render the scene to a texture
         * @param texture The texture to render to
         */
void renderToTexture(std::shared_ptr<Texture> texture);
⋮----
/**
         * @brief Get the number of draw calls in the last frame
         * @return The draw call count
         */
int getDrawCallCount() const;
⋮----
/**
         * @brief Get the number of triangles rendered in the last frame
         * @return The triangle count
         */
int getTriangleCount() const;
⋮----
/**
         * @brief Get the number of visible objects in the last frame
         * @return The visible object count
         */
int getVisibleObjectCount() const;
⋮----
/**
         * @brief Sort render queues by material and depth
         */
void sortRenderQueues();
⋮----
/**
         * @brief Submit a queue of renderables to the renderer
         * @param queue The queue to render
         */
void submitQueueToRenderer(const std::vector<RenderableObject>& queue);
⋮----
/**
         * @brief Perform frustum culling on objects
         */
void cullObjects();
⋮----
/**
         * @brief Update render statistics
         */
void updateRenderStats();
⋮----
// Core rendering state
⋮----
// Rendering queues
⋮----
// Viewport information
⋮----
// Subsystems
⋮----
// Debug rendering
⋮----
// Stats
⋮----
// Initialization flag
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/RenderTarget.h">
// -------------------------------------------------------------------------
// RenderTarget.h
⋮----
/**
     * @brief Enumeration of possible framebuffer attachment points
     */
enum class RenderTargetAttachment
⋮----
/**
     * @brief Framebuffer for off-screen rendering, post-processing, and advanced rendering techniques
     */
⋮----
/**
         * @brief Constructor
         * @param width Width of the render target in pixels
         * @param height Height of the render target in pixels
         * @param multisampled Whether to use multisampling for anti-aliasing
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the render target and create framebuffer
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Clean up resources and delete framebuffer
         */
void shutdown();
⋮----
/**
         * @brief Check if the render target has been initialized
         * @return True if initialized
         */
bool isInitialized() const;
⋮----
/**
         * @brief Add a color attachment to the render target
         * @param format Texture format to use for the attachment
         * @param index Index of the color attachment (0-7)
         * @return True if successful
         */
bool addColorAttachment(TextureFormat format, int index = 0);
⋮----
/**
         * @brief Add a depth attachment to the render target
         * @param format Texture format to use for the depth attachment
         * @return True if successful
         */
bool setDepthAttachment(TextureFormat format = TextureFormat::Depth24);
⋮----
/**
         * @brief Add a stencil attachment to the render target
         * @return True if successful
         */
bool setStencilAttachment();
⋮----
/**
         * @brief Add a combined depth-stencil attachment to the render target
         * @return True if successful
         */
bool setDepthStencilAttachment();
⋮----
/**
         * @brief Validate that the framebuffer is complete and ready for use
         * @return True if the framebuffer is valid and complete
         */
bool validate();
⋮----
/**
         * @brief Bind the framebuffer for rendering
         */
void bind();
⋮----
/**
         * @brief Unbind the framebuffer and return to default framebuffer
         */
void unbind();
⋮----
/**
         * @brief Clear the contents of the framebuffer
         * @param clearColor Whether to clear the color buffers
         * @param clearDepth Whether to clear the depth buffer
         * @param clearStencil Whether to clear the stencil buffer
         */
void clear(bool clearColor = true, bool clearDepth = true, bool clearStencil = false);
⋮----
/**
         * @brief Clear a specific color attachment with a color
         * @param index Index of the color attachment to clear
         * @param color Color to clear with
         */
void clearColor(int index, const glm::vec4& color);
⋮----
/**
         * @brief Get a color attachment texture
         * @param index Index of the color attachment
         * @return Shared pointer to the texture
         */
⋮----
/**
         * @brief Get the depth attachment texture
         * @return Shared pointer to the texture
         */
⋮----
/**
         * @brief Get the stencil attachment texture
         * @return Shared pointer to the texture
         */
⋮----
/**
         * @brief Get the combined depth-stencil attachment texture
         * @return Shared pointer to the texture
         */
⋮----
/**
         * @brief Copy contents from this render target to another
         * @param target Target render target to blit to
         * @param colorBuffer Whether to copy color buffers
         * @param depthBuffer Whether to copy depth buffer
         * @param stencilBuffer Whether to copy stencil buffer
         */
void blit(std::shared_ptr<RenderTarget> target,
⋮----
/**
         * @brief Resize the render target and all attachments
         * @param width New width in pixels
         * @param height New height in pixels
         */
void resize(int width, int height);
⋮----
/**
         * @brief Read pixels from the render target into CPU memory
         * @param x X coordinate to start reading from
         * @param y Y coordinate to start reading from
         * @param width Width of the region to read
         * @param height Height of the region to read
         * @param data Pointer to memory to store the pixel data
         * @param format Format to read the pixels in
         */
void readPixels(int x, int y, int width, int height, void* data,
⋮----
/**
         * @brief Get the OpenGL framebuffer ID
         * @return OpenGL framebuffer ID
         */
uint32_t getFramebufferID() const;
⋮----
/**
         * @brief Get the width of the render target
         * @return Width in pixels
         */
int getWidth() const;
⋮----
/**
         * @brief Get the height of the render target
         * @return Height in pixels
         */
int getHeight() const;
⋮----
/**
         * @brief Check if the render target is multisampled
         * @return True if multisampled
         */
bool isMultisampled() const;
⋮----
/**
         * @brief Get the multisample count
         * @return Number of samples, or 1 if not multisampled
         */
int getMultisampleCount() const;
⋮----
/**
         * @brief Create and bind textures to attachment points
         * @return True if successful
         */
bool createAttachments();
⋮----
/**
         * @brief Resolve multisampled textures to regular textures
         */
void resolveMultisampledTextures();
⋮----
/**
         * @brief Check the framebuffer status
         * @return True if the framebuffer is complete
         */
bool checkStatus();
⋮----
uint32_t m_resolveFramebufferID; // For multisampled targets
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Shader.h">
// -------------------------------------------------------------------------
// Shader.h
⋮----
/**
     * @brief Shader types supported by the engine
     */
enum class ShaderType
⋮----
/**
     * @brief Information about shader attribute (input)
     */
struct ShaderAttribute
⋮----
/**
     * @brief Encapsulates OpenGL shader program functionality
     *
     * The Shader class handles loading, compiling, and linking of
     * shader programs with support for hot-reloading and efficient
     * uniform management.
     */
⋮----
/**
         * @brief Constructor
         * @param name Unique name for this shader resource
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~Shader();
⋮----
/**
         * @brief Load the shader from associated source files
         * @return True if loading was successful
         */
bool load() override;
⋮----
/**
         * @brief Unload the shader and release GPU resources
         */
void unload() override;
⋮----
/**
         * @brief Handle hot-reloading of shader sources
         * @return True if reload was successful
         */
bool onReload() override;
⋮----
/**
         * @brief Compile and link all shader stages
         * @return True if compilation was successful
         */
bool compile();
⋮----
/**
         * @brief Bind the shader program for rendering
         */
void bind();
⋮----
/**
         * @brief Unbind the shader program
         */
void unbind();
⋮----
/**
         * @brief Check if the shader program is valid
         * @return True if the program is valid and ready for use
         */
bool isValid() const;
⋮----
/**
         * @brief Get the file paths for all shader stages
         * @return Map of shader types to file paths
         */
const std::unordered_map<ShaderType, std::string>& getFilePaths() const
⋮----
/**
         * @brief Set the source file for a shader stage
         * @param type The type of shader stage
         * @param filepath Path to the shader source file
         */
void setSourceFile(ShaderType type, const std::string& filepath);
⋮----
/**
         * @brief Set the source code for a shader stage directly
         * @param type The type of shader stage
         * @param source The shader source code
         */
void setSource(ShaderType type, const std::string& source);
⋮----
/**
         * @brief Get the attributes (inputs) of the shader
         * @return Vector of shader attributes
         */
const std::vector<ShaderAttribute>& getAttributes() const;
⋮----
/**
         * @brief Dispatch a compute shader
         * @param numGroupsX Number of work groups in X dimension
         * @param numGroupsY Number of work groups in Y dimension
         * @param numGroupsZ Number of work groups in Z dimension
         */
void dispatchCompute(uint32_t numGroupsX, uint32_t numGroupsY, uint32_t numGroupsZ);
⋮----
/**
         * @brief Set a float uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setFloat(const std::string& name, float value);
⋮----
/**
         * @brief Set an integer uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setInt(const std::string& name, int value);
⋮----
/**
         * @brief Set a vec2 uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setVec2(const std::string& name, const glm::vec2& value);
⋮----
/**
         * @brief Set a vec3 uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setVec3(const std::string& name, const glm::vec3& value);
⋮----
/**
         * @brief Set a vec4 uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setVec4(const std::string& name, const glm::vec4& value);
⋮----
/**
         * @brief Set a mat3 uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setMat3(const std::string& name, const glm::mat3& value);
⋮----
/**
         * @brief Set a mat4 uniform value
         * @param name The uniform name
         * @param value The value to set
         */
void setMat4(const std::string& name, const glm::mat4& value);
⋮----
/**
         * @brief Set a generic uniform value
         * @tparam T The uniform type
         * @param name The uniform name
         * @param value The value to set
         */
⋮----
void setUniform(const std::string& name, const T& value)
⋮----
setFloat(name, value);
⋮----
else if constexpr (std::is_same_v<T, glm::vec2>)
⋮----
else if constexpr (std::is_same_v<T, glm::vec3>)
⋮----
else if constexpr (std::is_same_v<T, glm::vec4>)
⋮----
else if constexpr (std::is_same_v<T, glm::mat3>)
⋮----
else if constexpr (std::is_same_v<T, glm::mat4>)
⋮----
/**
         * @brief Get the OpenGL shader type constant from ShaderType
         * @param type The shader type
         * @return The OpenGL shader type enum value
         */
⋮----
/**
         * @brief Get the location of a uniform
         * @param name The uniform name
         * @return The uniform location or -1 if not found
         */
GLint getUniformLocation(const std::string& name);
⋮----
/**
         * @brief Compile an individual shader stage
         * @param type The shader type
         * @param shaderID Output parameter for the shader ID
         * @return True if compilation succeeded
         */
bool compileShader(ShaderType type, GLuint& shaderID);
⋮----
/**
         * @brief Extract attribute information from the program
         */
void extractAttributes();
⋮----
/**
         * @brief Load shader source from file
         * @param filepath Path to the shader file
         * @return The shader source code
         */
⋮----
/**
         * @brief Log shader compilation errors
         * @param shader Shader ID to check for errors
         */
void logShaderError(GLuint shader);
⋮----
/**
         * @brief Log program linking errors
         * @param program Program ID to check for errors
         */
void logProgramError(GLuint program);
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/ShaderManager.h">
// -------------------------------------------------------------------------
// ShaderManager.h
⋮----
/**
     * @brief Manages shader resources, provides caching and utility methods
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~ShaderManager();
⋮----
/**
         * @brief Initialize the shader manager
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the shader manager (checks for hot-reloading)
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Render debug info (if enabled)
         */
void render() override;
⋮----
/**
         * @brief Shut down the shader manager and release resources
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get dependencies required by this subsystem
         * @return List of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Create or get a shader
         * @param name The shader name
         * @return Shared pointer to the shader
         */
std::shared_ptr<Shader> createShader(const std::string& name);
⋮----
/**
         * @brief Get an existing shader
         * @param name The shader name
         * @return Shared pointer to the shader or nullptr if not found
         */
std::shared_ptr<Shader> getShader(const std::string& name);
⋮----
/**
         * @brief Create a standard shader with vertex and fragment stages
         * @param name The shader name
         * @param vertexPath Path to vertex shader
         * @param fragmentPath Path to fragment shader
         * @return Shared pointer to the created shader
         */
std::shared_ptr<Shader> createStandardShader(
⋮----
/**
         * @brief Create a compute shader
         * @param name The shader name
         * @param computePath Path to compute shader
         * @return Shared pointer to the created shader
         */
std::shared_ptr<Shader> createComputeShader(
⋮----
/**
         * @brief Check if shader hot-reloading is enabled
         * @return True if hot-reloading is enabled
         */
bool isHotReloadingEnabled() const
⋮----
/**
         * @brief Enable or disable shader hot-reloading
         * @param enabled Whether hot-reloading should be enabled
         */
void setHotReloadingEnabled(bool enabled)
⋮----
/**
         * @brief Reload all shaders
         */
void reloadAllShaders();
⋮----
/**
         * @brief Check for modified shader files
         */
⋮----
const float m_hotReloadCheckInterval = 1.0f; // Check every second
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Rendering/Texture.h">
// -------------------------------------------------------------------------
// Texture.h
⋮----
/**
     * @brief Defines texture filtering modes for magnification and minification
     */
enum class TextureFilterMode
⋮----
Nearest,               ///< Nearest neighbor filtering (pixel art)
Linear,                ///< Linear filtering (smoother appearance)
NearestMipmapNearest,  ///< Nearest filtering with nearest mipmap level
LinearMipmapNearest,   ///< Linear filtering with nearest mipmap level
NearestMipmapLinear,   ///< Nearest filtering with linear mipmap interpolation
LinearMipmapLinear     ///< Linear filtering with linear mipmap interpolation (trilinear)
⋮----
/**
     * @brief Defines texture edge handling modes
     */
enum class TextureWrapMode
⋮----
Repeat,          ///< Texture repeats at boundaries
MirroredRepeat,  ///< Texture mirrors at boundaries
ClampToEdge,     ///< Texture coordinates are clamped to edge
ClampToBorder    ///< Texture coordinates beyond boundary use border color
⋮----
/**
     * @brief Defines internal texture formats for storage
     */
enum class TextureFormat
⋮----
// Standard formats
R8,              ///< 8-bit single channel (red)
RG8,             ///< 8-bit dual channel (red, green)
RGB8,            ///< 8-bit three channel (red, green, blue)
RGBA8,           ///< 8-bit four channel (red, green, blue, alpha)
⋮----
// Float formats (16-bit)
R16F,            ///< 16-bit float single channel
RG16F,           ///< 16-bit float dual channel
RGB16F,          ///< 16-bit float three channel
RGBA16F,         ///< 16-bit float four channel
⋮----
// Float formats (32-bit)
R32F,            ///< 32-bit float single channel
RG32F,           ///< 32-bit float dual channel
RGB32F,          ///< 32-bit float three channel
RGBA32F,         ///< 32-bit float four channel
⋮----
// Special float formats
R11F_G11F_B10F,  ///< Packed format with 11 bits each for R and G, 10 bits for B
RGB9_E5,         ///< Shared exponent format
⋮----
// Integer formats
R8I,             ///< 8-bit signed integer, single channel
RG8I,            ///< 8-bit signed integer, dual channel
RGB8I,           ///< 8-bit signed integer, three channel
RGBA8I,          ///< 8-bit signed integer, four channel
R16I,            ///< 16-bit signed integer, single channel
RG16I,           ///< 16-bit signed integer, dual channel
RGB16I,          ///< 16-bit signed integer, three channel
RGBA16I,         ///< 16-bit signed integer, four channel
⋮----
// Unsigned integer formats
R8UI,            ///< 8-bit unsigned integer, single channel
RG8UI,           ///< 8-bit unsigned integer, dual channel
RGB8UI,          ///< 8-bit unsigned integer, three channel
RGBA8UI,         ///< 8-bit unsigned integer, four channel
R16UI,           ///< 16-bit unsigned integer, single channel
RG16UI,          ///< 16-bit unsigned integer, dual channel
RGB16UI,         ///< 16-bit unsigned integer, three channel
RGBA16UI,        ///< 16-bit unsigned integer, four channel
⋮----
// Special formats
RGB10_A2,        ///< 10-bit per RGB component with 2-bit alpha
⋮----
// sRGB formats
SRGB8,           ///< 8-bit sRGB
SRGB8_A8,        ///< 8-bit sRGB with 8-bit alpha
⋮----
// Depth/stencil formats
Depth16,         ///< 16-bit depth component
Depth24,         ///< 24-bit depth component
Depth32F,        ///< 32-bit float depth component
Stencil8,        ///< 8-bit stencil component
Depth24Stencil8, ///< 24-bit depth with 8-bit stencil
⋮----
// Compressed formats - DXT
DXT1_RGB,        ///< DXT1 compressed (no alpha)
DXT1_RGBA,       ///< DXT1 compressed (1-bit alpha)
DXT3,            ///< DXT3 compressed (explicit alpha)
DXT5,            ///< DXT5 compressed (interpolated alpha)
⋮----
// Compressed formats - ETC2
ETC2_RGB,        ///< ETC2 compressed RGB
ETC2_RGBA,       ///< ETC2 compressed RGBA
⋮----
// Compressed formats - ASTC
ASTC_4x4,        ///< ASTC compressed 4x4 blocks
ASTC_8x8         ///< ASTC compressed 8x8 blocks
⋮----
/**
     * @brief 2D image resource with pixel art optimizations
     *
     * Texture class represents 2D image resources that can be loaded from files,
     * created from raw data, or generated procedurally. It provides special
     * handling for pixel art with features like pixel-perfect filtering and
     * palette mapping.
     */
⋮----
/**
         * @brief Constructor
         * @param name Resource name for identification and tracking
         */
⋮----
/**
         * @brief Destructor
         *
         * Automatically releases GPU resources if not already unloaded
         */
virtual ~Texture();
⋮----
/**
         * @brief Initializes the texture with default settings
         * @return True if initialization was successful, false otherwise
         *
         * Creates an empty texture handle without allocating storage.
         */
bool initialize();
⋮----
/**
         * @brief Creates an empty texture with specified dimensions and format
         * @param width Width of the texture in pixels
         * @param height Height of the texture in pixels
         * @param format Internal format for texture storage (default: RGBA8)
         * @return True if creation was successful, false otherwise
         *
         * Creates a new texture with uninitialized content. Useful for render targets
         * or textures that will be filled with data later.
         */
bool initialize(int width, int height, TextureFormat format = TextureFormat::RGBA8);
⋮----
/**
         * @brief Creates an empty texture with specified dimensions and format
         * @param width Width of the texture in pixels
         * @param height Height of the texture in pixels
         * @param format Internal format for texture storage (default: RGBA8)
         * @param multisampleCount The multisample count
         * @return True if creation was successful, false otherwise
         *
         * Creates a new texture with uninitialized content. Useful for render targets
         * or textures that will be filled with data later.
         */
bool initialize(int width, int height, TextureFormat format, int multisampleCount);
⋮----
/**
         * @brief Creates a texture from provided pixel data
         * @param width Width of the texture in pixels
         * @param height Height of the texture in pixels
         * @param format Internal format for texture storage
         * @param data Pointer to the raw pixel data
         * @return True if creation was successful, false otherwise
         *
         * The data pointer should point to contiguous memory with size at least
         * width × height × channels bytes, where channels depends on the format.
         */
bool initialize(int width, int height, TextureFormat format, const void* data);
⋮----
/**
         * @brief Sets the raw pixel data of the texture
         * @param data Pointer to the raw pixel data
         */
void setData(const void* data);
⋮----
/**
         * @brief Loads the texture from its source file path
         * @return True if loading was successful, false otherwise
         *
         * Uses the resource path to load image data using stb_image library.
         * Supports PNG, JPEG, BMP, TGA, and other common formats.
         */
bool load() override;
⋮----
/**
         * @brief Releases all texture resources from GPU and CPU memory
         *
         * Deletes the OpenGL texture and releases any pixel data stored on the CPU.
         */
void unload() override;
⋮----
/**
         * @brief Reloads the texture from its source while preserving settings
         * @return True if reloading was successful, false otherwise
         *
         * Used for hot-reloading when the source file changes. Preserves
         * filtering mode, wrap mode, and pixel grid alignment settings.
         */
bool onReload() override;
⋮----
/**
         * @brief Binds the texture to the specified texture unit for rendering
         * @param textureUnit The OpenGL texture unit to bind to (default: 0)
         *
         * Automatically loads the texture if not already loaded.
         */
void bind(uint32_t textureUnit = 0);
⋮----
/**
         * @brief Unbinds the texture from the current GL context
         *
         * Binds texture ID 0 to the current active texture unit.
         */
void unbind();
⋮----
/**
         * @brief Sets pixel grid alignment mode for pixel art
         * @param enabled True to enable pixel-perfect filtering, false for standard filtering
         *
         * When enabled, forces nearest-neighbor filtering regardless of the filter mode
         * to maintain sharp pixel edges for pixel art.
         */
void setPixelGridAlignment(bool enabled);
⋮----
/**
         * @brief Gets the current pixel grid alignment mode
         * @return True if pixel grid alignment is enabled, false otherwise
         */
bool isPixelGridAligned() const;
⋮----
/**
         * @brief Sets the texture filtering mode for magnification and minification
         * @param mode The filtering mode to use
         *
         * Has no effect if pixel grid alignment is enabled, which forces nearest filtering.
         */
void setFilterMode(TextureFilterMode mode);
⋮----
/**
         * @brief Sets the texture wrapping mode for texture coordinates
         * @param mode The wrapping mode to use
         *
         * Controls how texture coordinates outside the [0,1] range are handled.
         */
void setWrapMode(TextureWrapMode mode);
⋮----
/**
         * @brief Gets the current texture filtering mode
         * @return The current filtering mode
         */
TextureFilterMode getFilterMode() const;
⋮----
/**
         * @brief Gets the current texture wrapping mode
         * @return The current wrapping mode
         */
TextureWrapMode getWrapMode() const;
⋮----
/**
         * @brief Sets the multisample count for antialiasing
         * @param samples Number of samples (0 = no multisampling)
         * @return True if setting was successful, false otherwise
         */
bool setMultisampleCount(int samples);
⋮----
/**
         * @brief Gets the current multisample count
         * @return Number of multisample samples (0 if not multisampled)
         */
int getMultisampleCount() const
⋮----
/**
         * @brief Generates mipmaps for the texture
         *
         * Creates a full mipmap chain for the texture to improve rendering quality
         * at different scales. Only has an effect if a mipmap filtering mode is set.
         */
void generateMipmaps();
⋮----
/**
         * @brief Checks if mipmaps have been generated for this texture
         * @return True if mipmaps exist, false otherwise
         */
bool hasMipmaps() const;
⋮----
/**
         * @brief Sets or changes the texture dimensions
         * @param width New width in pixels
         * @param height New height in pixels
         * @param preserveData Whether to attempt to preserve existing pixel data
         * @return True if resizing was successful, false otherwise
         */
bool resize(int width, int height, bool preserveData = false);
⋮----
/**
         * @brief Sets or changes the texture format
         * @param format New internal texture format
         * @param preserveData Whether to attempt to preserve existing pixel data
         * @return True if format change was successful, false otherwise
         */
bool setFormat(TextureFormat format, bool preserveData = false);
⋮----
/**
         * @brief Sets the color of a specific pixel
         * @param x X-coordinate of the pixel
         * @param y Y-coordinate of the pixel
         * @param color The color to set in RGBA format (0.0-1.0 range)
         *
         * Updates both CPU cache and GPU texture. Useful for pixel-by-pixel modification
         * or procedural texture generation.
         */
void setPixel(int x, int y, const glm::vec4& color);
⋮----
/**
         * @brief Gets the color of a specific pixel
         * @param x X-coordinate of the pixel
         * @param y Y-coordinate of the pixel
         * @return The pixel color in RGBA format (0.0-1.0 range)
         *
         * Reads from CPU cache if available. If not, returns black.
         */
⋮----
/**
         * @brief Updates a region of the texture with new pixel data
         * @param data Pointer to the new pixel data
         * @param x X-coordinate of the region's top-left corner (default: 0)
         * @param y Y-coordinate of the region's top-left corner (default: 0)
         * @param width Width of the region to update (default: 0 for full width)
         * @param height Height of the region to update (default: 0 for full height)
         *
         * More efficient than setting individual pixels for large regions.
         * If width or height is 0, uses the full texture dimensions.
         */
void update(const void* data, int x = 0, int y = 0, int width = 0, int height = 0);
⋮----
/**
         * @brief Maps texture colors to the nearest colors in the provided palette
         * @param paletteManager The palette manager containing color constraints
         *
         * Used for pixel art to enforce a consistent color palette. This operation
         * modifies the texture's pixel data.
         */
void applyPaletteMapping(std::shared_ptr<class PaletteManager> paletteManager);
⋮----
/**
         * @brief Gets the OpenGL texture ID
         * @return The OpenGL texture handle
         */
uint32_t getID() const;
⋮----
/**
         * @brief Gets the texture width
         * @return Width in pixels
         */
int getWidth() const;
⋮----
/**
         * @brief Gets the texture height
         * @return Height in pixels
         */
int getHeight() const;
⋮----
/**
         * @brief Gets the texture format
         * @return The internal format of the texture
         */
TextureFormat getFormat() const;
⋮----
uint32_t m_textureID;               ///< OpenGL texture handle
int m_width;                         ///< Texture width in pixels
int m_height;                        ///< Texture height in pixels
TextureFormat m_format;              ///< Internal texture format
TextureFilterMode m_filterMode;      ///< Current filtering mode
TextureWrapMode m_wrapMode;          ///< Current wrapping mode
bool m_hasMipmaps;                   ///< Whether mipmaps have been generated
bool m_pixelGridAligned;             ///< Whether pixel-perfect mode is enabled
bool m_hasPixelData;                 ///< Whether CPU-side pixel data is available
std::unique_ptr<uint8_t[]> m_pixelData; ///< CPU-side pixel data cache
int m_channels;                      ///< Number of color channels
int m_multisampleCount;              ///< Number of multisample samples (0 = no multisampling)
⋮----
/**
         * @brief Loads texture data from a file
         * @param filepath Path to the image file
         * @return True if loading was successful, false otherwise
         *
         * Internal implementation used by load() method.
         */
bool loadFromFile(const std::string& filepath);
⋮----
/**
         * @brief Sets texture parameters based on current settings
         *
         * Applies filter mode, wrap mode, and other parameters to the bound texture.
         */
void setTextureParameters();
⋮----
/**
         * @brief Gets the number of color channels for a format
         * @param format The texture format to check
         * @return Number of color channels (1-4)
         */
int getFormatChannelCount(TextureFormat format);
⋮----
/**
         * @brief Converts texture format enum to OpenGL format constants
         * @param format The texture format to convert
         * @param internalFormat [out] OpenGL internal format value
         * @param dataFormat [out] OpenGL data format value
         * @param dataType [out] OpenGL data type value
         *
         * Maps PixelCraft texture formats to the appropriate OpenGL constants.
         */
void convertFormat(TextureFormat format, uint32_t& internalFormat, uint32_t& dataFormat, uint32_t& dataType);
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="include/Utility/AABB.h">
// -------------------------------------------------------------------------
// AABB.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Axis-Aligned Bounding Box for efficient collision detection and spatial partitioning
     *
     * An AABB represents a box in 3D space with faces aligned to the coordinate axes,
     * defined by minimum and maximum points in each dimension.
     */
⋮----
/**
         * @brief Default constructor, creates an invalid (empty) AABB
         */
⋮----
/**
         * @brief Construct from min and max points
         * @param min The minimum point of the box (smallest values in each dimension)
         * @param max The maximum point of the box (largest values in each dimension)
         */
⋮----
/**
         * @brief Construct from center and half extents
         * @param center The center point of the box
         * @param halfExtentX The half-size in X dimension
         * @param halfExtentY The half-size in Y dimension
         * @param halfExtentZ The half-size in Z dimension
         */
⋮----
/**
         * @brief Create an AABB that contains all given points
         * @param points A collection of points to enclose
         * @return AABB containing all points
         */
static AABB createFromPoints(const std::vector<glm::vec3>& points);
⋮----
/**
         * @brief Create an AABB that contains a sphere
         * @param center The center of the sphere
         * @param radius The radius of the sphere
         * @return AABB containing the sphere
         */
static AABB createFromSphere(const glm::vec3& center, float radius);
⋮----
/**
         * @brief Create an AABB that contains a transformed AABB
         * @param aabb The source AABB
         * @param transform The transformation matrix to apply
         * @return New AABB containing the transformed source AABB
         */
static AABB createFromTransformedAABB(const AABB& aabb, const glm::mat4& transform);
⋮----
/**
         * @brief Get the minimum point of the box
         * @return The minimum point (smallest values in each dimension)
         */
⋮----
/**
         * @brief Get the maximum point of the box
         * @return The maximum point (largest values in each dimension)
         */
⋮----
/**
         * @brief Set the minimum point of the box
         * @param min The new minimum point
         */
void setMin(const glm::vec3& min);
⋮----
/**
         * @brief Set the maximum point of the box
         * @param max The new maximum point
         */
void setMax(const glm::vec3& max);
⋮----
/**
         * @brief Get the center point of the box
         * @return The center point
         */
⋮----
/**
         * @brief Get the half-extents of the box
         * @return Half-sizes in each dimension
         */
⋮----
/**
         * @brief Get the full size of the box
         * @return Full sizes in each dimension
         */
⋮----
/**
         * @brief Get the volume of the box
         * @return The volume
         */
float getVolume() const;
⋮----
/**
         * @brief Get the surface area of the box
         * @return The surface area
         */
float getSurfaceArea() const;
⋮----
/**
         * @brief Get the length of the longest axis
         * @return The length of the longest axis
         */
float getLongestAxis() const;
⋮----
/**
         * @brief Get the index of the longest axis (0=X, 1=Y, 2=Z)
         * @return The index of the longest axis
         */
int getLongestAxisIndex() const;
⋮----
/**
         * @brief Get the length of the shortest axis
         * @return The length of the shortest axis
         */
float getShortestAxis() const;
⋮----
/**
         * @brief Get the index of the shortest axis (0=X, 1=Y, 2=Z)
         * @return The index of the shortest axis
         */
int getShortestAxisIndex() const;
⋮----
/**
         * @brief Get a specific corner of the box
         * @param index Corner index (0-7, binary pattern corresponds to (x,y,z))
         * @return The corner point
         */
glm::vec3 getCorner(int index) const;
⋮----
/**
         * @brief Get all corners of the box
         * @return Array of all 8 corner points
         */
std::array<glm::vec3, 8> getAllCorners() const;
⋮----
/**
         * @brief Expand the box in all directions by a fixed amount
         * @param amount The distance to expand in each direction
         */
void expand(float amount);
⋮----
/**
         * @brief Expand the box by different amounts in each direction
         * @param amount The distances to expand in each direction
         */
void expand(const glm::vec3& amount);
⋮----
/**
         * @brief Move the box by a vector
         * @param delta The translation vector
         */
void translate(const glm::vec3& delta);
⋮----
/**
         * @brief Apply a transformation to the box
         * @param transform The transformation matrix
         */
void transform(const glm::mat4& transform);
⋮----
/**
         * @brief Create a new AABB that contains both this box and another
         * @param other The other AABB to merge with
         * @return New AABB containing both boxes
         */
AABB merge(const AABB& other) const;
⋮----
/**
         * @brief Expand the box to include a point
         * @param point The point to include
         */
void include(const glm::vec3& point);
⋮----
/**
         * @brief Expand the box to include another AABB
         * @param other The AABB to include
         */
void include(const AABB& other);
⋮----
/**
         * @brief Check if the box is empty (zero volume)
         * @return True if the box is empty
         */
bool isEmpty() const;
⋮----
/**
         * @brief Check if the box is valid (min <= max in all dimensions)
         * @return True if the box is valid
         */
bool isValid() const;
⋮----
/**
         * @brief Check if the box contains a point
         * @param point The point to test
         * @return True if the point is inside or on the box
         */
bool contains(const glm::vec3& point) const;
⋮----
/**
         * @brief Check if the box fully contains another AABB
         * @param other The AABB to test
         * @return True if the other box is fully contained
         */
bool contains(const AABB& other) const;
⋮----
/**
         * @brief Check if the box intersects with another AABB
         * @param other The AABB to test
         * @return True if the boxes intersect
         */
bool intersects(const AABB& other) const;
⋮----
/**
         * @brief Check if the box intersects with a ray and find intersection distances
         * @param ray The ray to test
         * @param tMin Output parameter for near intersection distance
         * @param tMax Output parameter for far intersection distance
         * @return True if the ray intersects the box
         */
bool intersects(const Ray& ray, float& tMin, float& tMax) const;
⋮----
/**
         * @brief Check if the box intersects with a frustum
         * @param frustum The frustum to test
         * @return True if the box intersects the frustum
         */
bool intersects(const Frustum& frustum) const;
⋮----
/**
         * @brief Check if the box intersects with a sphere
         * @param center The center point of the sphere
         * @param radius The radius of the sphere
         * @return True if the box intersects the sphere
         */
bool intersects(const glm::vec3& center, float radius) const;
⋮----
/**
         * @brief Get the closest point on the box to a given point
         * @param point The reference point
         * @return The closest point on the box surface or inside
         */
glm::vec3 getClosestPoint(const glm::vec3& point) const;
⋮----
/**
         * @brief Get the squared distance from a point to the box
         * @param point The reference point
         * @return Squared distance (0 if point is inside)
         */
float getDistanceSquared(const glm::vec3& point) const;
⋮----
/**
         * @brief Get the distance from a point to the box
         * @param point The reference point
         * @return Distance (0 if point is inside)
         */
float getDistance(const glm::vec3& point) const;
⋮----
/**
         * @brief Draw the box for debugging purposes
         * @param color The color to use for drawing
         */
void debugDraw(const glm::vec3& color = glm::vec3(1.0f, 1.0f, 1.0f)) const;
⋮----
glm::vec3 m_min; ///< Minimum point (smallest values in each dimension)
glm::vec3 m_max; ///< Maximum point (largest values in each dimension)
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Color.h">
// -------------------------------------------------------------------------
// Color.h
⋮----
/**
     * @brief Color representation and manipulation class
     *
     * Provides storage and manipulation of RGBA color values with conversions
     * between different color spaces and color manipulation operations.
     */
⋮----
/**
         * @brief Default constructor
         * Creates a black, fully opaque color (0, 0, 0, 1)
         */
⋮----
/**
         * @brief Constructor from float components
         * @param r Red component (0.0-1.0)
         * @param g Green component (0.0-1.0)
         * @param b Blue component (0.0-1.0)
         * @param a Alpha component (0.0-1.0)
         */
⋮----
/**
         * @brief Constructor from byte components
         * @param r Red component (0-255)
         * @param g Green component (0-255)
         * @param b Blue component (0-255)
         * @param a Alpha component (0-255)
         */
⋮----
/**
         * @brief Constructor from 32-bit integer RGBA
         * @param rgba Color in 0xRRGGBBAA format
         */
⋮----
/**
         * @brief Create a color from HSV values
         * @param h Hue component (0.0-360.0)
         * @param s Saturation component (0.0-1.0)
         * @param v Value component (0.0-1.0)
         * @param a Alpha component (0.0-1.0)
         * @return The resulting color
         */
static Color fromHSV(float h, float s, float v, float a = 1.0f);
⋮----
/**
         * @brief Create a color from HSL values
         * @param h Hue component (0.0-360.0)
         * @param s Saturation component (0.0-1.0)
         * @param l Lightness component (0.0-1.0)
         * @param a Alpha component (0.0-1.0)
         * @return The resulting color
         */
static Color fromHSL(float h, float s, float l, float a = 1.0f);
⋮----
/**
         * @brief Create a color from a hex string
         * @param hexString Color in "#RRGGBB" or "#RRGGBBAA" format
         * @return The resulting color
         */
static Color fromString(const std::string& hexString);
⋮----
/**
         * @brief Linearly interpolate between two colors
         * @param a First color
         * @param b Second color
         * @param t Interpolation factor (0.0-1.0)
         * @return The interpolated color
         */
static Color lerp(const Color& a, const Color& b, float t);
⋮----
/**
         * @brief Create a random color
         * @param alpha Alpha value for the random color (0.0-1.0)
         * @return A random color
         */
static Color random(float alpha = 1.0f);
⋮----
/**
         * @brief Get the red component (float)
         * @return Red component (0.0-1.0)
         */
float r() const;
⋮----
/**
         * @brief Get the green component (float)
         * @return Green component (0.0-1.0)
         */
float g() const;
⋮----
/**
         * @brief Get the blue component (float)
         * @return Blue component (0.0-1.0)
         */
float b() const;
⋮----
/**
         * @brief Get the alpha component (float)
         * @return Alpha component (0.0-1.0)
         */
float a() const;
⋮----
/**
         * @brief Set the red component (float)
         * @param r Red component (0.0-1.0)
         */
void setR(float r);
⋮----
/**
         * @brief Set the green component (float)
         * @param g Green component (0.0-1.0)
         */
void setG(float g);
⋮----
/**
         * @brief Set the blue component (float)
         * @param b Blue component (0.0-1.0)
         */
void setB(float b);
⋮----
/**
         * @brief Set the alpha component (float)
         * @param a Alpha component (0.0-1.0)
         */
void setA(float a);
⋮----
/**
         * @brief Get the red component (byte)
         * @return Red component (0-255)
         */
uint8_t rByte() const;
⋮----
/**
         * @brief Get the green component (byte)
         * @return Green component (0-255)
         */
uint8_t gByte() const;
⋮----
/**
         * @brief Get the blue component (byte)
         * @return Blue component (0-255)
         */
uint8_t bByte() const;
⋮----
/**
         * @brief Get the alpha component (byte)
         * @return Alpha component (0-255)
         */
uint8_t aByte() const;
⋮----
/**
         * @brief Set the red component (byte)
         * @param r Red component (0-255)
         */
void setRByte(uint8_t r);
⋮----
/**
         * @brief Set the green component (byte)
         * @param g Green component (0-255)
         */
void setGByte(uint8_t g);
⋮----
/**
         * @brief Set the blue component (byte)
         * @param b Blue component (0-255)
         */
void setBByte(uint8_t b);
⋮----
/**
         * @brief Set the alpha component (byte)
         * @param a Alpha component (0-255)
         */
void setAByte(uint8_t a);
⋮----
/**
         * @brief Get the RGB components as a vec3
         * @return RGB components (0.0-1.0)
         */
glm::vec3 rgb() const;
⋮----
/**
         * @brief Get the RGBA components as a vec4
         * @return RGBA components (0.0-1.0)
         */
glm::vec4 rgba() const;
⋮----
/**
         * @brief Set the RGB components from a vec3
         * @param rgb RGB components (0.0-1.0)
         */
void setRGB(const glm::vec3& rgb);
⋮----
/**
         * @brief Set the RGBA components from a vec4
         * @param rgba RGBA components (0.0-1.0)
         */
void setRGBA(const glm::vec4& rgba);
⋮----
/**
         * @brief Convert the color to a 32-bit integer
         * @return Color in 0xRRGGBBAA format
         */
uint32_t toInt() const;
⋮----
/**
         * @brief Set the color from a 32-bit integer
         * @param rgba Color in 0xRRGGBBAA format
         */
void setFromInt(uint32_t rgba);
⋮----
/**
         * @brief Convert the color to HSV space
         * @return HSV values (hue: 0-360, saturation: 0-1, value: 0-1)
         */
glm::vec3 toHSV() const;
⋮----
/**
         * @brief Convert the color to HSL space
         * @return HSL values (hue: 0-360, saturation: 0-1, lightness: 0-1)
         */
glm::vec3 toHSL() const;
⋮----
/**
         * @brief Set the color from HSV values
         * @param h Hue component (0.0-360.0)
         * @param s Saturation component (0.0-1.0)
         * @param v Value component (0.0-1.0)
         */
void setHSV(float h, float s, float v);
⋮----
/**
         * @brief Set the color from HSL values
         * @param h Hue component (0.0-360.0)
         * @param s Saturation component (0.0-1.0)
         * @param l Lightness component (0.0-1.0)
         */
void setHSL(float h, float s, float l);
⋮----
/**
         * @brief Convert the color to a hex string
         * @param includeAlpha Whether to include the alpha component
         * @return Hex string in "#RRGGBB" or "#RRGGBBAA" format
         */
std::string toHexString(bool includeAlpha = false) const;
⋮----
/**
         * @brief Convert the color to a human-readable string
         * @return String representation of the color
         */
std::string toString() const;
⋮----
/**
         * @brief Create a copy of this color with a different alpha
         * @param alpha New alpha value (0.0-1.0)
         * @return New color with the specified alpha
         */
Color withAlpha(float alpha) const;
⋮----
/**
         * @brief Increase the saturation of the color
         * @param amount Amount to increase saturation by (0.0-1.0)
         * @return Saturated color
         */
Color saturate(float amount) const;
⋮----
/**
         * @brief Decrease the saturation of the color
         * @param amount Amount to decrease saturation by (0.0-1.0)
         * @return Desaturated color
         */
Color desaturate(float amount) const;
⋮----
/**
         * @brief Lighten the color
         * @param amount Amount to lighten by (0.0-1.0)
         * @return Lightened color
         */
Color lighten(float amount) const;
⋮----
/**
         * @brief Darken the color
         * @param amount Amount to darken by (0.0-1.0)
         * @return Darkened color
         */
Color darken(float amount) const;
⋮----
/**
         * @brief Get the complementary color
         * @return Complementary color (opposite on the color wheel)
         */
Color complementary() const;
⋮----
/**
         * @brief Blend with another color using linear interpolation
         * @param other Color to blend with
         * @param factor Blend factor (0.0-1.0)
         * @return Blended color
         */
Color blend(const Color& other, float factor) const;
⋮----
/**
         * @brief Multiply blend mode
         * @param other Color to blend with
         * @return Resulting color from multiply blend
         */
Color multiply(const Color& other) const;
⋮----
/**
         * @brief Screen blend mode
         * @param other Color to blend with
         * @return Resulting color from screen blend
         */
Color screen(const Color& other) const;
⋮----
/**
         * @brief Overlay blend mode
         * @param other Color to blend with
         * @return Resulting color from overlay blend
         */
Color overlay(const Color& other) const;
⋮----
/**
         * @brief Generate analogous colors
         * @param angle Angle between analogous colors (degrees)
         * @return Vector of analogous colors
         */
std::vector<Color> analogous(float angle = 30.0f) const;
⋮----
/**
         * @brief Generate triadic color harmony
         * @return Vector of triadic colors (including this color)
         */
std::vector<Color> triadic() const;
⋮----
/**
         * @brief Generate tetradic color harmony
         * @return Vector of tetradic colors (including this color)
         */
std::vector<Color> tetradic() const;
⋮----
/**
         * @brief Generate monochromatic color variations
         * @param steps Number of variations to generate
         * @return Vector of monochromatic colors
         */
std::vector<Color> monochromatic(int steps = 5) const;
⋮----
/**
         * @brief Equality operator
         * @param other Color to compare with
         * @return True if colors are equal
         */
⋮----
/**
         * @brief Inequality operator
         * @param other Color to compare with
         * @return True if colors are not equal
         */
⋮----
/**
         * @brief Addition operator
         * @param other Color to add
         * @return Sum of colors (clamped to valid range)
         */
⋮----
/**
         * @brief Subtraction operator
         * @param other Color to subtract
         * @return Difference of colors (clamped to valid range)
         */
⋮----
/**
         * @brief Scalar multiplication operator
         * @param scalar Value to multiply by
         * @return Scaled color (clamped to valid range)
         */
⋮----
/**
         * @brief Scalar division operator
         * @param scalar Value to divide by
         * @return Divided color (clamped to valid range)
         */
⋮----
// Predefined colors
⋮----
/**
         * @brief Helper method for HSL/HSV conversions
         * @param p First parameter
         * @param q Second parameter
         * @param t Third parameter
         * @return Resulting component value
         */
static float hueToRGB(float p, float q, float t);
⋮----
/**
         * @brief Clamp color components to valid range [0,1]
         */
void clamp();
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/DebugDraw.h">
// -------------------------------------------------------------------------
// DebugDraw.h
⋮----
/**
     * @brief Debug line primitive for immediate-mode rendering
     */
struct DebugLine
⋮----
glm::vec3 start;        // Starting position of the line
glm::vec3 end;          // Ending position of the line
glm::vec4 color;        // RGBA color
float thickness;        // Line thickness
float duration;         // How long the line should stay visible (0 = single frame)
bool depthTest;         // Whether the line should be depth tested
float creationTime;     // When the line was created
⋮----
/**
     * @brief Debug text primitive for immediate-mode rendering
     */
struct DebugText
⋮----
std::string text;       // Text string to display
glm::vec3 position;     // 3D position of the text
⋮----
float size;             // Text size
bool billboard;         // Whether to align with camera
float duration;         // How long the text should stay visible (0 = single frame)
bool depthTest;         // Whether the text should be depth tested
float creationTime;     // When the text was created
⋮----
/**
     * @brief Debug shape primitive for immediate-mode rendering
     */
struct DebugShape
⋮----
/**
         * @brief Types of debug shapes supported
         */
enum class Type
⋮----
Type type;              // Shape type
glm::vec3 position;     // 3D position of the shape
glm::quat rotation;     // Rotation of the shape
glm::vec3 scale;        // Scale of the shape
⋮----
bool wireframe;         // Whether to render as wireframe
float duration;         // How long the shape should stay visible (0 = single frame)
bool depthTest;         // Whether the shape should be depth tested
float creationTime;     // When the shape was created
⋮----
/**
     * @brief Immediate-mode debug drawing utility for visualization
     *
     * The DebugDraw class provides a simple and efficient way to render
     * debug visuals like lines, shapes, and text. These visuals can persist
     * for specified durations or appear for a single frame.
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the singleton instance
         */
⋮----
/**
         * @brief Initialize the debug drawing system
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the debug drawing system and release resources
         */
void shutdown();
⋮----
/**
         * @brief Begin a new debug drawing frame
         * Must be called before any drawing in a frame
         */
void begin();
⋮----
/**
         * @brief Flush all debug drawings to the renderer
         * Must be called after all drawing in a frame
         */
void flush();
⋮----
/**
         * @brief Clear all debug drawing primitives
         */
void clear();
⋮----
/**
         * @brief Draw a line between two points
         * @param start Starting position
         * @param end Ending position
         * @param color RGBA color (default: white)
         * @param thickness Line thickness (default: 1.0)
         * @param duration How long the line should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the line should be depth tested (default: true)
         */
void drawLine(const glm::vec3& start, const glm::vec3& end,
const glm::vec4& color = glm::vec4(1.0f),
⋮----
/**
         * @brief Draw a ray starting from an origin point
         * @param origin Ray origin position
         * @param direction Ray direction (will be normalized)
         * @param length Ray length
         * @param color RGBA color (default: white)
         * @param thickness Line thickness (default: 1.0)
         * @param duration How long the ray should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the ray should be depth tested (default: true)
         */
void drawRay(const glm::vec3& origin, const glm::vec3& direction,
⋮----
/**
         * @brief Draw a sequence of connected lines
         * @param points Vector of points to connect
         * @param color RGBA color (default: white)
         * @param thickness Line thickness (default: 1.0)
         * @param duration How long the lines should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the lines should be depth tested (default: true)
         */
void drawLineStrip(const std::vector<glm::vec3>& points,
⋮----
/**
         * @brief Draw a box shape
         * @param center Center position of the box
         * @param dimensions Width, height, and depth of the box
         * @param rotation Rotation of the box
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param duration How long the box should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the box should be depth tested (default: true)
         */
void drawBox(const glm::vec3& center,
⋮----
const glm::quat& rotation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f),
⋮----
/**
         * @brief Draw a box from an axis-aligned bounding box
         * @param aabb The axis-aligned bounding box
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param duration How long the box should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the box should be depth tested (default: true)
         */
void drawBox(const AABB& aabb,
⋮----
/**
         * @brief Draw a sphere shape
         * @param center Center position of the sphere
         * @param radius Radius of the sphere
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param segments Number of segments for sphere tessellation (default: 16)
         * @param duration How long the sphere should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the sphere should be depth tested (default: true)
         */
void drawSphere(const glm::vec3& center,
⋮----
/**
         * @brief Draw a cylinder shape
         * @param base Center of the base of the cylinder
         * @param top Center of the top of the cylinder
         * @param radius Radius of the cylinder
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param segments Number of segments for cylinder tessellation (default: 16)
         * @param duration How long the cylinder should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the cylinder should be depth tested (default: true)
         */
void drawCylinder(const glm::vec3& base,
⋮----
/**
         * @brief Draw a cone shape
         * @param apex Apex position of the cone
         * @param direction Direction the cone points (will be normalized)
         * @param length Length of the cone
         * @param radius Radius of the cone base
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param segments Number of segments for cone tessellation (default: 16)
         * @param duration How long the cone should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the cone should be depth tested (default: true)
         */
void drawCone(const glm::vec3& apex,
⋮----
/**
         * @brief Draw a capsule shape
         * @param start Center of the first hemisphere
         * @param end Center of the second hemisphere
         * @param radius Radius of the capsule
         * @param color RGBA color (default: white)
         * @param wireframe Whether to render as wireframe (default: true)
         * @param segments Number of segments for capsule tessellation (default: 16)
         * @param duration How long the capsule should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the capsule should be depth tested (default: true)
         */
void drawCapsule(const glm::vec3& start,
⋮----
/**
         * @brief Draw an arrow
         * @param start Start position of the arrow
         * @param end End position of the arrow
         * @param headSize Size of the arrow head relative to the length
         * @param color RGBA color (default: white)
         * @param thickness Line thickness of the arrow shaft (default: 1.0)
         * @param duration How long the arrow should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the arrow should be depth tested (default: true)
         */
void drawArrow(const glm::vec3& start,
⋮----
/**
         * @brief Draw a circle
         * @param center Center position of the circle
         * @param radius Radius of the circle
         * @param normal Normal vector defining the plane of the circle
         * @param color RGBA color (default: white)
         * @param segments Number of segments for circle tessellation (default: 32)
         * @param duration How long the circle should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the circle should be depth tested (default: true)
         */
void drawCircle(const glm::vec3& center,
⋮----
const glm::vec3& normal = glm::vec3(0.0f, 1.0f, 0.0f),
⋮----
/**
         * @brief Draw a view frustum
         * @param frustum The view frustum to draw
         * @param color RGBA color (default: white)
         * @param duration How long the frustum should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the frustum should be depth tested (default: true)
         */
void drawFrustum(const Frustum& frustum,
⋮----
/**
         * @brief Draw a grid
         * @param center Center position of the grid
         * @param size X and Y size of the grid
         * @param cellSize Size of each grid cell
         * @param color RGBA color (default: gray)
         * @param xzPlane Whether to draw the grid on the XZ plane (true) or XY plane (false)
         * @param duration How long the grid should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the grid should be depth tested (default: true)
         */
void drawGrid(const glm::vec3& center,
⋮----
const glm::vec4& color = glm::vec4(0.5f, 0.5f, 0.5f, 1.0f),
⋮----
/**
         * @brief Draw coordinate axes
         * @param position Origin position of the axes
         * @param size Size/length of the axes
         * @param duration How long the axes should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the axes should be depth tested (default: true)
         */
void drawAxes(const glm::vec3& position,
⋮----
/**
         * @brief Draw 3D text
         * @param text Text string to display
         * @param position 3D position of the text
         * @param color RGBA color (default: white)
         * @param size Text size
         * @param billboard Whether to align text with camera (default: true)
         * @param duration How long the text should stay visible in seconds (0 = single frame)
         * @param depthTest Whether the text should be depth tested (default: true)
         */
void drawText(const std::string& text,
⋮----
/**
         * @brief Draw 2D text on screen space
         * @param text Text string to display
         * @param position 2D screen position (0,0 is bottom-left)
         * @param color RGBA color (default: white)
         * @param size Text size
         * @param duration How long the text should stay visible in seconds (0 = single frame)
         */
void draw2DText(const std::string& text,
⋮----
/**
         * @brief Draw a 2D rectangle on screen space
         * @param position Bottom-left position of the rectangle
         * @param size Width and height of the rectangle
         * @param color RGBA color (default: white)
         * @param filled Whether to draw a filled rectangle (default: false)
         * @param duration How long the rectangle should stay visible in seconds (0 = single frame)
         */
void drawRect2D(const glm::vec2& position,
⋮----
/**
         * @brief Draw a 2D circle on screen space
         * @param center Center position of the circle
         * @param radius Radius of the circle
         * @param color RGBA color (default: white)
         * @param filled Whether to draw a filled circle (default: false)
         * @param segments Number of segments for circle tessellation (default: 32)
         * @param duration How long the circle should stay visible in seconds (0 = single frame)
         */
void drawCircle2D(const glm::vec2& center,
⋮----
/**
         * @brief Draw a 2D line on screen space
         * @param start Start position of the line
         * @param end End position of the line
         * @param color RGBA color (default: white)
         * @param thickness Line thickness (default: 1.0)
         * @param duration How long the line should stay visible in seconds (0 = single frame)
         */
void drawLine2D(const glm::vec2& start,
⋮----
/**
         * @brief Set the camera used for debug drawing
         * @param camera Weak pointer to the camera
         */
void setCamera(std::weak_ptr<Camera> camera);
⋮----
/**
         * @brief Update the debug drawing system
         * @param deltaTime Time since last update
         */
void update(float deltaTime);
⋮----
/**
         * @brief Constructor (private for singleton)
         */
⋮----
/**
         * @brief Destructor (private for singleton)
         */
⋮----
/**
         * @brief Render accumulated lines
         */
void renderLines();
⋮----
/**
         * @brief Render accumulated shapes
         */
void renderShapes();
⋮----
/**
         * @brief Render accumulated texts
         */
void renderTexts();
⋮----
/**
         * @brief Render accumulated 2D elements
         */
void render2DElements();
⋮----
/**
         * @brief Create primitive meshes for rendering
         */
void createPrimitiveMeshes();
⋮----
/**
         * @brief Check if the DebugDraw system is initialized
         * @return True if initialized
         */
bool isInitialized() const
⋮----
// Shader for debug rendering
⋮----
// OpenGL resources
⋮----
// Debug primitive meshes
⋮----
// Debug drawing storage
⋮----
// 2D elements
⋮----
// Camera reference
⋮----
// Font texture for text rendering
⋮----
// Current time for duration calculations
⋮----
// Initialization flag
⋮----
// Singleton instance
⋮----
// Mutex for thread safety
⋮----
// Global convenience functions
/**
     * @brief Draw a line between two points (global convenience function)
     * @param start Starting position
     * @param end Ending position
     * @param color RGBA color (default: white)
     */
void drawLine(const glm::vec3& start, const glm::vec3& end, const glm::vec4& color = glm::vec4(1.0f));
⋮----
/**
     * @brief Draw a box shape (global convenience function)
     * @param center Center position of the box
     * @param dimensions Width, height, and depth of the box
     * @param color RGBA color (default: white)
     */
void drawBox(const glm::vec3& center, const glm::vec3& dimensions, const glm::vec4& color = glm::vec4(1.0f));
⋮----
/**
     * @brief Draw a sphere shape (global convenience function)
     * @param center Center position of the sphere
     * @param radius Radius of the sphere
     * @param color RGBA color (default: white)
     */
void drawSphere(const glm::vec3& center, float radius, const glm::vec4& color = glm::vec4(1.0f));
⋮----
/**
     * @brief Draw 3D text (global convenience function)
     * @param text Text string to display
     * @param position 3D position of the text
     * @param color RGBA color (default: white)
     */
void drawText(const std::string& text, const glm::vec3& position, const glm::vec4& color = glm::vec4(1.0f));
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/FileSystem.h">
// -------------------------------------------------------------------------
// FileSystem.h
⋮----
/**
     * @brief Enumeration of file access modes
     */
enum class FileMode
⋮----
/**
     * @brief File operation result codes
     */
enum class FileResult
⋮----
/**
     * @brief File information structure
     */
struct FileInfo
⋮----
/**
     * @brief Platform-independent file system utility class
     *
     * Provides unified interface for file and directory operations across platforms
     * with support for asynchronous operations, path manipulation, virtual file system
     * and file watching for hot-reloading.
     */
⋮----
/**
         * @brief Reads a text file into a string
         * @param path The path to the file
         * @param outContent The string that will receive the file content
         * @return Result of the operation
         */
static FileResult readFile(const std::string& path, std::string& outContent);
⋮----
/**
         * @brief Reads a binary file into a byte vector
         * @param path The path to the file
         * @param outData The vector that will receive the file data
         * @return Result of the operation
         */
static FileResult readFileBinary(const std::string& path, std::vector<uint8_t>& outData);
⋮----
/**
         * @brief Writes a string to a text file
         * @param path The path to the file
         * @param content The content to write
         * @return Result of the operation
         */
static FileResult writeFile(const std::string& path, const std::string& content);
⋮----
/**
         * @brief Writes a byte vector to a binary file
         * @param path The path to the file
         * @param data The data to write
         * @return Result of the operation
         */
static FileResult writeFileBinary(const std::string& path, const std::vector<uint8_t>& data);
⋮----
/**
         * @brief Appends a string to a text file
         * @param path The path to the file
         * @param content The content to append
         * @return Result of the operation
         */
static FileResult appendFile(const std::string& path, const std::string& content);
⋮----
/**
         * @brief Appends a byte vector to a binary file
         * @param path The path to the file
         * @param data The data to append
         * @return Result of the operation
         */
static FileResult appendFileBinary(const std::string& path, const std::vector<uint8_t>& data);
⋮----
/**
         * @brief Checks if a file exists
         * @param path The path to check
         * @return True if the file exists, false otherwise
         */
static bool fileExists(const std::string& path);
⋮----
/**
         * @brief Deletes a file
         * @param path The path to the file to delete
         * @return True if the file was deleted, false otherwise
         */
static bool deleteFile(const std::string& path);
⋮----
/**
         * @brief Copies a file from source to destination
         * @param source The source file path
         * @param destination The destination file path
         * @param overwrite If true, overwrites existing destination
         * @return True if the file was copied, false otherwise
         */
static bool copyFile(const std::string& source, const std::string& destination, bool overwrite = false);
⋮----
/**
         * @brief Moves a file from source to destination
         * @param source The source file path
         * @param destination The destination file path
         * @param overwrite If true, overwrites existing destination
         * @return True if the file was moved, false otherwise
         */
static bool moveFile(const std::string& source, const std::string& destination, bool overwrite = false);
⋮----
/**
         * @brief Gets the size of a file in bytes
         * @param path The path to the file
         * @return The size of the file in bytes, or 0 if the file doesn't exist
         */
static size_t getFileSize(const std::string& path);
⋮----
/**
         * @brief Gets the last modification time of a file
         * @param path The path to the file
         * @return The last modification time as a time_t value, or 0 if the file doesn't exist
         */
static time_t getFileModificationTime(const std::string& path);
⋮----
/**
         * @brief Creates a directory
         * @param path The path of the directory to create
         * @return True if the directory was created, false otherwise
         */
static bool createDirectory(const std::string& path);
⋮----
/**
         * @brief Deletes a directory
         * @param path The path of the directory to delete
         * @param recursive If true, deletes all contents recursively
         * @return True if the directory was deleted, false otherwise
         */
static bool deleteDirectory(const std::string& path, bool recursive = false);
⋮----
/**
         * @brief Checks if a directory exists
         * @param path The path to check
         * @return True if the directory exists, false otherwise
         */
static bool directoryExists(const std::string& path);
⋮----
/**
         * @brief Lists all files in a directory
         * @param directory The directory path
         * @param filter Optional wildcard filter (e.g., "*.png")
         * @return Vector of FileInfo structures for each file
         */
static std::vector<FileInfo> listFiles(const std::string& directory, const std::string& filter = "*");
⋮----
/**
         * @brief Lists all subdirectories in a directory
         * @param directory The directory path
         * @return Vector of FileInfo structures for each subdirectory
         */
static std::vector<FileInfo> listDirectories(const std::string& directory);
⋮----
/**
         * @brief Gets the extension of a file path
         * @param path The file path
         * @return The extension including the dot (e.g., ".png")
         */
static std::string getPathExtension(const std::string& path);
⋮----
/**
         * @brief Gets the filename from a path
         * @param path The file path
         * @return The filename with extension
         */
static std::string getFileName(const std::string& path);
⋮----
/**
         * @brief Gets the filename without extension
         * @param path The file path
         * @return The filename without extension
         */
static std::string getFileNameWithoutExtension(const std::string& path);
⋮----
/**
         * @brief Gets the directory part of a path
         * @param path The file path
         * @return The directory part of the path
         */
static std::string getDirectoryPath(const std::string& path);
⋮----
/**
         * @brief Normalizes a path by removing redundant separators and up-level references
         * @param path The path to normalize
         * @return The normalized path
         */
static std::string normalizePath(const std::string& path);
⋮----
/**
         * @brief Combines two paths
         * @param path1 The first path
         * @param path2 The second path
         * @return The combined path
         */
static std::string combinePaths(const std::string& path1, const std::string& path2);
⋮----
/**
         * @brief Adds a file watcher that triggers a callback when the file changes
         * @param path The path to watch
         * @param callback The function to call when the file changes
         * @return A watcher ID that can be used to remove the watcher
         */
static uint64_t addFileWatcher(const std::string& path, std::function<void(const std::string&)> callback);
⋮----
/**
         * @brief Removes a file watcher
         * @param watcherId The ID of the watcher to remove
         */
static void removeFileWatcher(uint64_t watcherId);
⋮----
/**
         * @brief Mounts a real directory to a virtual path
         * @param virtualPath The virtual path prefix
         * @param realPath The real directory path
         */
static void mountDirectory(const std::string& virtualPath, const std::string& realPath);
⋮----
/**
         * @brief Unmounts a virtual path
         * @param virtualPath The virtual path to unmount
         */
static void unmountDirectory(const std::string& virtualPath);
⋮----
/**
         * @brief Resolves a virtual path to a real path
         * @param virtualPath The virtual path to resolve
         * @return The corresponding real path
         */
static std::string resolveVirtualPath(const std::string& virtualPath);
⋮----
/**
         * @brief Asynchronously reads a text file
         * @param path The path to the file
         * @return Future containing the file content as a string
         */
static std::future<std::string> readFileAsync(const std::string& path);
⋮----
/**
         * @brief Asynchronously reads a binary file
         * @param path The path to the file
         * @return Future containing the file content as a byte vector
         */
static std::future<std::vector<uint8_t>> readFileBinaryAsync(const std::string& path);
⋮----
/**
         * @brief Initializes the FileSystem subsystem
         * @return True if initialization was successful
         */
static bool initialize();
⋮----
/**
         * @brief Shuts down the FileSystem subsystem
         */
static void shutdown();
⋮----
// Prevent instantiation
⋮----
// Implementation details
⋮----
// Platform-specific implementations
/**
         * @brief Platform-specific file reading implementation
         * @param path The path to the file
         * @param buffer The buffer to read into
         * @param bufferSize The size of the buffer
         * @param bytesRead Will be set to the number of bytes read
         * @param mode The file access mode
         * @return Result of the operation
         */
static FileResult platformReadFile(const std::string& path, void* buffer, size_t bufferSize, size_t& bytesRead, FileMode mode);
⋮----
/**
         * @brief Platform-specific file writing implementation
         * @param path The path to the file
         * @param buffer The buffer to write from
         * @param bufferSize The size of the buffer
         * @param mode The file access mode
         * @return Result of the operation
         */
static FileResult platformWriteFile(const std::string& path, const void* buffer, size_t bufferSize, FileMode mode);
⋮----
// File watching thread
⋮----
/**
         * @brief Thread function for file watching
         */
static void fileWatcherThreadFunc();
⋮----
// Helper methods
/**
         * @brief Resolves a path, handling virtual paths
         * @param path The path to resolve
         * @return The resolved path
         */
static std::string resolvePathInternal(const std::string& path);
⋮----
/**
         * @brief Checks if a file is accessible with the given mode
         * @param path The path to check
         * @param mode The access mode to check
         * @return Result indicating if the file is accessible
         */
static FileResult checkFileAccess(const std::string& path, FileMode mode);
⋮----
/**
         * @brief Ensures a directory exists, creating it if necessary
         * @param path The directory path
         * @return True if the directory exists or was created
         */
static bool ensureDirectoryExists(const std::string& path);
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Frustum.h">
// -------------------------------------------------------------------------
// Frustum.h
⋮----
/**
     * @brief Enumeration of frustum planes
     */
enum class FrustumPlane
⋮----
/**
     * @brief Represents a plane in 3D space (ax + by + cz + d = 0)
     */
⋮----
/**
         * @brief Default constructor creates a plane at the origin with normal (0,1,0)
         */
⋮----
/**
         * @brief Creates a plane with given normal and distance from origin
         * @param normal The plane normal vector (should be normalized)
         * @param distance Distance from origin along the normal
         */
⋮----
/**
         * @brief Creates a plane with given normal that passes through the specified point
         * @param normal The plane normal vector (should be normalized)
         * @param point A point that lies on the plane
         */
⋮----
/**
         * @brief Creates a plane with equation ax + by + cz + d = 0
         * @param a The x component of the normal
         * @param b The y component of the normal
         * @param c The z component of the normal
         * @param d The negative distance from origin along the normal
         */
⋮----
/**
         * @brief Normalizes the plane equation
         */
void normalize();
⋮----
/**
         * @brief Calculates the signed distance from a point to the plane
         * @param point The point to calculate distance to
         * @return Signed distance (positive if in front of the plane)
         */
float getSignedDistance(const glm::vec3& point) const;
⋮----
/**
         * @brief Get the plane normal
         * @return The plane normal vector (normalized)
         */
const glm::vec3& getNormal() const;
⋮----
/**
         * @brief Get the plane distance from origin
         * @return Distance from the origin along the normal
         */
float getDistance() const;
⋮----
/**
         * @brief Set the plane normal
         * @param normal The new normal vector (should be normalized)
         */
void setNormal(const glm::vec3& normal);
⋮----
/**
         * @brief Set the plane distance from origin
         * @param distance The new distance from origin along the normal
         */
void setDistance(float distance);
⋮----
/**
         * @brief Get the x component of the normal (a coefficient)
         * @return The x component of the normal
         */
float a() const
⋮----
/**
         * @brief Get the y component of the normal (b coefficient)
         * @return The y component of the normal
         */
float b() const
⋮----
/**
         * @brief Get the z component of the normal (c coefficient)
         * @return The z component of the normal
         */
float c() const
⋮----
/**
         * @brief Get the d coefficient (negative distance)
         * @return The d coefficient of the plane equation
         */
float d() const
⋮----
glm::vec3 m_normal;   ///< The plane normal vector
float m_distance;     ///< Distance from origin along the normal
⋮----
/**
     * @brief Intersection test result types
     */
enum class IntersectionType
⋮----
Inside,     ///< Object is fully inside frustum
Outside,    ///< Object is fully outside frustum
Intersects  ///< Object intersects frustum boundary
⋮----
/**
     * @brief Represents a view frustum for efficient culling operations
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Initialize the frustum with default values
         */
void initialize();
⋮----
/**
         * @brief Update the frustum from a view-projection matrix
         * @param viewProjection The combined view-projection matrix
         */
void update(const glm::mat4& viewProjection);
⋮----
/**
         * @brief Extract frustum planes from a matrix
         * @param matrix The view-projection matrix to extract planes from
         */
void extractPlanes(const glm::mat4& matrix);
⋮----
/**
         * @brief Extract frustum corners from an inverse view-projection matrix
         * @param invViewProj The inverse view-projection matrix
         */
void extractCorners(const glm::mat4& invViewProj);
⋮----
/**
         * @brief Get a specific frustum plane
         * @param planeType The plane to retrieve
         * @return Const reference to the requested plane
         */
const Plane& getPlane(FrustumPlane planeType) const;
⋮----
/**
         * @brief Get a specific frustum plane for modification
         * @param planeType The plane to retrieve
         * @return Non-const reference to the requested plane
         */
⋮----
/**
         * @brief Get all frustum planes
         * @return Const reference to array of all planes
         */
const std::array<Plane, 6>& getPlanes() const;
⋮----
/**
         * @brief Get all frustum corners
         * @return Const reference to array of corner points
         */
const std::array<glm::vec3, 8>& getCorners() const;
⋮----
/**
         * @brief Test if a point is inside the frustum
         * @param point The point to test
         * @return True if point is inside or on the frustum
         */
bool testPoint(const glm::vec3& point) const;
⋮----
/**
         * @brief Test if a sphere is inside or intersects the frustum
         * @param center The center of the sphere
         * @param radius The radius of the sphere
         * @return True if sphere is at least partially inside the frustum
         */
bool testSphere(const glm::vec3& center, float radius) const;
⋮----
/**
         * @brief Detailed intersection test for a sphere
         * @param center The center of the sphere
         * @param radius The radius of the sphere
         * @return IntersectionType indicating the sphere's relation to the frustum
         */
IntersectionType testSphereIntersection(const glm::vec3& center, float radius) const;
⋮----
/**
         * @brief Test if an AABB is inside or intersects the frustum
         * @param min The minimum corner of the AABB
         * @param max The maximum corner of the AABB
         * @return True if AABB is at least partially inside the frustum
         */
bool testAABB(const glm::vec3& min, const glm::vec3& max) const;
⋮----
/**
         * @brief Detailed intersection test for an AABB
         * @param min The minimum corner of the AABB
         * @param max The maximum corner of the AABB
         * @return IntersectionType indicating the AABB's relation to the frustum
         */
IntersectionType testAABBIntersection(const glm::vec3& min, const glm::vec3& max) const;
⋮----
/**
         * @brief Draw debug visualization of the frustum
         * @param color The color to use for debug drawing
         */
⋮----
std::array<Plane, 6> m_planes;  ///< Frustum planes (Near, Far, Left, Right, Top, Bottom)
std::array<glm::vec3, 8> m_corners; ///< Frustum corners
⋮----
// Corner indices reference:
// Near face: 0=bottom-left, 1=bottom-right, 2=top-right, 3=top-left
// Far face: 4=bottom-left, 5=bottom-right, 6=top-right, 7=top-left
⋮----
bool m_planesNormalized; ///< Flag indicating if planes are normalized
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Math.h">
// -------------------------------------------------------------------------
// Math.h
⋮----
/**
     * @brief A utility class providing common mathematical functions and constants for game development.
     *
     * The Math class offers a wide range of optimized mathematical operations beyond the standard library,
     * including interpolation, angle manipulation, random number generation, noise functions, vector and
     * matrix operations, geometry utilities, and SIMD-optimized routines.
     */
⋮----
// Constants
⋮----
/**
         * @brief Convert an angle from degrees to radians.
         *
         * @param degrees The angle in degrees
         * @return The angle converted to radians
         */
static inline float degreesToRadians(float degrees)
⋮----
/**
         * @brief Convert an angle from radians to degrees.
         *
         * @param radians The angle in radians
         * @return The angle converted to degrees
         */
static inline float radiansToDegrees(float radians)
⋮----
/**
         * @brief Linearly interpolate between two scalar values.
         *
         * @param a Starting value
         * @param b Ending value
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated value
         */
static float lerp(float a, float b, float t);
⋮----
/**
         * @brief Linearly interpolate between two 2D vectors.
         *
         * @param a Starting vector
         * @param b Ending vector
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated vector
         */
static glm::vec2 lerp(const glm::vec2& a, const glm::vec2& b, float t);
⋮----
/**
         * @brief Linearly interpolate between two 3D vectors.
         *
         * @param a Starting vector
         * @param b Ending vector
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated vector
         */
static glm::vec3 lerp(const glm::vec3& a, const glm::vec3& b, float t);
⋮----
/**
         * @brief Linearly interpolate between two 4D vectors.
         *
         * @param a Starting vector
         * @param b Ending vector
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated vector
         */
static glm::vec4 lerp(const glm::vec4& a, const glm::vec4& b, float t);
⋮----
/**
         * @brief Perform a smooth step interpolation between two values.
         *
         * This produces a smooth transition that accelerates and decelerates,
         * following a Hermite curve (3t² - 2t³).
         *
         * @param a Starting value
         * @param b Ending value
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated value
         */
static float smoothStep(float a, float b, float t);
⋮----
/**
         * @brief Perform a smoother step interpolation between two values.
         *
         * This produces an even smoother transition than smoothStep,
         * following the curve (6t^5 - 15t^4 + 10t^3).
         *
         * @param a Starting value
         * @param b Ending value
         * @param t Interpolation factor (0.0 to 1.0)
         * @return The interpolated value
         */
static float smootherStep(float a, float b, float t);
⋮----
/**
         * @brief Clamp a float value between a minimum and maximum value.
         *
         * @param value The value to clamp
         * @param min The minimum value
         * @param max The maximum value
         * @return The clamped value
         */
static float clamp(float value, float min, float max);
⋮----
/**
         * @brief Clamp an integer value between a minimum and maximum value.
         *
         * @param value The value to clamp
         * @param min The minimum value
         * @param max The maximum value
         * @return The clamped value
         */
static int clamp(int value, int min, int max);
⋮----
/**
         * @brief Clamp a float value to the range [0, 1].
         *
         * @param value The value to saturate
         * @return The saturated value
         */
static inline float saturate(float value)
⋮----
/**
         * @brief Wrap an angle to the range [-PI, PI].
         *
         * @param angle The angle in radians to wrap
         * @return The wrapped angle
         */
static float wrapAngle(float angle);
⋮----
/**
         * @brief Calculate the signed angle between two 2D vectors.
         *
         * @param a The first vector
         * @param b The second vector
         * @return The angle in radians between the vectors
         */
static float angleBetween(const glm::vec2& a, const glm::vec2& b);
⋮----
/**
         * @brief Calculate the angle between two 3D vectors.
         *
         * @param a The first vector
         * @param b The second vector
         * @return The angle in radians between the vectors
         */
static float angleBetween(const glm::vec3& a, const glm::vec3& b);
⋮----
/**
         * @brief Generate a random float within a specified range.
         *
         * @param min The minimum value
         * @param max The maximum value
         * @return A random float between min and max
         */
static float randomRange(float min, float max);
⋮----
/**
         * @brief Generate a random integer within a specified range.
         *
         * @param min The minimum value
         * @param max The maximum value
         * @return A random integer between min and max (inclusive)
         */
static int randomRange(int min, int max);
⋮----
/**
         * @brief Generate a random 2D unit vector.
         *
         * @return A random 2D direction vector with unit length
         */
static glm::vec2 randomDirection2D();
⋮----
/**
         * @brief Generate a random 3D unit vector.
         *
         * @return A random 3D direction vector with unit length
         */
static glm::vec3 randomDirection3D();
⋮----
/**
         * @brief Generate a random point on the surface of a unit sphere.
         *
         * @return A random position vector on the unit sphere
         */
static glm::vec3 randomPointOnSphere();
⋮----
/**
         * @brief Generate a random point within a unit sphere.
         *
         * @return A random position vector inside the unit sphere
         */
static glm::vec3 randomPointInSphere();
⋮----
/**
         * @brief Generate a 1D Perlin noise value.
         *
         * @param x The x-coordinate
         * @return Noise value in the range [-1, 1]
         */
static float perlinNoise(float x);
⋮----
/**
         * @brief Generate a 2D Perlin noise value.
         *
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @return Noise value in the range [-1, 1]
         */
static float perlinNoise(float x, float y);
⋮----
/**
         * @brief Generate a 3D Perlin noise value.
         *
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param z The z-coordinate
         * @return Noise value in the range [-1, 1]
         */
static float perlinNoise(float x, float y, float z);
⋮----
/**
         * @brief Generate a 2D Simplex noise value.
         *
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @return Noise value in the range [-1, 1]
         */
static float simplexNoise(float x, float y);
⋮----
/**
         * @brief Generate a 3D Simplex noise value.
         *
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param z The z-coordinate
         * @return Noise value in the range [-1, 1]
         */
static float simplexNoise(float x, float y, float z);
⋮----
/**
         * @brief Generate fractal noise by summing multiple octaves of noise.
         *
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param octaves Number of octaves to sum
         * @param persistence How much each octave contributes
         * @return Noise value in the range [-1, 1]
         */
static float fractalNoise(float x, float y, int octaves, float persistence);
⋮----
/**
         * @brief Project a vector onto a plane defined by its normal.
         *
         * @param vector The vector to project
         * @param planeNormal The normal of the plane
         * @return The projected vector
         */
static glm::vec3 projectOnPlane(const glm::vec3& vector, const glm::vec3& planeNormal);
⋮----
/**
         * @brief Reflect a vector off a surface with the specified normal.
         *
         * @param vector The vector to reflect
         * @param normal The surface normal
         * @return The reflected vector
         */
static glm::vec3 reflect(const glm::vec3& vector, const glm::vec3& normal);
⋮----
/**
         * @brief Calculate the normal of a triangle.
         *
         * @param a First vertex position
         * @param b Second vertex position
         * @param c Third vertex position
         * @return The triangle normal
         */
static glm::vec3 calculateNormal(const glm::vec3& a, const glm::vec3& b, const glm::vec3& c);
⋮----
/**
         * @brief Calculate the tangent vector for a triangle.
         *
         * @param p1 First vertex position
         * @param p2 Second vertex position
         * @param p3 Third vertex position
         * @param uv1 First vertex UV
         * @param uv2 Second vertex UV
         * @param uv3 Third vertex UV
         * @return The triangle tangent
         */
static glm::vec3 calculateTangent(const glm::vec3& p1, const glm::vec3& p2, const glm::vec3& p3,
⋮----
/**
         * @brief Compare two float values with an epsilon tolerance.
         *
         * @param a First value
         * @param b Second value
         * @param epsilon The comparison tolerance (default: EPSILON)
         * @return True if the values are equal within the tolerance
         */
static bool equals(float a, float b, float epsilon = EPSILON);
⋮----
/**
         * @brief Compare two 2D vectors with an epsilon tolerance.
         *
         * @param a First vector
         * @param b Second vector
         * @param epsilon The comparison tolerance (default: EPSILON)
         * @return True if the vectors are equal within the tolerance
         */
static bool equals(const glm::vec2& a, const glm::vec2& b, float epsilon = EPSILON);
⋮----
/**
         * @brief Compare two 3D vectors with an epsilon tolerance.
         *
         * @param a First vector
         * @param b Second vector
         * @param epsilon The comparison tolerance (default: EPSILON)
         * @return True if the vectors are equal within the tolerance
         */
static bool equals(const glm::vec3& a, const glm::vec3& b, float epsilon = EPSILON);
⋮----
/**
         * @brief Create a transformation matrix from position, rotation, and scale.
         *
         * @param position The position vector
         * @param rotation The rotation quaternion
         * @param scale The scale vector
         * @return The combined transformation matrix
         */
static glm::mat4 createTransformMatrix(const glm::vec3& position, const glm::quat& rotation, const glm::vec3& scale);
⋮----
/**
         * @brief Decompose a transformation matrix into position, rotation, and scale.
         *
         * @param transform The transformation matrix to decompose
         * @param position Output parameter for the position
         * @param rotation Output parameter for the rotation
         * @param scale Output parameter for the scale
         */
static void decomposeTransform(const glm::mat4& transform, glm::vec3& position, glm::quat& rotation, glm::vec3& scale);
⋮----
/**
         * @brief Transform a point by a 4x4 matrix.
         *
         * @param matrix The transformation matrix
         * @param point The point to transform
         * @return The transformed point
         */
static glm::vec3 transformPoint(const glm::mat4& matrix, const glm::vec3& point);
⋮----
/**
         * @brief Transform a direction vector by a 4x4 matrix.
         *
         * Unlike transformPoint, this ignores translation.
         *
         * @param matrix The transformation matrix
         * @param direction The direction vector to transform
         * @return The transformed direction
         */
static glm::vec3 transformDirection(const glm::mat4& matrix, const glm::vec3& direction);
⋮----
// Internal random number generator
⋮----
// Perlin noise helper tables
⋮----
// Initialize the noise tables
static void initializeNoise();
⋮----
// Return a value from the permutation table
static int perm(int i);
⋮----
// Helper methods for noise functions
static float grad(int hash, float x);
static float grad(int hash, float x, float y);
static float grad(int hash, float x, float y, float z);
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Profiler.h">
// -------------------------------------------------------------------------
// Profiler.h
⋮----
/**
     * @brief Performance profiling data for a single measurement
     */
struct ProfileSample
⋮----
std::string name;              ///< Name of the profile sample
double startTime;              ///< Start time in milliseconds
double endTime;                ///< End time in milliseconds
double duration;               ///< Duration in milliseconds (endTime - startTime)
double minTime;                ///< Minimum duration recorded for this sample
double maxTime;                ///< Maximum duration recorded for this sample
double averageTime;            ///< Average duration for this sample
uint64_t callCount;            ///< Number of times this sample has been called
std::vector<ProfileSample> children; ///< Child samples
ProfileSample* parent;         ///< Parent sample (if any)
bool isOpen;                   ///< Whether this sample is currently being measured
std::thread::id threadId;      ///< ID of the thread this sample was recorded on
⋮----
/**
     * @brief Performance statistics for a single frame
     */
struct FrameStats
⋮----
double frameTime;              ///< Total frame time in milliseconds
double cpuTime;                ///< CPU time in milliseconds
double gpuTime;                ///< GPU time in milliseconds (if available)
uint64_t frameNumber;          ///< Frame number
std::unordered_map<std::string, ProfileSample> samples; ///< Samples recorded in this frame
⋮----
/**
     * @brief Display modes for the profiler
     */
enum class ProfilerDisplayMode
⋮----
Disabled,                      ///< No display
Simple,                        ///< Simple flat list of timings
Detailed,                      ///< Detailed view with statistics
Hierarchical,                  ///< Tree view showing parent-child relationships
Graph                          ///< Graph view showing timing history
⋮----
/**
     * @brief RAII wrapper for automatic profiling of a scope
     */
⋮----
/**
         * @brief Constructor starts timing the named scope
         * @param name Name of the scope to profile
         */
⋮----
/**
         * @brief Destructor ends timing the scope
         */
⋮----
std::string m_name;            ///< Name of the profile sample
double m_startTime;            ///< Start time of the sample
⋮----
/**
     * @brief Performance profiling system
     *
     * The Profiler provides performance measurement and tracking throughout
     * the engine. It supports hierarchical profiling with nested measurements,
     * frame-based and cumulative statistics, and visualization capabilities.
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the global profiler instance
         */
⋮----
/**
         * @brief Initialize the profiler
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the profiler and release resources
         */
void shutdown();
⋮----
/**
         * @brief Enable or disable profiling
         * @param enable True to enable profiling, false to disable
         */
void enableProfiling(bool enable);
⋮----
/**
         * @brief Check if profiling is enabled
         * @return True if profiling is enabled
         */
bool isProfilingEnabled() const;
⋮----
/**
         * @brief Begin a profiling sample
         * @param name Name of the sample
         */
void beginSample(const std::string& name);
⋮----
/**
         * @brief End the current profiling sample
         */
void endSample();
⋮----
/**
         * @brief Begin a new frame
         */
void beginFrame();
⋮----
/**
         * @brief End the current frame
         */
void endFrame();
⋮----
/**
         * @brief Get a specific profile sample
         * @param name Name of the sample
         * @return Pointer to the sample, or nullptr if not found
         */
const ProfileSample* getSample(const std::string& name) const;
⋮----
/**
         * @brief Get names of all samples
         * @return Vector of sample names
         */
const std::vector<std::string>& getSampleNames() const;
⋮----
/**
         * @brief Get frame statistics
         * @return Vector of frame stats
         */
const std::vector<FrameStats>& getFrameStats() const;
⋮----
/**
         * @brief Reset all profiling statistics
         */
void resetStats();
⋮----
/**
         * @brief Reset statistics for a specific sample
         * @param name Name of the sample to reset
         */
void resetSample(const std::string& name);
⋮----
/**
         * @brief Set how frequently profile data is output
         * @param frameInterval Interval in frames (0 to disable)
         */
void setOutputFrequency(uint32_t frameInterval);
⋮----
/**
         * @brief Output profiling data to the log
         */
void outputToLog();
⋮----
/**
         * @brief Output profiling data to a file
         * @param filename Name of the file to output to
         */
void outputToFile(const std::string& filename);
⋮----
/**
         * @brief Output profiling data to the console
         */
void outputToConsole();
⋮----
/**
         * @brief Set the display mode
         * @param mode Display mode to use
         */
void setDisplayMode(ProfilerDisplayMode mode);
⋮----
/**
         * @brief Get the current display mode
         * @return Current display mode
         */
ProfilerDisplayMode getDisplayMode() const;
⋮----
/**
         * @brief Render profiling visualization
         */
void render();
⋮----
/**
         * @brief Set the name of the current thread
         * @param name Thread name
         */
void setThreadName(const std::string& name);
⋮----
/**
         * @brief Get the name of a thread
         * @param threadId Thread ID
         * @return Thread name, or empty string if not found
         */
std::string getThreadName(std::thread::id threadId) const;
⋮----
/**
         * @brief Begin a GPU timing sample
         * @param name Name of the sample
         */
void beginGPUSample(const std::string& name);
⋮----
/**
         * @brief End the current GPU timing sample
         */
void endGPUSample();
⋮----
/**
         * @brief Set a performance marker for external tools
         * @param name Name of the marker
         */
void setPerformanceMarker(const std::string& name);
⋮----
/**
         * @brief Begin a performance marker section for external tools
         * @param name Name of the marker
         */
void beginPerformanceMarker(const std::string& name);
⋮----
/**
         * @brief End the current performance marker section
         */
void endPerformanceMarker();
⋮----
/**
         * @brief Constructor is private (singleton)
         */
Profiler();
⋮----
/**
         * @brief Destructor is private (singleton)
         */
⋮----
// Prevent copying
⋮----
/**
         * @brief Get the current time in milliseconds
         * @return Current time in milliseconds
         */
double getCurrentTimeMs();
⋮----
/**
         * @brief Update statistics for a sample
         * @param sample Sample to update
         * @param duration Duration of the sample
         */
void updateSampleStatistics(ProfileSample& sample, double duration);
⋮----
/**
         * @brief Get or create a sample for the current thread
         * @param name Name of the sample
         * @return Reference to the sample
         */
ProfileSample& getThreadSample(const std::string& name);
⋮----
/**
         * @brief Render the profiler UI
         */
void renderUI();
⋮----
/**
         * @brief Format a time value for display
         * @param timeMs Time in milliseconds
         * @return Formatted time string
         */
std::string formatTime(double timeMs);
⋮----
// Main profiling data
bool m_enabled;                ///< Whether profiling is enabled
ProfilerDisplayMode m_displayMode; ///< Current display mode
std::unordered_map<std::string, ProfileSample> m_samples; ///< All samples
std::vector<std::string> m_sampleNames; ///< Names of all samples
std::vector<FrameStats> m_frameStats; ///< Statistics for recent frames
uint32_t m_maxFrameStats;      ///< Maximum number of frame stats to keep
⋮----
// Current frame data
uint64_t m_frameCount;         ///< Current frame count
double m_frameStartTime;       ///< Start time of the current frame
double m_frameTime;            ///< Duration of the current frame
double m_cpuTime;              ///< CPU time for the current frame
double m_gpuTime;              ///< GPU time for the current frame
⋮----
// Active samples tracking
std::stack<std::string> m_activeSamples; ///< Stack of active samples
std::unordered_map<std::thread::id, std::stack<std::string>> m_threadActiveSamples; ///< Active samples per thread
std::unordered_map<std::thread::id, std::string> m_threadNames; ///< Thread names
⋮----
// GPU timing objects
std::unordered_map<std::string, uint32_t> m_gpuQueries; ///< GPU timing queries
std::stack<std::string> m_activeGPUQueries; ///< Stack of active GPU queries
⋮----
// Output control
uint32_t m_outputFrequency;    ///< Output frequency in frames
bool m_outputToLog;            ///< Whether to output to log
bool m_outputToConsole;        ///< Whether to output to console
std::string m_outputFilename;  ///< Filename for file output
⋮----
// Threading support
mutable std::mutex m_profilerMutex;    ///< Mutex for thread safety
⋮----
/**
         * @brief Thread-local storage for profiling
         */
struct ThreadLocalStorage
⋮----
std::stack<std::string> activeSamples; ///< Active samples for this thread
std::string threadName;    ///< Name of this thread
⋮----
/**
         * @brief Thread-local storage instance
         */
⋮----
// Convenient macro for scoped profiling
⋮----
#define PROFILE_SCOPE(name) PixelCraft::Utility::ScopedProfiler scopedProfiler##__LINE__(name)
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Random.h">
// -------------------------------------------------------------------------
// Random.h
⋮----
/**
     * @brief Provides robust random number generation capabilities for various game development needs
     *
     * The Random class offers high-quality random number generation with support for
     * different distributions and common game development use cases such as random
     * vectors, directions, positions, and color generation. It supports deterministic
     * seeding for reproducible results and thread-safe operation.
     */
⋮----
/**
         * @brief Constructor with optional seed
         * @param seed Initial seed value (0 means seed from time)
         */
⋮----
/**
         * @brief Set the random number generator seed
         * @param seed The seed value to use
         */
void seed(uint32_t seed);
⋮----
/**
         * @brief Seed the random number generator with current time
         */
void seedFromTime();
⋮----
/**
         * @brief Get the current seed value
         * @return The current seed value
         */
uint32_t getSeed() const;
⋮----
/**
         * @brief Get a random integer covering the full int32_t range
         * @return Random integer
         */
int32_t getInt();
⋮----
/**
         * @brief Get a random integer in the specified range [min, max]
         * @param min Minimum value (inclusive)
         * @param max Maximum value (inclusive)
         * @return Random integer in the range [min, max]
         */
int32_t getInt(int32_t min, int32_t max);
⋮----
/**
         * @brief Get a random unsigned integer covering the full uint32_t range
         * @return Random unsigned integer
         */
uint32_t getUint();
⋮----
/**
         * @brief Get a random unsigned integer in the specified range [min, max]
         * @param min Minimum value (inclusive)
         * @param max Maximum value (inclusive)
         * @return Random unsigned integer in the range [min, max]
         */
uint32_t getUint(uint32_t min, uint32_t max);
⋮----
/**
         * @brief Get a random float in the range [0.0, 1.0)
         * @return Random float
         */
float getFloat();
⋮----
/**
         * @brief Get a random float in the specified range [min, max)
         * @param min Minimum value (inclusive)
         * @param max Maximum value (exclusive)
         * @return Random float in the range [min, max)
         */
float getFloat(float min, float max);
⋮----
/**
         * @brief Get a random double in the range [0.0, 1.0)
         * @return Random double
         */
double getDouble();
⋮----
/**
         * @brief Get a random double in the specified range [min, max)
         * @param min Minimum value (inclusive)
         * @param max Maximum value (exclusive)
         * @return Random double in the range [min, max)
         */
double getDouble(double min, double max);
⋮----
/**
         * @brief Get a random boolean with 50% probability
         * @return Random boolean
         */
bool getBool();
⋮----
/**
         * @brief Get a random boolean with specified probability
         * @param probability Probability of returning true (0.0 to 1.0)
         * @return Random boolean
         */
bool getBool(float probability);
⋮----
/**
         * @brief Get a random 2D vector with components in the range [0.0, 1.0)
         * @return Random 2D vector
         */
⋮----
/**
         * @brief Get a random 2D vector with components in the specified range [min, max)
         * @param min Minimum component value (inclusive)
         * @param max Maximum component value (exclusive)
         * @return Random 2D vector
         */
⋮----
/**
         * @brief Get a random 2D vector with components in the specified range [min.x, max.x), [min.y, max.y)
         * @param min Minimum component values (inclusive)
         * @param max Maximum component values (exclusive)
         * @return Random 2D vector
         */
⋮----
/**
         * @brief Get a random 3D vector with components in the range [0.0, 1.0)
         * @return Random 3D vector
         */
⋮----
/**
         * @brief Get a random 3D vector with components in the specified range [min, max)
         * @param min Minimum component value (inclusive)
         * @param max Maximum component value (exclusive)
         * @return Random 3D vector
         */
⋮----
/**
         * @brief Get a random 3D vector with components in the specified range [min.x, max.x), [min.y, max.y), [min.z, max.z)
         * @param min Minimum component values (inclusive)
         * @param max Maximum component values (exclusive)
         * @return Random 3D vector
         */
⋮----
/**
         * @brief Get a random 4D vector with components in the range [0.0, 1.0)
         * @return Random 4D vector
         */
⋮----
/**
         * @brief Get a random 4D vector with components in the specified range [min, max)
         * @param min Minimum component value (inclusive)
         * @param max Maximum component value (exclusive)
         * @return Random 4D vector
         */
⋮----
/**
         * @brief Get a random 4D vector with components in the specified range [min.x, max.x), [min.y, max.y), [min.z, max.z), [min.w, max.w)
         * @param min Minimum component values (inclusive)
         * @param max Maximum component values (exclusive)
         * @return Random 4D vector
         */
⋮----
/**
         * @brief Get a random 2D unit direction vector
         * @return Normalized random 2D direction vector
         */
⋮----
/**
         * @brief Get a random 3D unit direction vector
         * @return Normalized random 3D direction vector
         */
⋮----
/**
         * @brief Get a random point inside a circle of specified radius
         * @param radius The radius of the circle
         * @return Random point inside the circle
         */
⋮----
/**
         * @brief Get a random point on the perimeter of a circle of specified radius
         * @param radius The radius of the circle
         * @return Random point on the circle perimeter
         */
⋮----
/**
         * @brief Get a random point inside a sphere of specified radius
         * @param radius The radius of the sphere
         * @return Random point inside the sphere
         */
⋮----
/**
         * @brief Get a random point on the surface of a sphere of specified radius
         * @param radius The radius of the sphere
         * @return Random point on the sphere surface
         */
⋮----
/**
         * @brief Get a random point inside a cube of specified size
         * @param size The size of the cube (edge length)
         * @return Random point inside the cube
         */
⋮----
/**
         * @brief Get a random point inside a box of specified dimensions
         * @param dimensions The dimensions of the box
         * @return Random point inside the box
         */
⋮----
/**
         * @brief Get a random angle in the range [0, 2π)
         * @return Random angle in radians
         */
float getAngle();
⋮----
/**
         * @brief Get a random quaternion representing a rotation
         * @return Random quaternion (normalized)
         */
⋮----
/**
         * @brief Get a random value from a normal distribution
         * @param mean Mean value of the distribution
         * @param stdDev Standard deviation of the distribution
         * @return Random value from the normal distribution
         */
float getNormal(float mean = 0.0f, float stdDev = 1.0f);
⋮----
/**
         * @brief Get a random value from an exponential distribution
         * @param lambda Rate parameter of the distribution
         * @return Random value from the exponential distribution
         */
float getExponential(float lambda = 1.0f);
⋮----
/**
         * @brief Get a random color with optional random alpha
         * @param randomAlpha Whether to randomize the alpha component
         * @return Random color
         */
Color getColor(bool randomAlpha = false);
⋮----
/**
         * @brief Get a random color using the HSV color model
         * @param minHue Minimum hue value (degrees)
         * @param maxHue Maximum hue value (degrees)
         * @param minSat Minimum saturation value [0.0, 1.0]
         * @param maxSat Maximum saturation value [0.0, 1.0]
         * @param minVal Minimum value/brightness [0.0, 1.0]
         * @param maxVal Maximum value/brightness [0.0, 1.0]
         * @param alpha Alpha value [0.0, 1.0]
         * @return Random color in the specified HSV range
         */
Color getColorHSV(float minHue = 0.0f, float maxHue = 360.0f,
⋮----
/**
         * @brief Get a weighted random item from a container
         * @tparam T Type of items in the container
         * @param items Container of items to choose from
         * @param weights Container of weights corresponding to the items
         * @return Randomly selected item based on weights
         * @throws std::invalid_argument if containers are empty or have different sizes
         */
⋮----
/**
         * @brief Choose a random item from a container
         * @tparam Container Container type
         * @param container Container to choose from
         * @return Reference to the randomly selected item
         * @throws std::invalid_argument if container is empty
         */
⋮----
/**
         * @brief Shuffle the elements of a container randomly
         * @tparam Container Container type
         * @param container Container to shuffle
         */
⋮----
/**
         * @brief Sample a specified number of elements from a container without replacement
         * @tparam Container Container type
         * @param container Container to sample from
         * @param count Number of elements to sample
         * @return Vector containing the sampled elements
         */
⋮----
/**
         * @brief Test if an event with the given probability occurs
         * @param probability Probability of the event [0.0, 1.0]
         * @return True if the event occurs, false otherwise
         */
bool chance(float probability);
⋮----
/**
         * @brief Simulate rolling a die with the specified number of sides
         * @param sides Number of sides on the die
         * @return Result of the die roll [1, sides]
         */
int roll(int sides);
⋮----
/**
         * @brief Simulate rolling multiple dice and summing the results
         * @param count Number of dice to roll
         * @param sides Number of sides on each die
         * @return Sum of the dice rolls
         */
int rollDice(int count, int sides);
⋮----
/**
         * @brief Get the global random number generator instance
         * @return Reference to the global random instance
         */
static Random& getInstance();
⋮----
// Thread-local random engine
⋮----
// Standard distributions
⋮----
// Template method implementations
⋮----
// Calculate sum of weights
⋮----
// Get a random value between 0 and sum
⋮----
// Find the item that corresponds to the random value
⋮----
// Fallback (should not happen unless floating point precision issues)
⋮----
// If requesting all or more than available, return a copy of the whole container
⋮----
// Create a copy to shuffle
⋮----
// Shuffle and take the first 'count' elements
⋮----
// Global convenience functions
/**
     * @brief Get a random integer in the specified range [min, max]
     * @param min Minimum value (inclusive)
     * @param max Maximum value (inclusive)
     * @return Random integer in the range [min, max]
     */
int32_t randomInt(int32_t min, int32_t max);
⋮----
/**
     * @brief Get a random float in the specified range [min, max)
     * @param min Minimum value (inclusive)
     * @param max Maximum value (exclusive)
     * @return Random float in the range [min, max)
     */
float randomFloat(float min = 0.0f, float max = 1.0f);
⋮----
/**
     * @brief Get a random boolean with specified probability
     * @param probability Probability of returning true (0.0 to 1.0)
     * @return Random boolean
     */
bool randomBool(float probability = 0.5f);
⋮----
/**
     * @brief Get a random 3D unit direction vector
     * @return Normalized random 3D direction vector
     */
⋮----
/**
     * @brief Get a random color
     * @return Random color
     */
Color randomColor();
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Ray.h">
// -------------------------------------------------------------------------
// Ray.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Ray class for raycasting operations in physics, rendering, and user interaction

     * Represents a ray with origin and direction, providing optimized intersection tests
     * with various primitives, transformation operations, distance calculations, and
     * debug visualization.
     */
⋮----
/**
         * @brief Default constructor creating a ray along positive Z-axis
         */
⋮----
/**
         * @brief Constructor with origin and direction
         * @param origin The origin point of the ray
         * @param direction The direction vector of the ray (will be normalized)
         */
⋮----
/**
         * @brief Get the ray's origin point
         * @return The origin point
         */
const glm::vec3& getOrigin() const
⋮----
/**
         * @brief Get the ray's direction vector
         * @return The normalized direction vector
         */
const glm::vec3& getDirection() const
⋮----
/**
         * @brief Set the ray's origin point
         * @param origin The new origin point
         */
void setOrigin(const glm::vec3& origin);
⋮----
/**
         * @brief Set the ray's direction vector
         * @param direction The new direction vector (will be normalized)
         */
void setDirection(const glm::vec3& direction);
⋮----
/**
         * @brief Get the inverse of the ray's direction vector
         * Used for optimized intersection tests
         * @return The inverse direction vector (1/dx, 1/dy, 1/dz)
         */
const glm::vec3& getInvDirection() const
⋮----
/**
         * @brief Get signs of direction components for optimized AABB intersection
         * @return Vector with 1 for negative components, 0 for positive components
         */
const glm::ivec3& getDirIsNeg() const
⋮----
/**
         * @brief Get a point along the ray at distance t
         * @param t Distance along the ray
         * @return The point at origin + t * direction
         */
⋮----
/**
         * @brief Transform the ray by a 4x4 matrix
         * @param matrix The transformation matrix
         * @return A new transformed ray
         */
Ray transform(const glm::mat4& matrix) const;
⋮----
/**
         * @brief Test intersection with an axis-aligned bounding box
         * Uses the optimized slab method with cached inverse direction
         * @param aabb The axis-aligned bounding box to test against
         * @param tMin [out] Near intersection distance if hit
         * @param tMax [out] Far intersection distance if hit
         * @return True if the ray intersects the AABB
         */
bool intersectAABB(const AABB& aabb, float& tMin, float& tMax) const;
⋮----
/**
         * @brief Test intersection with a sphere
         * @param center The center of the sphere
         * @param radius The radius of the sphere
         * @param t [out] Distance along the ray to the intersection point
         * @return True if the ray intersects the sphere
         */
bool intersectSphere(const glm::vec3& center, float radius, float& t) const;
⋮----
/**
         * @brief Test intersection with a plane defined by normal and distance
         * @param normal The plane normal (must be normalized)
         * @param distance The plane distance from origin
         * @param t [out] Distance along the ray to the intersection point
         * @return True if the ray intersects the plane
         */
bool intersectPlane(const glm::vec3& normal, float distance, float& t) const;
⋮----
/**
         * @brief Test intersection with a plane defined by normal and point
         * @param normal The plane normal (must be normalized)
         * @param point A point on the plane
         * @param t [out] Distance along the ray to the intersection point
         * @return True if the ray intersects the plane
         */
bool intersectPlane(const glm::vec3& normal, const glm::vec3& point, float& t) const;
⋮----
/**
         * @brief Test intersection with a triangle using Möller–Trumbore algorithm
         * @param v0 First vertex of the triangle
         * @param v1 Second vertex of the triangle
         * @param v2 Third vertex of the triangle
         * @param t [out] Distance along the ray to the intersection point
         * @param u [out] Barycentric coordinate of the intersection
         * @param v [out] Barycentric coordinate of the intersection
         * @param backfaceCulling Whether to ignore intersections with back faces
         * @return True if the ray intersects the triangle
         */
bool intersectTriangle(const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2,
⋮----
/**
         * @brief Test intersection with a triangle mesh
         * @param vertices Array of vertex positions
         * @param indices Array of triangle indices
         * @param t [out] Distance along the ray to the closest intersection point
         * @param triangleIndex [out] Index of the intersected triangle
         * @return True if the ray intersects any triangle in the mesh
         */
bool intersectTriangleMesh(const std::vector<glm::vec3>& vertices,
⋮----
/**
         * @brief Calculate distance from a point to the ray
         * @param point The point to calculate distance to
         * @return The shortest distance from the point to the ray
         */
float distanceToPoint(const glm::vec3& point) const;
⋮----
/**
         * @brief Calculate distance from a line segment to the ray
         * @param start Start point of the line segment
         * @param end End point of the line segment
         * @param t [out] Parameter along the ray for closest point
         * @param closestPoint [out] Closest point on the line segment to the ray
         * @return The shortest distance from the ray to the line segment
         */
float distanceToLineSegment(const glm::vec3& start, const glm::vec3& end,
⋮----
/**
         * @brief Calculate signed distance from the ray origin to a plane
         * @param normal The plane normal (must be normalized)
         * @param distance The plane distance from origin
         * @return The signed distance from ray origin to plane
         */
float distanceToPlane(const glm::vec3& normal, float distance) const;
⋮----
/**
         * @brief Calculate signed distance from the ray origin to a plane
         * @param normal The plane normal (must be normalized)
         * @param point A point on the plane
         * @return The signed distance from ray origin to plane
         */
float distanceToPlane(const glm::vec3& normal, const glm::vec3& point) const;
⋮----
/**
         * @brief Set ray differentials for texture mapping
         * Ray differentials represent how the ray changes with respect to
         * screen-space coordinates, used for texture filtering.
         * @param dPdx Ray origin differential in x direction
         * @param dPdy Ray origin differential in y direction
         * @param dDdx Ray direction differential in x direction
         * @param dDdy Ray direction differential in y direction
         */
void setDifferentials(const glm::vec3& dPdx, const glm::vec3& dPdy,
⋮----
/**
         * @brief Check if the ray has differentials set
         * @return True if ray differentials are available
         */
bool hasDifferentials() const
⋮----
/**
         * @brief Get the ray origin differential in x direction
         * @return The ray origin differential in x direction
         */
⋮----
/**
         * @brief Get the ray origin differential in y direction
         * @return The ray origin differential in y direction
         */
⋮----
/**
         * @brief Get the ray direction differential in x direction
         * @return The ray direction differential in x direction
         */
⋮----
/**
         * @brief Get the ray direction differential in y direction
         * @return The ray direction differential in y direction
         */
⋮----
/**
         * @brief Draw the ray for debugging purposes
         * @param length Length of the ray to draw
         * @param color Color of the ray
         */
void debugDraw(float length = 100.0f, const glm::vec3& color = glm::vec3(1.0f, 1.0f, 0.0f)) const;
⋮----
glm::vec3 m_origin;      ///< Ray origin point
glm::vec3 m_direction;   ///< Normalized ray direction
⋮----
// Cached values for optimized intersection tests
glm::vec3 m_invDirection;  ///< Inverse of direction (1/dx, 1/dy, 1/dz)
glm::ivec3 m_dirIsNeg;     ///< Signs of direction components (1 if negative, 0 if positive)
⋮----
// Ray differentials for texture filtering
bool m_hasDifferentials;   ///< Whether differentials are available
glm::vec3 m_dPdx;          ///< Ray origin differential in x
glm::vec3 m_dPdy;          ///< Ray origin differential in y
glm::vec3 m_dDdx;          ///< Ray direction differential in x
glm::vec3 m_dDdy;          ///< Ray direction differential in y
⋮----
/**
         * @brief Update cached values after changing origin or direction
         */
void updateCachedValues();
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/StringUtils.h">
// -------------------------------------------------------------------------
// StringUtils.h
⋮----
/**
     * @brief Provides utility functions for string manipulation.
     *
     * StringUtils contains static methods for common string operations such as
     * trimming, case conversion, splitting, formatting, and path manipulation.
     * All methods are designed to be efficient and consistent with modern C++ practices.
     */
⋮----
/**
         * @brief Trims whitespace from both ends of a string
         * @param str The string to trim
         * @return The trimmed string
         */
⋮----
/**
         * @brief Trims whitespace from the beginning of a string
         * @param str The string to trim
         * @return The trimmed string
         */
static std::string trimLeft(const std::string& str);
⋮----
/**
         * @brief Trims whitespace from the end of a string
         * @param str The string to trim
         * @return The trimmed string
         */
static std::string trimRight(const std::string& str);
⋮----
/**
         * @brief Converts a string to uppercase
         * @param str The string to convert
         * @return The uppercase version of the string
         */
static std::string toUpper(const std::string& str);
⋮----
/**
         * @brief Converts a string to lowercase
         * @param str The string to convert
         * @return The lowercase version of the string
         */
static std::string toLower(const std::string& str);
⋮----
/**
         * @brief Converts a string to title case (first letter of each word capitalized)
         * @param str The string to convert
         * @return The title case version of the string
         */
static std::string toTitleCase(const std::string& str);
⋮----
/**
         * @brief Converts a string to camelCase (first word lowercase, subsequent words capitalized)
         * @param str The string to convert
         * @return The camelCase version of the string
         */
static std::string toCamelCase(const std::string& str);
⋮----
/**
         * @brief Converts a string to PascalCase (all words capitalized)
         * @param str The string to convert
         * @return The PascalCase version of the string
         */
static std::string toPascalCase(const std::string& str);
⋮----
/**
         * @brief Converts a string to snake_case
         * @param str The string to convert
         * @return The snake_case version of the string
         */
static std::string toSnakeCase(const std::string& str);
⋮----
/**
         * @brief Converts a string to kebab-case
         * @param str The string to convert
         * @return The kebab-case version of the string
         */
static std::string toKebabCase(const std::string& str);
⋮----
/**
         * @brief Splits a string by a delimiter
         * @param str The string to split
         * @param delimiter The delimiter to split by
         * @return A vector of substrings
         */
static std::vector<std::string> split(const std::string& str, const std::string& delimiter);
⋮----
/**
         * @brief Splits a string by whitespace
         * @param str The string to split
         * @return A vector of substrings
         */
static std::vector<std::string> splitByWhitespace(const std::string& str);
⋮----
/**
         * @brief Joins a vector of strings with a delimiter
         * @param strings The strings to join
         * @param delimiter The delimiter to join with
         * @return The joined string
         */
static std::string join(const std::vector<std::string>& strings, const std::string& delimiter);
⋮----
/**
         * @brief Replaces the first occurrence of a substring
         * @param str The string to perform replacement on
         * @param from The substring to replace
         * @param to The replacement substring
         * @return The string with replacement
         */
static std::string replace(const std::string& str, const std::string& from, const std::string& to);
⋮----
/**
         * @brief Replaces all occurrences of a substring
         * @param str The string to perform replacement on
         * @param from The substring to replace
         * @param to The replacement substring
         * @return The string with all replacements
         */
static std::string replaceAll(const std::string& str, const std::string& from, const std::string& to);
⋮----
/**
         * @brief Checks if a string starts with a prefix
         * @param str The string to check
         * @param prefix The prefix to check for
         * @return True if the string starts with the prefix, false otherwise
         */
static bool startsWith(const std::string& str, const std::string& prefix);
⋮----
/**
         * @brief Checks if a string ends with a suffix
         * @param str The string to check
         * @param suffix The suffix to check for
         * @return True if the string ends with the suffix, false otherwise
         */
static bool endsWith(const std::string& str, const std::string& suffix);
⋮----
/**
         * @brief Checks if a string contains a substring
         * @param str The string to check
         * @param substring The substring to check for
         * @return True if the string contains the substring, false otherwise
         */
static bool contains(const std::string& str, const std::string& substring);
⋮----
/**
         * @brief Checks if a string contains only alphabetic characters
         * @param str The string to check
         * @return True if the string is alphabetic, false otherwise
         */
static bool isAlpha(const std::string& str);
⋮----
/**
         * @brief Checks if a string contains only numeric characters
         * @param str The string to check
         * @return True if the string is numeric, false otherwise
         */
static bool isNumeric(const std::string& str);
⋮----
/**
         * @brief Checks if a string contains only alphanumeric characters
         * @param str The string to check
         * @return True if the string is alphanumeric, false otherwise
         */
static bool isAlphaNumeric(const std::string& str);
⋮----
/**
         * @brief Formats a string like sprintf but type-safe
         * @param format The format string
         * @param args The arguments to format
         * @return The formatted string
         */
⋮----
/**
         * @brief Pads a string on the left
         * @param str The string to pad
         * @param totalWidth The desired width of the resulting string
         * @param padChar The character to pad with
         * @return The padded string
         */
static std::string padLeft(const std::string& str, size_t totalWidth, char padChar = ' ');
⋮----
/**
         * @brief Pads a string on the right
         * @param str The string to pad
         * @param totalWidth The desired width of the resulting string
         * @param padChar The character to pad with
         * @return The padded string
         */
static std::string padRight(const std::string& str, size_t totalWidth, char padChar = ' ');
⋮----
/**
         * @brief Centers a string with padding
         * @param str The string to center
         * @param totalWidth The desired width of the resulting string
         * @param padChar The character to pad with
         * @return The centered string
         */
static std::string center(const std::string& str, size_t totalWidth, char padChar = ' ');
⋮----
/**
         * @brief Parses a string to an integer
         * @param str The string to parse
         * @param defaultValue The default value to return if parsing fails
         * @return The parsed integer or the default value
         */
static int parseInt(const std::string& str, int defaultValue = 0);
⋮----
/**
         * @brief Parses a string to a float
         * @param str The string to parse
         * @param defaultValue The default value to return if parsing fails
         * @return The parsed float or the default value
         */
static float parseFloat(const std::string& str, float defaultValue = 0.0f);
⋮----
/**
         * @brief Parses a string to a boolean
         * @param str The string to parse
         * @param defaultValue The default value to return if parsing fails
         * @return The parsed boolean or the default value
         */
static bool parseBool(const std::string& str, bool defaultValue = false);
⋮----
/**
         * @brief Converts an integer to a string
         * @param value The integer to convert
         * @return The string representation
         */
static std::string toString(int value);
⋮----
/**
         * @brief Converts a float to a string
         * @param value The float to convert
         * @param precision The number of decimal places
         * @return The string representation
         */
static std::string toString(float value, int precision = 6);
⋮----
/**
         * @brief Converts a double to a string
         * @param value The double to convert
         * @param precision The number of decimal places
         * @return The string representation
         */
static std::string toString(double value, int precision = 10);
⋮----
/**
         * @brief Converts a boolean to a string
         * @param value The boolean to convert
         * @return "true" or "false"
         */
static std::string toString(bool value);
⋮----
/**
         * @brief Converts a vec2 to a string
         * @param value The vec2 to convert
         * @param precision The number of decimal places
         * @return The string representation
         */
static std::string toString(const glm::vec2& value, int precision = 2);
⋮----
/**
         * @brief Converts a vec3 to a string
         * @param value The vec3 to convert
         * @param precision The number of decimal places
         * @return The string representation
         */
static std::string toString(const glm::vec3& value, int precision = 2);
⋮----
/**
         * @brief Converts a vec4 to a string
         * @param value The vec4 to convert
         * @param precision The number of decimal places
         * @return The string representation
         */
static std::string toString(const glm::vec4& value, int precision = 2);
⋮----
/**
         * @brief Encodes a string for URL usage
         * @param str The string to encode
         * @return The URL encoded string
         */
static std::string urlEncode(const std::string& str);
⋮----
/**
         * @brief Decodes a URL encoded string
         * @param str The string to decode
         * @return The decoded string
         */
static std::string urlDecode(const std::string& str);
⋮----
/**
         * @brief Encodes binary data to base64
         * @param data The binary data to encode
         * @return The base64 encoded string
         */
static std::string base64Encode(const std::vector<uint8_t>& data);
⋮----
/**
         * @brief Decodes a base64 string to binary data
         * @param str The base64 string to decode
         * @return The decoded binary data
         */
static std::vector<uint8_t> base64Decode(const std::string& str);
⋮----
/**
         * @brief Computes a hash value for a string
         * @param str The string to hash
         * @return The hash value
         */
static size_t hash(const std::string& str);
⋮----
/**
         * @brief Computes the MD5 hash of a string
         * @param str The string to hash
         * @return The MD5 hash as a hexadecimal string
         */
static std::string md5(const std::string& str);
⋮----
/**
         * @brief Computes the SHA1 hash of a string
         * @param str The string to hash
         * @return The SHA1 hash as a hexadecimal string
         */
static std::string sha1(const std::string& str);
⋮----
/**
         * @brief Gets the file extension from a path
         * @param path The file path
         * @return The file extension (without the dot)
         */
static std::string getPathExtension(const std::string& path);
⋮----
/**
         * @brief Gets the file name from a path
         * @param path The file path
         * @return The file name (with extension)
         */
static std::string getFileName(const std::string& path);
⋮----
/**
         * @brief Gets the file name from a path without extension
         * @param path The file path
         * @return The file name without extension
         */
static std::string getFileNameWithoutExtension(const std::string& path);
⋮----
/**
         * @brief Gets the directory path from a file path
         * @param path The file path
         * @return The directory path
         */
static std::string getDirectoryPath(const std::string& path);
⋮----
/**
         * @brief Normalizes a path (removes redundant separators, resolves '..' and '.')
         * @param path The path to normalize
         * @return The normalized path
         */
static std::string normalizePath(const std::string& path);
⋮----
/**
         * @brief Combines two paths
         * @param path1 The first path
         * @param path2 The second path
         * @return The combined path
         */
static std::string combinePaths(const std::string& path1, const std::string& path2);
⋮----
// Prevent instantiation
⋮----
// Template implementation for format
⋮----
// Calculate the required buffer size
⋮----
// Allocate buffer of required size (+1 for null terminator)
⋮----
// Format the string
⋮----
// Remove the null terminator from the string
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="include/Utility/Transform.h">
// -------------------------------------------------------------------------
// Transform.h
⋮----
/**
     * @brief Encapsulates position, rotation, and scale for spatial transformations.
     *
     * The Transform class provides functionality for handling 3D transformations including:
     * - Position, rotation and scale management
     * - Matrix generation for rendering and physics
     * - Support for hierarchical transformations
     * - Interpolation between different transforms
     * - Conversion between different rotation representations
     * - Efficient matrix generation using dirty flags
     * - Local and world space operations
     */
⋮----
/**
         * @brief Default constructor.
         * Initializes position to origin, rotation to identity, and scale to (1,1,1).
         */
⋮----
/**
         * @brief Constructor with position.
         * @param position The initial position
         */
⋮----
/**
         * @brief Constructor with position and rotation.
         * @param position The initial position
         * @param rotation The initial rotation as quaternion
         */
⋮----
/**
         * @brief Constructor with position, rotation and scale.
         * @param position The initial position
         * @param rotation The initial rotation as quaternion
         * @param scale The initial scale
         */
⋮----
/**
         * @brief Constructor from a transformation matrix.
         * Decomposes the matrix into position, rotation, and scale.
         * @param matrix The transformation matrix
         */
⋮----
/**
         * @brief Sets the position.
         * @param position The new position
         */
void setPosition(const glm::vec3& position);
⋮----
/**
         * @brief Sets the position using individual components.
         * @param x The x-coordinate
         * @param y The y-coordinate
         * @param z The z-coordinate
         */
void setPosition(float x, float y, float z);
⋮----
/**
         * @brief Gets the current position.
         * @return The current position
         */
const glm::vec3& getPosition() const;
⋮----
/**
         * @brief Translates the position by a delta vector.
         * @param delta The translation delta
         */
void translate(const glm::vec3& delta);
⋮----
/**
         * @brief Translates the position by individual delta components.
         * @param x The x delta
         * @param y The y delta
         * @param z The z delta
         */
void translate(float x, float y, float z);
⋮----
/**
         * @brief Sets the rotation using a quaternion.
         * @param rotation The new rotation as quaternion
         */
void setRotation(const glm::quat& rotation);
⋮----
/**
         * @brief Sets the rotation using Euler angles (in radians).
         * @param eulerAngles The Euler angles in radians (pitch, yaw, roll)
         */
void setRotation(const glm::vec3& eulerAngles);
⋮----
/**
         * @brief Sets the rotation using individual Euler angles (in radians).
         * @param yaw The yaw angle in radians (rotation around Y-axis)
         * @param pitch The pitch angle in radians (rotation around X-axis)
         * @param roll The roll angle in radians (rotation around Z-axis)
         */
void setRotation(float yaw, float pitch, float roll);
⋮----
/**
         * @brief Sets the rotation from an axis-angle representation.
         * @param axis The rotation axis (should be normalized)
         * @param angle The rotation angle in radians
         */
void setRotationFromAxisAngle(const glm::vec3& axis, float angle);
⋮----
/**
         * @brief Gets the current rotation as quaternion.
         * @return The current rotation quaternion
         */
const glm::quat& getRotation() const;
⋮----
/**
         * @brief Gets the current rotation as Euler angles (in radians).
         * @return The current rotation as Euler angles in radians
         */
glm::vec3 getEulerAngles() const;
⋮----
/**
         * @brief Applies an additional rotation.
         * @param rotation The rotation to apply as quaternion
         */
void rotate(const glm::quat& rotation);
⋮----
/**
         * @brief Applies an additional rotation specified by Euler angles.
         * @param eulerAngles The Euler angles in radians (pitch, yaw, roll)
         */
void rotate(const glm::vec3& eulerAngles);
⋮----
/**
         * @brief Applies an additional rotation specified by individual Euler angles.
         * @param yaw The yaw angle in radians (rotation around Y-axis)
         * @param pitch The pitch angle in radians (rotation around X-axis)
         * @param roll The roll angle in radians (rotation around Z-axis)
         */
void rotate(float yaw, float pitch, float roll);
⋮----
/**
         * @brief Rotates around a specific point.
         * @param point The point to rotate around
         * @param rotation The rotation to apply as quaternion
         */
void rotateAround(const glm::vec3& point, const glm::quat& rotation);
⋮----
/**
         * @brief Sets the scale.
         * @param scale The new scale
         */
void setScale(const glm::vec3& scale);
⋮----
/**
         * @brief Sets a uniform scale for all axes.
         * @param uniformScale The uniform scale factor to apply to all axes
         */
void setScale(float uniformScale);
⋮----
/**
         * @brief Sets the scale using individual components.
         * @param x The x-scale
         * @param y The y-scale
         * @param z The z-scale
         */
void setScale(float x, float y, float z);
⋮----
/**
         * @brief Gets the current scale.
         * @return The current scale
         */
const glm::vec3& getScale() const;
⋮----
/**
         * @brief Scales by a vector.
         * @param scale The scale factors to apply
         */
void scaleBy(const glm::vec3& scale);
⋮----
/**
         * @brief Scales uniformly by a scalar.
         * @param scale The uniform scale factor to apply
         */
void scaleBy(float scale);
⋮----
/**
         * @brief Gets the forward direction vector based on rotation.
         * @return The forward direction vector (normalized)
         */
glm::vec3 getForward() const;
⋮----
/**
         * @brief Gets the right direction vector based on rotation.
         * @return The right direction vector (normalized)
         */
glm::vec3 getRight() const;
⋮----
/**
         * @brief Gets the up direction vector based on rotation.
         * @return The up direction vector (normalized)
         */
glm::vec3 getUp() const;
⋮----
/**
         * @brief Gets the transformation matrix.
         * Updates the cached matrix if dirty.
         * @return The transformation matrix
         */
const glm::mat4& getMatrix() const;
⋮----
/**
         * @brief Gets the inverse transformation matrix.
         * @return The inverse transformation matrix
         */
glm::mat4 getInverseMatrix() const;
⋮----
/**
         * @brief Sets the transform from a matrix.
         * Decomposes the matrix into position, rotation, and scale.
         * @param matrix The transformation matrix
         */
void setFromMatrix(const glm::mat4& matrix);
⋮----
/**
         * @brief Decomposes a matrix into position, rotation, and scale.
         * @param matrix The matrix to decompose
         * @param[out] position The resulting position
         * @param[out] rotation The resulting rotation
         * @param[out] scale The resulting scale
         */
static void decompose(const glm::mat4& matrix, glm::vec3& position, glm::quat& rotation, glm::vec3& scale);
⋮----
/**
         * @brief Transforms a point from local space to world space.
         * @param point The point in local space
         * @return The transformed point in world space
         */
glm::vec3 transformPoint(const glm::vec3& point) const;
⋮----
/**
         * @brief Transforms a direction vector from local space to world space.
         * Does not apply scale or translation, only rotation.
         * @param direction The direction in local space
         * @return The transformed direction in world space
         */
glm::vec3 transformDirection(const glm::vec3& direction) const;
⋮----
/**
         * @brief Transforms a point from world space to local space.
         * @param point The point in world space
         * @return The transformed point in local space
         */
glm::vec3 inverseTransformPoint(const glm::vec3& point) const;
⋮----
/**
         * @brief Transforms a direction vector from world space to local space.
         * Does not apply scale or translation, only rotation.
         * @param direction The direction in world space
         * @return The transformed direction in local space
         */
glm::vec3 inverseTransformDirection(const glm::vec3& direction) const;
⋮----
/**
         * @brief Combines this transform with a parent transform.
         * @param parent The parent transform
         * @return The combined transform
         */
⋮----
/**
         * @brief Gets this transform relative to a parent transform.
         * @param parent The parent transform
         * @return The relative transform
         */
Transform relativeTo(const Transform& parent) const;
⋮----
/**
         * @brief Linearly interpolates between two transforms.
         * @param a The starting transform
         * @param b The ending transform
         * @param t The interpolation parameter (0.0 to 1.0)
         * @return The interpolated transform
         */
static Transform lerp(const Transform& a, const Transform& b, float t);
⋮----
/**
         * @brief Sets the rotation to look at a target point.
         * @param target The target point to look at
         * @param up The up direction (default is Y-up)
         */
void lookAt(const glm::vec3& target, const glm::vec3& up = glm::vec3(0.0f, 1.0f, 0.0f));
⋮----
/**
         * @brief Resets the transform to identity.
         * Sets position to origin, rotation to identity, and scale to (1,1,1).
         */
void reset();
⋮----
// Position, rotation, and scale components
glm::vec3 m_position;   ///< The position component
glm::quat m_rotation;   ///< The rotation component as quaternion
glm::vec3 m_scale;      ///< The scale component
⋮----
// Cached transformation matrix with dirty flag
mutable glm::mat4 m_matrix;      ///< Cached transformation matrix
mutable bool m_matrixDirty;      ///< Flag indicating if matrix needs to be updated
⋮----
/**
         * @brief Marks the matrix as dirty, requiring an update.
         */
void markDirty();
⋮----
/**
         * @brief Updates the cached transformation matrix.
         */
void updateMatrix() const;
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Core/Application.cpp">
// -------------------------------------------------------------------------
// Application.cpp
⋮----
// Initialize static members
⋮----
Application& Application::getInstance()
⋮----
std::lock_guard<std::mutex> lock(m_instanceMutex);
⋮----
Application::Application()
⋮----
// Create the configuration manager
⋮----
bool Application::initialize()
⋮----
// Initialize config manager first
⋮----
// Register the config manager as a subsystem
⋮----
// Sort subsystems based on dependencies
⋮----
// Initialize all subsystems in dependency order
⋮----
bool Application::sortSubsystemDependencies()
⋮----
// Create a temporary vector for the new order
⋮----
// Topological sort using DFS
⋮----
// Find the subsystem with this name
⋮----
// Visit all nodes
⋮----
// Update the initialization order
⋮----
bool Application::initializeSubsystem(const std::type_index& typeIndex, std::set<std::type_index>& initializedSystems)
⋮----
// Check if already initialized
⋮----
// Legitimate dependencies first
⋮----
// Initialize the subsystem
⋮----
void Application::run()
⋮----
// Get configuration values for the main loop
⋮----
// Cap extremely long frames (e.g., after debugging pause)
⋮----
// Fixed timestep update
⋮----
// Variable timestep update
⋮----
// Always render once per frame
⋮----
// Optional frame rate limiter
⋮----
void Application::update(float deltaTime)
⋮----
// Update all subsystems in dependency order
⋮----
void Application::render()
⋮----
// Call render on all subsystems in dependency order
⋮----
void Application::shutdown()
⋮----
// Shutdown subsystems in reverse dependency order
⋮----
void Application::quit()
⋮----
float Application::getDeltaTime() const
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/ConfigManager.cpp">
// -------------------------------------------------------------------------
// ConfigManager.cpp
⋮----
// JSON parsing library
⋮----
// YAML parsing library
⋮----
// Initialize static members
⋮----
ConfigManager& ConfigManager::getInstance()
⋮----
ConfigManager::ConfigManager() : m_fileWatcher(std::make_unique<FileWatcher>())
⋮----
// Constructor - nothing to do here
⋮----
bool ConfigManager::initialize()
⋮----
// Initialize file watcher
⋮----
// Load default engine configuration
⋮----
// Automatically watch the engine config
⋮----
void ConfigManager::update(float deltaTime)
⋮----
// Accumulate time since last check
⋮----
// Only check for changes at the specified interval
⋮----
void ConfigManager::shutdown()
⋮----
// Stop watching all files
⋮----
// Clear all configuration values
std::lock_guard<std::mutex> lock(m_configMutex);
⋮----
std::vector<std::string> ConfigManager::getDependencies() const
⋮----
bool ConfigManager::loadConfig(const std::string& filename, const std::string& section)
⋮----
// Track which file this section comes from
⋮----
// Use filename as default section
⋮----
bool ConfigManager::saveConfig(const std::string& filename, const std::string& section)
⋮----
// Create directory if it doesn't exist
⋮----
// Get configuration values for this section
⋮----
// Remove section prefix if present
⋮----
// Convert variant to JSON
⋮----
// Write JSON to file
std::ofstream file(filename);
⋮----
file << jsonConfig.dump(4); // Pretty print with 4-space indent
⋮----
// Convert variant to YAML
⋮----
// Write YAML to file
⋮----
int ConfigManager::getInt(const std::string& key, int defaultValue) const
⋮----
float ConfigManager::getFloat(const std::string& key, float defaultValue) const
⋮----
bool ConfigManager::getBool(const std::string& key, bool defaultValue) const
⋮----
std::string ConfigManager::getString(const std::string& key, const std::string& defaultValue) const
⋮----
glm::vec2 ConfigManager::getVec2(const std::string& key, const glm::vec2& defaultValue) const
⋮----
glm::vec3 ConfigManager::getVec3(const std::string& key, const glm::vec3& defaultValue) const
⋮----
glm::vec4 ConfigManager::getVec4(const std::string& key, const glm::vec4& defaultValue) const
⋮----
bool ConfigManager::hasKey(const std::string& key) const
⋮----
void ConfigManager::watch(const std::string& filename, bool enable)
⋮----
uint64_t ConfigManager::registerChangeCallback(const ConfigChangeCallback& callback)
⋮----
void ConfigManager::unregisterChangeCallback(uint64_t callbackId)
⋮----
void ConfigManager::checkWatchedFiles()
⋮----
// Get all sections associated with this file
⋮----
// Reload all sections from this file
⋮----
// Nofity about changes to all configs in this section
⋮----
void ConfigManager::parseConfigFile(const std::string& filename, const std::string& section)
⋮----
// Parse JSON file
std::ifstream file(filename);
⋮----
// Process all key-value pairs
⋮----
// Skip null values
⋮----
// Parse YAML file
⋮----
// Try to determine the type
⋮----
// First try as integer
⋮----
// Then try as float
⋮----
// Then try as boolean
⋮----
// Default to string
⋮----
void ConfigManager::notifyConfigChange(const std::string& key, const std::string& section)
⋮----
// Create event for the change
ConfigChangeEvent event(key, section);
⋮----
// Notify local callbacks
⋮----
// Dispatch through the event system if available
⋮----
std::string ConfigManager::getFileFormat(const std::string& filename) const
⋮----
fs::path path(filename);
⋮----
ConfigManager::stringToVariant(const std::string& value, const std::string& type) const
⋮----
std::istringstream iss(value);
⋮----
// Template specializations
⋮----
// Try converting from float
⋮----
// Try converting from int
⋮----
// Try converting from other types
⋮----
// FileWatcher Implementation
⋮----
FileWatcher::FileWatcher()
⋮----
// Nothing to initialize
⋮----
// Nothing to clean up
⋮----
void FileWatcher::addWatch(const std::string& filename)
⋮----
// Store initial modification time
⋮----
void FileWatcher::removeWatch(const std::string& filename)
⋮----
std::vector<std::string> FileWatcher::checkChanges()
⋮----
it->second = currentModTime; // Update stored timestamp
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/Logger.cpp">
// -------------------------------------------------------------------------
// Logger.cpp
⋮----
// ConsoleLogChannel implementation
ConsoleLogChannel::ConsoleLogChannel()
⋮----
void ConsoleLogChannel::write(LogLevel level, const std::string& message)
⋮----
// Set console color based on log level
⋮----
std::cout << "\033[37m"; // White
⋮----
std::cout << "\033[32m"; // Green
⋮----
std::cout << "\033[33m"; // Yellow
⋮----
std::cout << "\033[31m"; // Red
⋮----
std::cout << "\033[35m"; // Magenta
⋮----
void ConsoleLogChannel::flush()
⋮----
// FileLogChannel implementation
FileLogChannel::FileLogChannel(const std::string& filename)
⋮----
void FileLogChannel::write(LogLevel level, const std::string& message)
⋮----
void FileLogChannel::flush()
⋮----
// Logger implementation
Logger::Logger()
⋮----
Logger& Logger::getInstance()
⋮----
bool Logger::initialize()
⋮----
std::lock_guard<std::mutex> lock(m_logMutex);
⋮----
// Add default console channel
⋮----
void Logger::shutdown()
⋮----
// Flush and clear all channels
⋮----
void Logger::setLogLevel(LogLevel level)
⋮----
LogLevel Logger::getLogLevel() const
⋮----
void Logger::addChannel(std::shared_ptr<LogChannel> channel)
⋮----
void Logger::removeChannel(std::shared_ptr<LogChannel> channel)
⋮----
void Logger::setCategory(const std::string& category)
⋮----
void Logger::clearCategory()
⋮----
void Logger::log(LogLevel level, const std::string& message)
⋮----
// Early return if message level is below current log level
⋮----
// Fall back to std::cerr if logger is not initialized
⋮----
// Write to all channels
⋮----
void Logger::debug(const std::string& message)
⋮----
void Logger::info(const std::string& message)
⋮----
void Logger::warn(const std::string& message)
⋮----
void Logger::error(const std::string& message)
⋮----
void Logger::fatal(const std::string& message)
⋮----
std::string Logger::formatMessage(LogLevel level, const std::string& message)
⋮----
// Get current time
⋮----
// Format timestamp
⋮----
// Get thread ID
⋮----
// Build the formatted message
⋮----
std::string Logger::logLevelToString(LogLevel level)
⋮----
// Global convenience functions
void debug(const std::string& message)
⋮----
void info(const std::string& message)
⋮----
void warn(const std::string& message)
⋮----
void error(const std::string& message)
⋮----
void fatal(const std::string& message)
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/MemoryManager.cpp">
// -------------------------------------------------------------------------
// MemoryManager.cpp
⋮----
// Static instance for singleton pattern
⋮----
MemoryManager::MemoryManager()
⋮----
// Initialize statistics
⋮----
MemoryManager& MemoryManager::getInstance()
⋮----
bool MemoryManager::initialize()
⋮----
std::lock_guard<std::mutex> lock(m_mutex);
⋮----
// Create some common pools by default for better performance
⋮----
void MemoryManager::shutdown()
⋮----
// Check for memory leaks
⋮----
// Output final statistics
⋮----
// Clear all pools
⋮----
// Reset statistics
⋮----
MemoryManager::AllocationStats MemoryManager::getAllocStats() const
⋮----
std::lock_guard<std::mutex> lock(m_statsMutex);
⋮----
void MemoryManager::defragmentAll()
⋮----
int MemoryManager::releaseUnused()
⋮----
// Find pools with no used blocks
⋮----
// Remove unused pools
⋮----
// Update statistics before removing
⋮----
std::lock_guard<std::mutex> statsLock(m_statsMutex);
⋮----
// Remove the pool
</file>

<file path="src/Core/MemoryPool.cpp">
// -------------------------------------------------------------------------
// MemoryPool.cpp
⋮----
MemoryPool::MemoryPool(size_t objectSize, size_t initialCapacity)
: m_objectSize(std::max(objectSize, sizeof(void*)))  // Ensure minimum size to store free list pointers
⋮----
// Align object size to the platform's alignment requirements
⋮----
// Allocate the memory block
⋮----
// Initialize the free block list
⋮----
// Report leak if blocks are still allocated when the pool is destroyed
⋮----
void* MemoryPool::allocate()
⋮----
std::lock_guard<std::mutex> lock(m_mutex);
⋮----
// If no free blocks, attempt to grow the pool
⋮----
// Grow by 50% of current capacity (minimum 16 blocks)
⋮----
// Get a block from the free list
⋮----
// Zero out the memory block for safety
⋮----
void MemoryPool::deallocate(void* ptr)
⋮----
// Validate the pointer
⋮----
// Add the block back to the free list
⋮----
size_t MemoryPool::getUsedBlocks() const
⋮----
size_t MemoryPool::getFreeBlocks() const
⋮----
size_t MemoryPool::getCapacity() const
⋮----
size_t MemoryPool::getObjectSize() const
⋮----
void MemoryPool::reserve(size_t newCapacity)
⋮----
return; // Already have enough capacity
⋮----
void MemoryPool::defragment()
⋮----
// Sort free blocks by address for better cache locality
⋮----
// Remove duplicates if any (shouldn't happen, but safety check)
⋮----
bool MemoryPool::owns(void* ptr) const
⋮----
MemoryPool::PoolStats MemoryPool::getStats() const
⋮----
// Calculate fragmentation ratio
⋮----
// Sort free blocks temporarily to check for contiguity
⋮----
// Count "islands" of free blocks
⋮----
// Fragmentation ratio: 0% = one contiguous block, 100% = maximally fragmented
⋮----
bool MemoryPool::grow(size_t additionalCapacity)
⋮----
// Allocate a new, larger block
⋮----
// Copy existing memory to the new block
⋮----
// Update free list with new blocks
⋮----
// Release old memory and update state
⋮----
bool MemoryPool::isValidPointer(void* ptr) const
⋮----
// Check if pointer is within the pool's memory range
⋮----
// Check alignment (must be at exact object boundary)
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/Resource.cpp">
// -------------------------------------------------------------------------
// Resource.cpp
⋮----
Resource::Resource(const std::string& path)
⋮----
// Extract name from path (filename without extension)
std::filesystem::path filePath(path);
⋮----
// Ensure resource is unloaded when destroyed
⋮----
bool Resource::onReload()
⋮----
// Default implementation just unloads and reloads
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/ResourceManager.cpp">
// -------------------------------------------------------------------------
// ResourceManager.cpp
⋮----
ResourceManager::ResourceManager()
⋮----
ResourceManager& ResourceManager::getInstance()
⋮----
bool ResourceManager::initialize()
⋮----
// Start async loading thread if enabled
⋮----
void ResourceManager::shutdown()
⋮----
// Stop async loading thread
⋮----
// Unload all resources
⋮----
std::lock_guard<std::mutex> lock(m_resourceMutex);
⋮----
// Unload resources outside the lock
⋮----
void ResourceManager::setAsyncLoading(bool enabled)
⋮----
// Start the loading thread
⋮----
// Stop the loading thread
⋮----
void ResourceManager::asyncLoadingThreadFunc()
⋮----
// Check if we're shutting down
⋮----
// Load the resource
⋮----
// Store file modification time for hot reloading
⋮----
// Call the callback if provided
⋮----
// If loading failed, remove from resource map
⋮----
// If no more resources of this type, remove the type map
⋮----
void ResourceManager::reloadModified()
⋮----
// First, check for modified files
⋮----
// Skip memory resources
⋮----
// Check if file exists
⋮----
// Get last modified time
⋮----
// Check if file has been modified
⋮----
// File has been modified, add to reload list
⋮----
// Update modification time
⋮----
// Now reload the modified resources
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Core/Subsystem.cpp">
// -------------------------------------------------------------------------
// Subsystem.cpp
⋮----
Subsystem::Subsystem()
⋮----
bool Subsystem::isInitialized() const
⋮----
bool Subsystem::isActive() const
⋮----
void Subsystem::setActive(bool active)
⋮----
std::vector<std::string> Subsystem::getDependencies() const
⋮----
// Default implementation returns an empty dependencies list
⋮----
} // namespace PixelCraft::Core
</file>

<file path="src/Rendering/Camera/Camera.cpp">
// -------------------------------------------------------------------------
// Camera.cpp
⋮----
Camera::Camera()
⋮----
, m_rotation(glm::quat(1.0f, 0.0f, 0.0f, 0.0f)) // Identity quaternion
⋮----
// Nothing to clean up
⋮----
const glm::mat4& Camera::getViewMatrix() const
⋮----
const glm::mat4& Camera::getProjectionMatrix() const
⋮----
const glm::mat4& Camera::getViewProjectionMatrix() const
⋮----
// Ensure view and projection matrices are up to date
⋮----
const Utility::Frustum& Camera::getFrustum() const
⋮----
// Ensure view-projection matrix is up to date
⋮----
void Camera::setPosition(const glm::vec3& position)
⋮----
const glm::vec3& Camera::getPosition() const
⋮----
void Camera::setRotation(const glm::quat& rotation)
⋮----
const glm::quat& Camera::getRotation() const
⋮----
void Camera::lookAt(const glm::vec3& target, const glm::vec3& up)
⋮----
// Calculate the view matrix directly
⋮----
// Extract rotation from the view matrix
⋮----
void Camera::setTarget(const glm::vec3& target)
⋮----
// We don't update the rotation here - use lookAt if that's needed
⋮----
const glm::vec3& Camera::getTarget() const
⋮----
glm::vec3 Camera::getForward() const
⋮----
// Forward is negative Z in view space
⋮----
glm::vec3 Camera::getRight() const
⋮----
// Right is positive X in view space
⋮----
glm::vec3 Camera::getUp() const
⋮----
// Up is positive Y in view space
⋮----
void Camera::move(const glm::vec3& offset)
⋮----
void Camera::moveForward(float distance)
⋮----
void Camera::moveRight(float distance)
⋮----
void Camera::moveUp(float distance)
⋮----
void Camera::rotate(const glm::quat& rotation)
⋮----
void Camera::rotateYaw(float angle)
⋮----
// Rotate around world up axis (0,1,0)
⋮----
void Camera::rotatePitch(float angle)
⋮----
// Rotate around local right axis
⋮----
void Camera::rotateRoll(float angle)
⋮----
// Rotate around local forward axis
⋮----
void Camera::setAspectRatio(float aspectRatio)
⋮----
float Camera::getAspectRatio() const
⋮----
void Camera::setNearPlane(float nearPlane)
⋮----
float Camera::getNearPlane() const
⋮----
void Camera::setFarPlane(float farPlane)
⋮----
float Camera::getFarPlane() const
⋮----
void Camera::update()
⋮----
// This base implementation just ensures matrices are up to date
⋮----
Utility::Ray Camera::screenPointToRay(const glm::vec2& screenPoint) const
⋮----
// Ensure matrices are up to date
⋮----
// Convert from screen space [0,1] to normalized device coordinates [-1,1]
⋮----
-1.0f, // Near plane
⋮----
0.0f, // Far plane
⋮----
// Inverse transform from NDC to world space
⋮----
// Perspective division
⋮----
// Direction vector
⋮----
glm::vec3 Camera::screenToWorldPoint(const glm::vec2& screenPoint, float depth) const
⋮----
// Clamp depth between 0 and 1
⋮----
glm::vec2 Camera::worldToScreenPoint(const glm::vec3& worldPoint) const
⋮----
// Transform world point to clip space
⋮----
// Perspective division to get NDC coordinates
⋮----
// Convert from NDC [-1,1] to screen coordinates [0,1]
⋮----
void Camera::updateViewMatrix() const
⋮----
// Build the view matrix from position and rotation
⋮----
void Camera::updateProjectionMatrix() const
⋮----
// This is implemented by derived classes
⋮----
void Camera::updateViewProjectionMatrix() const
⋮----
// Multiply projection and view matrices
⋮----
void Camera::updateFrustum() const
⋮----
// Extract frustum planes from the view-projection matrix
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Camera/CameraAnimator.cpp">
// -------------------------------------------------------------------------
// CameraAnimator.cpp
⋮----
CameraAnimator::CameraAnimator(std::shared_ptr<Camera> camera)
⋮----
// Nothing to clean up
⋮----
void CameraAnimator::setTargetPosition(const glm::vec3& position, float duration)
⋮----
void CameraAnimator::setTargetRotation(const glm::quat& rotation, float duration)
⋮----
void CameraAnimator::setTargetLookAt(const glm::vec3& target, float duration)
⋮----
void CameraAnimator::animateTo(const glm::vec3& position, const glm::quat& rotation, float duration)
⋮----
void CameraAnimator::animateTo(const Camera& targetCamera, float duration)
⋮----
void CameraAnimator::play()
⋮----
void CameraAnimator::pause()
⋮----
void CameraAnimator::stop()
⋮----
bool CameraAnimator::isPlaying() const
⋮----
float CameraAnimator::getProgress() const
⋮----
void CameraAnimator::update(float deltaTime)
⋮----
// Update time
⋮----
// Check if animation is complete
⋮----
// Apply final values
⋮----
// Animation complete
⋮----
// Calculate interpolation factor with easing
⋮----
// Interpolate values
⋮----
float CameraAnimator::easeInOut(float t) const
⋮----
// Smooth cubic easing: 3t^2 - 2t^3
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Camera/FPSCameraController.cpp">
// -------------------------------------------------------------------------
// FPSCameraController.cpp
⋮----
FPSCameraController::FPSCameraController(std::shared_ptr<Camera> camera)
⋮----
, m_moveSpeed(5.0f)  // 5 units per second
, m_rotationSpeed(0.005f)  // Radians per pixel
⋮----
// Extract initial yaw and pitch from camera rotation
⋮----
// Nothing to clean up
⋮----
void FPSCameraController::setCamera(std::shared_ptr<Camera> camera)
⋮----
// Extract yaw and pitch from camera rotation
⋮----
std::shared_ptr<Camera> FPSCameraController::getCamera() const
⋮----
void FPSCameraController::setMoveSpeed(float speed)
⋮----
float FPSCameraController::getMoveSpeed() const
⋮----
void FPSCameraController::setRotationSpeed(float speed)
⋮----
float FPSCameraController::getRotationSpeed() const
⋮----
void FPSCameraController::handleKeyboard(float deltaTime)
⋮----
// Get the Input system from the application
⋮----
// Check key states for movement
⋮----
void FPSCameraController::handleMouseMotion(float deltaX, float deltaY)
⋮----
// Update yaw and pitch based on mouse movement
⋮----
// Clamp pitch to avoid gimbal lock
⋮----
void FPSCameraController::update(float deltaTime)
⋮----
// Apply rotation
⋮----
// Apply movement
⋮----
movement += glm::vec3(0.0f, 1.0f, 0.0f);  // World up, not camera up
⋮----
movement -= glm::vec3(0.0f, 1.0f, 0.0f);  // World down, not camera down
⋮----
// Normalize and apply movement
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Camera/OrthographicCamera.cpp">
// -------------------------------------------------------------------------
// OrthographicCamera.cpp
⋮----
OrthographicCamera::OrthographicCamera()
⋮----
, m_size(5.0f) // Default size
⋮----
OrthographicCamera::OrthographicCamera(float size, float aspectRatio, float nearPlane, float farPlane)
⋮----
// Nothing to clean up
⋮----
void OrthographicCamera::setSize(float size)
⋮----
float OrthographicCamera::getSize() const
⋮----
void OrthographicCamera::setRect(float left, float right, float bottom, float top)
⋮----
void OrthographicCamera::updateProjectionMatrix() const
⋮----
// Use explicit boundaries
⋮----
// Calculate boundaries from size and aspect ratio
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Camera/PerspectiveCamera.cpp">
// -------------------------------------------------------------------------
// PerspectiveCamera.cpp
⋮----
PerspectiveCamera::PerspectiveCamera()
⋮----
, m_fov(glm::radians(60.0f)) // Default 60 degrees FOV
⋮----
PerspectiveCamera::PerspectiveCamera(float fov, float aspectRatio, float nearPlane, float farPlane)
⋮----
// Nothing to clean up
⋮----
void PerspectiveCamera::setFOV(float fov)
⋮----
float PerspectiveCamera::getFOV() const
⋮----
void PerspectiveCamera::updateProjectionMatrix() const
⋮----
// Create a perspective projection matrix
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/GeometryStage.cpp">
// -------------------------------------------------------------------------
// GeometryStage.cpp
⋮----
// OpenGL headers
⋮----
GeometryStage::GeometryStage()
⋮----
bool GeometryStage::initialize()
⋮----
// Set default parameters
⋮----
// Register profiling marker
//m_profilingMarker = Core::Profiler::registerMarker("GeometryStage");
⋮----
void GeometryStage::shutdown()
⋮----
void GeometryStage::execute(const RenderContext& context)
⋮----
// Start profiling
//Core::Profiler::beginMarker(m_profilingMarker);
⋮----
//Core::Profiler::endMarker(m_profilingMarker);
⋮----
// Update parameters from the parameter map
⋮----
// Bind output render target
⋮----
// Set viewport
⋮----
// Setup render state
⋮----
// Bind shader
⋮----
// Set common shader uniforms from context
⋮----
// Pass custom parameters to shader
⋮----
struct ShaderParamVisitor
⋮----
// Get all entities with mesh, transform, and material components
⋮----
// Copy to vector for sorting
⋮----
// Sort entities if needed
⋮----
// Sort transparent objects back-to-front
⋮----
// Sort back-to-front (furthest first)
⋮----
// Sort opaque objects by material to minimize state changes
⋮----
// Sort by material ID to batch similar materials
⋮----
// Render each entity
⋮----
// Unbind shader
⋮----
// Restore render state
⋮----
// End profiling
⋮----
void GeometryStage::setShader(std::shared_ptr<Shader> shader)
⋮----
std::shared_ptr<Shader> GeometryStage::getShader() const
⋮----
void GeometryStage::setRegistry(std::shared_ptr<ECS::Registry> registry)
⋮----
void GeometryStage::renderObject(const RenderContext& context, ECS::EntityID entity)
⋮----
// Get components
⋮----
// Skip if mesh or material is not valid
⋮----
// Skip based on transparency settings
⋮----
// Frustum culling - skip if object is outside view frustum
⋮----
// Get world transform
⋮----
// Set model matrix
⋮----
// Normal matrix (inverse transpose of the model matrix)
⋮----
// Bind material and its textures
⋮----
// Render mesh
⋮----
// Use instancing if available and enabled
⋮----
// Unbind material
⋮----
void GeometryStage::setupRenderState()
⋮----
// Configure depth testing
⋮----
// Configure depth writing
⋮----
// Configure culling (always enable for opaque, configurable for transparent)
⋮----
// Configure blending based on render mode
⋮----
// Get blend mode from parameters or use default alpha blending
⋮----
case 0: // Alpha blending
⋮----
case 1: // Additive
⋮----
case 2: // Multiplicative
⋮----
case 3: // Premultiplied alpha
⋮----
void GeometryStage::restoreRenderState()
⋮----
// Restore default states
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/LightManager.cpp">
// -------------------------------------------------------------------------
// LightManager.cpp
⋮----
//-------------------------------------------------------------------------
// Light implementation
⋮----
Light::Light(LightType type)
⋮----
// Normalize the direction vector
⋮----
// No special cleanup needed
⋮----
void Light::setPosition(const glm::vec3& position)
⋮----
void Light::setDirection(const glm::vec3& direction)
⋮----
void Light::setColor(const glm::vec3& color)
⋮----
void Light::setIntensity(float intensity)
⋮----
void Light::setRange(float range)
⋮----
void Light::setCastShadows(bool castShadows)
⋮----
void Light::setSpotAngle(float innerAngle, float outerAngle)
⋮----
void Light::setAreaSize(const glm::vec2& size)
⋮----
LightType Light::getType() const
⋮----
const glm::vec3& Light::getPosition() const
⋮----
const glm::vec3& Light::getDirection() const
⋮----
const glm::vec3& Light::getColor() const
⋮----
float Light::getIntensity() const
⋮----
float Light::getRange() const
⋮----
bool Light::getCastShadows() const
⋮----
void Light::setShadowBias(float bias)
⋮----
void Light::setShadowResolution(int resolution)
⋮----
// Ensure resolution is a power of two
⋮----
glm::mat4 Light::getViewMatrix() const
⋮----
// For directional lights, create a view matrix looking in the light direction
⋮----
// For point and spot lights, create a view matrix from the light position
⋮----
// For area lights, create a view matrix from the light position
⋮----
glm::mat4 Light::getProjectionMatrix() const
⋮----
// Orthographic projection for directional lights
⋮----
// For point lights, we would typically use cubemap projections
// This is a placeholder - actual implementation would handle all six faces
⋮----
// For spot lights, use a perspective projection
⋮----
// For area lights, use an orthographic projection
⋮----
LightData Light::packLightData() const
⋮----
data.shadowIndex = 0; // Will be set by LightManager
⋮----
// LightManager implementation
⋮----
LightManager::LightManager()
⋮----
bool LightManager::initialize()
⋮----
// Initialize the cluster data with default values
m_clusterData.dimensions = glm::ivec3(16, 8, 24); // Default cluster grid size
⋮----
// Allocate space for the light grid and indices
⋮----
m_clusterData.lightIndices.reserve(1024); // Reserve space for light indices
⋮----
// Create GPU buffers for light data and cluster data
// In a real implementation, these would be created using the graphics API
m_lightDataBuffer = 1; // Placeholder
m_clusterDataBuffer = 2; // Placeholder
⋮----
void LightManager::shutdown()
⋮----
// Clear all lights
⋮----
// Release shadow maps
⋮----
// Release GPU buffers
// In a real implementation, these would be deleted using the graphics API
⋮----
std::shared_ptr<Light> LightManager::createLight(LightType type)
⋮----
// Add the light to the appropriate lists
⋮----
// Mark clusters as dirty
⋮----
void LightManager::removeLight(std::shared_ptr<Light> light)
⋮----
// Remove from light shadow indices if it had a shadow
⋮----
// Remove from the appropriate type-specific list
⋮----
// Remove from visible lights if present
⋮----
// Remove from main light list
⋮----
const std::vector<std::shared_ptr<Light>>& LightManager::getLights() const
⋮----
const std::vector<std::shared_ptr<Light>>& LightManager::getVisibleLights() const
⋮----
void LightManager::setupClusters(const glm::ivec3& dimensions)
⋮----
// Resize the light grid for the new dimensions
⋮----
// Mark clusters as dirty to trigger a rebuild
⋮----
void LightManager::updateClusters(const RenderContext& context)
⋮----
// Update the cluster bounds based on the view frustum
// For simplicity, we'll use the camera frustum corners to determine bounds
⋮----
// Calculate min/max bounds from the frustum corners
⋮----
// Clear existing light assignments
⋮----
// Assign lights to clusters
⋮----
// Update the cluster buffer
⋮----
const ClusterData& LightManager::getClusterData() const
⋮----
void LightManager::prepareShadowMaps(const RenderContext& context)
⋮----
// Create shadow maps for all shadow-casting lights
⋮----
// For directional lights, calculate cascaded shadow maps
⋮----
std::shared_ptr<RenderTarget> LightManager::getShadowMap(size_t index) const
⋮----
void LightManager::setupCascadedShadowMaps(int cascadeCount, float splitLambda)
⋮----
// Resize cascade data structures
⋮----
const std::vector<glm::mat4>& LightManager::getCascadeViewProjections() const
⋮----
const std::vector<float>& LightManager::getCascadeSplits() const
⋮----
void LightManager::updateVisibleLights(const Utility::Frustum& frustum)
⋮----
// Directional lights are always visible
⋮----
// Test point lights against the frustum
⋮----
// Test spot lights against the frustum
⋮----
// Test area lights against the frustum
⋮----
// Mark clusters as dirty since visible lights changed
⋮----
void LightManager::updateGPUBuffers()
⋮----
// Prepare light data for GPU
⋮----
// Set shadow index if this light has a shadow map
⋮----
// In a real implementation, the light data would be uploaded to GPU buffers here
// For example:
// glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_lightDataBuffer);
// glBufferData(GL_SHADER_STORAGE_BUFFER, lightDataArray.size() * sizeof(LightData), lightDataArray.data(), GL_DYNAMIC_DRAW);
⋮----
// Similarly for cluster data
// glBindBuffer(GL_SHADER_STORAGE_BUFFER, m_clusterDataBuffer);
// ...
⋮----
uint32_t LightManager::getLightDataBuffer() const
⋮----
uint32_t LightManager::getClusterDataBuffer() const
⋮----
void LightManager::assignLightsToClusters()
⋮----
// Grid dimensions
⋮----
// Cluster size
⋮----
// Reserve space for light indices (worst case: all lights affect all clusters)
⋮----
// For each cluster, find lights that affect it
⋮----
// Calculate 3D indices from flat index
⋮----
// Calculate cluster bounds
⋮----
// Center of the cluster
⋮----
// Record starting index for this cluster's lights
⋮----
// Add directional lights (which affect all clusters)
⋮----
// Check point lights
⋮----
// Simplified test: distance from point to AABB
⋮----
// Check spot lights (similar to point lights but also check direction)
⋮----
// First, quick sphere test
⋮----
// Check if cluster center is within the spotlight cone
⋮----
// Check area lights (simplified)
⋮----
// Simplified as sphere test
⋮----
// Update grid entry with start index and count
⋮----
void LightManager::createShadowMapForLight(std::shared_ptr<Light> light)
⋮----
// Check if the light already has a shadow map
⋮----
return; // Shadow map already exists
⋮----
// Create a shadow map based on light type
⋮----
// In a real implementation, this would create the appropriate render target
// with depth textures for shadow mapping
⋮----
// shadowMap->initialize(resolution, resolution, TextureFormat::DEPTH_32F, cubemap);
⋮----
// Add shadow map to the list and record its index
⋮----
void LightManager::calculateCascadeSplits(const RenderContext& context)
⋮----
// Get near and far planes from the camera
⋮----
// Calculate split depths using logarithmic distribution
⋮----
// Get the main directional light
⋮----
// Get the light view matrix
⋮----
// For each cascade, calculate the view-projection matrix
⋮----
// Calculate bounding sphere for this cascade
⋮----
// In a real implementation, this would compute the bounding sphere
// for the view frustum between nearSplit and farSplit
⋮----
// Radius of the sphere is the distance from the center to the furthest corner
radius = 10.0f + i * 15.0f; // Simplified for demonstration
⋮----
// Create an orthographic projection for this cascade
⋮----
// Store the cascade view-projection matrix
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Material.cpp">
// -------------------------------------------------------------------------
// Material.cpp
⋮----
Material::Material(const std::string& name)
⋮----
bool Material::load()
⋮----
// Load any textures that have been set
⋮----
void Material::unload()
⋮----
// No need to unload textures as they are managed by ResourceManager
⋮----
bool Material::onReload()
⋮----
// Reload textures if needed
⋮----
void Material::setShader(std::shared_ptr<Shader> shader)
⋮----
std::shared_ptr<Shader> Material::getShader() const
⋮----
bool Material::hasParameter(const std::string& name) const
⋮----
// Check local parameters first
⋮----
// Check parent if available
⋮----
void Material::setFloat(const std::string& name, float value)
⋮----
void Material::setInt(const std::string& name, int value)
⋮----
void Material::setVector2(const std::string& name, const glm::vec2& value)
⋮----
void Material::setVector3(const std::string& name, const glm::vec3& value)
⋮----
void Material::setVector4(const std::string& name, const glm::vec4& value)
⋮----
void Material::setMatrix4(const std::string& name, const glm::mat4& value)
⋮----
void Material::setColor(const std::string& name, const glm::vec4& value)
⋮----
void Material::setTexture(TextureSlot slot, std::shared_ptr<Texture> texture)
⋮----
std::shared_ptr<Texture> Material::getTexture(TextureSlot slot) const
⋮----
void Material::setTextureByName(const std::string& name, std::shared_ptr<Texture> texture)
⋮----
std::shared_ptr<Texture> Material::getTextureByName(const std::string& name) const
⋮----
void Material::setBaseColor(const glm::vec3& color)
⋮----
void Material::setMetallic(float metallic)
⋮----
void Material::setRoughness(float roughness)
⋮----
void Material::setEmissive(const glm::vec3& emissive)
⋮----
glm::vec3 Material::getBaseColor() const
⋮----
float Material::getMetallic() const
⋮----
float Material::getRoughness() const
⋮----
glm::vec3 Material::getEmissive() const
⋮----
void Material::setBlendMode(BlendMode mode)
⋮----
void Material::setCullMode(CullMode mode)
⋮----
void Material::setDepthTest(bool enabled)
⋮----
void Material::setDepthWrite(bool enabled)
⋮----
BlendMode Material::getBlendMode() const
⋮----
CullMode Material::getCullMode() const
⋮----
bool Material::getDepthTest() const
⋮----
bool Material::getDepthWrite() const
⋮----
void Material::setParent(std::shared_ptr<Material> parent)
⋮----
// Prevent circular inheritance
⋮----
std::shared_ptr<Material> Material::getParent() const
⋮----
std::shared_ptr<Material> Material::clone() const
⋮----
// Copy all properties
⋮----
// Set parent to this material's parent (not to this material)
⋮----
void Material::bind()
⋮----
void Material::unbind()
⋮----
void Material::bindRenderState()
⋮----
// Note: This would typically map to platform-specific graphics API calls
// For example, in OpenGL these would be glEnable/glDisable calls
⋮----
// Set blend mode
⋮----
// Disable blending
⋮----
// Enable alpha blending
⋮----
// Enable additive blending
⋮----
// Enable multiply blending
⋮----
// Enable screen blending
⋮----
// Set cull mode
⋮----
// Disable face culling
⋮----
// Cull front faces
⋮----
// Cull back faces
⋮----
// Set depth test
⋮----
// Enable depth testing
⋮----
// Disable depth testing
⋮----
// Set depth write
⋮----
// Enable depth writing
⋮----
// Disable depth writing
⋮----
void Material::bindParameters()
⋮----
// Process all parameters in this material
⋮----
// Process parent parameters not overridden by this material
⋮----
// Skip if this material already has this parameter
⋮----
void Material::bindTextures()
⋮----
// Process standard texture slots
⋮----
// Map texture slot to uniform name
⋮----
// Process custom textures
⋮----
// Process parent textures not overridden by this material
⋮----
// Process standard texture slots from parent
⋮----
// Skip if this material already has this texture
⋮----
bool Material::findParameter(const std::string& name, ParameterValue& outValue) const
⋮----
bool Material::findTexture(TextureSlot slot, std::shared_ptr<Texture>& outTexture) const
⋮----
// Check local textures first
⋮----
// Template specializations for getParameter
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Material.inl">
// -------------------------------------------------------------------------
// Material.inl - Template implementations for Material class
// -------------------------------------------------------------------------
#pragma once

namespace PixelCraft::Rendering
{

    template<typename T>
    void Material::setParameter(const std::string& name, const T& value)
    {
        // Use compile-time errors to limit to supported types
        static_assert(
            std::is_same_v<T, int> ||
            std::is_same_v<T, float> ||
            std::is_same_v<T, glm::vec2> ||
            std::is_same_v<T, glm::vec3> ||
            std::is_same_v<T, glm::vec4> ||
            std::is_same_v<T, glm::mat4>,
            "Unsupported parameter type"
            );

        ParameterValue param;
        param.value = value;
        m_parameters[name] = param;
    }

    template<typename T>
    T Material::getParameter(const std::string& name, const T& defaultValue) const
    {
        // Default implementation handles most common cases
        // Specialized implementations are in Material.cpp
        ParameterValue value;
        if (findParameter(name, value))
        {
            if (std::holds_alternative<T>(value.value))
            {
                return std::get<T>(value.value);
            }
        }
        return defaultValue;
    }

} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Mesh.cpp">
// -------------------------------------------------------------------------
// Mesh.cpp
⋮----
Mesh::Mesh(const std::string& name)
⋮----
bool Mesh::load()
⋮----
// The actual mesh data will be loaded through createFromData
// This method is primarily used when loading from a file
⋮----
void Mesh::unload()
⋮----
bool Mesh::onReload()
⋮----
// If this is a file-based resource, we would reload the file here
⋮----
bool Mesh::createFromData(const void* vertices, uint32_t vertexCount,
⋮----
// Create and bind the VAO
⋮----
// Create and bind the VBO, upload vertex data
⋮----
// Calculate total vertex data size
⋮----
// If we have indices, create and bind the EBO, upload index data
⋮----
// Set up vertex attributes
⋮----
// Unbind VAO to prevent accidental modifications
⋮----
// Calculate bounds if we have position data
⋮----
void Mesh::bind()
⋮----
void Mesh::unbind()
⋮----
void Mesh::draw()
⋮----
// Draw indexed
⋮----
// Draw non-indexed
⋮----
void Mesh::drawInstanced(uint32_t instanceCount)
⋮----
// Draw indexed instanced
⋮----
// Draw non-indexed instanced
⋮----
void Mesh::updateVertexData(const void* data, uint32_t size, uint32_t offset)
⋮----
void Mesh::updateIndexData(const uint32_t* indices, uint32_t count, uint32_t offset)
⋮----
void Mesh::calculateNormals()
⋮----
// Find position and normal attribute locations
⋮----
// Get the vertex data
⋮----
// Calculate normals
⋮----
// Reset normals to zero
⋮----
// Calculate face normals and accumulate to vertices
⋮----
// Indexed geometry
std::vector<uint32_t> indices(m_indexCount);
⋮----
glm::vec3 v1(pos1[0], pos1[1], pos1[2]);
glm::vec3 v2(pos2[0], pos2[1], pos2[2]);
glm::vec3 v3(pos3[0], pos3[1], pos3[2]);
⋮----
// Accumulate normals
⋮----
// Non-indexed geometry (assume triangles)
⋮----
// Normalize all normals
⋮----
glm::vec3 n(normal[0], normal[1], normal[2]);
⋮----
// Default normal if the calculated one is too small
⋮----
// Update the vertex buffer with the new normals
⋮----
void Mesh::calculateTangents()
⋮----
// Find relevant attribute locations
⋮----
// Check required attributes
⋮----
// Similar implementation to calculateNormals, but for tangents
// This would involve getting the vertex data, calculating tangents for each triangle,
// accumulating them per vertex, and then normalizing the results.
⋮----
// For brevity, tangent calculation is simplified here.
// A full implementation would follow the same pattern as calculateNormals
// but with the math for tangent space calculation
⋮----
void Mesh::calculateBounds()
⋮----
// Find position attribute
⋮----
// Reset bounds
glm::vec3 minBounds(std::numeric_limits<float>::max());
glm::vec3 maxBounds(std::numeric_limits<float>::lowest());
⋮----
// Iterate through vertices to find min/max bounds
⋮----
// Set the bounds
⋮----
uint32_t Mesh::getVertexCount() const
⋮----
uint32_t Mesh::getIndexCount() const
⋮----
PrimitiveType Mesh::getPrimitiveType() const
⋮----
const VertexAttributes& Mesh::getAttributes() const
⋮----
const Utility::AABB& Mesh::getBounds() const
⋮----
void Mesh::setupVertexAttributes()
⋮----
GLenum Mesh::getPrimitiveTypeGL() const
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/PaletteManager.cpp">
// -------------------------------------------------------------------------
// PaletteManager.cpp
⋮----
PaletteManager::PaletteManager()
⋮----
bool PaletteManager::initialize()
⋮----
// Create default grayscale palette
⋮----
// Create default color palette (16 colors)
⋮----
// Basic colors
glm::vec4(0.0f, 0.0f, 0.0f, 1.0f),      // Black
glm::vec4(1.0f, 1.0f, 1.0f, 1.0f),      // White
glm::vec4(1.0f, 0.0f, 0.0f, 1.0f),      // Red
glm::vec4(0.0f, 1.0f, 0.0f, 1.0f),      // Green
glm::vec4(0.0f, 0.0f, 1.0f, 1.0f),      // Blue
glm::vec4(1.0f, 1.0f, 0.0f, 1.0f),      // Yellow
glm::vec4(1.0f, 0.0f, 1.0f, 1.0f),      // Magenta
glm::vec4(0.0f, 1.0f, 1.0f, 1.0f),      // Cyan
// Additional colors
glm::vec4(0.5f, 0.5f, 0.5f, 1.0f),      // Gray
glm::vec4(0.5f, 0.0f, 0.0f, 1.0f),      // Dark red
glm::vec4(0.0f, 0.5f, 0.0f, 1.0f),      // Dark green
glm::vec4(0.0f, 0.0f, 0.5f, 1.0f),      // Dark blue
glm::vec4(0.5f, 0.5f, 0.0f, 1.0f),      // Dark yellow
glm::vec4(0.5f, 0.0f, 0.5f, 1.0f),      // Dark magenta
glm::vec4(0.0f, 0.5f, 0.5f, 1.0f),      // Dark cyan
glm::vec4(0.8f, 0.4f, 0.2f, 1.0f)       // Orange
⋮----
// Set Default as the active palette
⋮----
// Create dithering textures
⋮----
void PaletteManager::shutdown()
⋮----
bool PaletteManager::loadPalette(const std::string& name, const std::string& filepath)
⋮----
std::ifstream file(filepath, std::ios::binary);
⋮----
// Detect file format based on extension
⋮----
// JASC-PAL format
⋮----
// Read header
std::getline(file, line); // JASC-PAL
std::getline(file, line); // Version
⋮----
// Read color count
⋮----
// Read colors
⋮----
std::stringstream ss(line);
⋮----
// Hex color codes, one per line
⋮----
if (line.empty() || line[0] == '#' && line.length() == 1) continue; // Skip empty lines and comments
⋮----
// Remove any whitespace
⋮----
// Remove # if present
⋮----
// Parse hex code
⋮----
// Determine if it's RGB or RGBA based on length
⋮----
{ // RGB
⋮----
{ // RGBA
⋮----
// GIMP Palette format
⋮----
// Skip header
⋮----
// Keep reading until we find the Name: line or reach EOF
⋮----
if (line.empty() || line[0] == '#') continue; // Skip empty lines and comments
⋮----
// Skip any color name after RGB values
⋮----
// Store the palette
⋮----
// Create a texture for the palette
⋮----
// If no active palette is set, make this one active
⋮----
bool PaletteManager::createPalette(const std::string& name, const std::vector<glm::vec4>& colors)
⋮----
bool PaletteManager::savePalette(const std::string& name, const std::string& filepath)
⋮----
std::ofstream file(filepath, std::ios::binary);
⋮----
bool PaletteManager::deletePalette(const std::string& name)
⋮----
// Remove the palette
⋮----
// Remove the texture if it exists
⋮----
// If this was the active palette, clear the active palette
⋮----
// Set a new active palette if any exist
⋮----
// If this was the target palette, clear the target palette
⋮----
// Remove any time variants that use this palette
⋮----
// Remove variants that use this palette
⋮----
// If base palette has no variants left, remove it
⋮----
bool PaletteManager::hasPalette(const std::string& name) const
⋮----
const std::vector<glm::vec4>& PaletteManager::getPaletteColors(const std::string& name) const
⋮----
std::shared_ptr<Texture> PaletteManager::getPaletteTexture(const std::string& name)
⋮----
// Create the texture if it doesn't exist
⋮----
std::vector<std::string> PaletteManager::getPaletteNames() const
⋮----
void PaletteManager::setActivePalette(const std::string& name)
⋮----
const std::string& PaletteManager::getActivePalette() const
⋮----
void PaletteManager::enablePaletteConstraint(bool enabled)
⋮----
bool PaletteManager::isPaletteConstraintEnabled() const
⋮----
void PaletteManager::setConstraintStrength(float strength)
⋮----
float PaletteManager::getConstraintStrength() const
⋮----
void PaletteManager::setDitheringPattern(DitheringPattern pattern)
⋮----
void PaletteManager::setDitheringStrength(float strength)
⋮----
DitheringPattern PaletteManager::getDitheringPattern() const
⋮----
float PaletteManager::getDitheringStrength() const
⋮----
bool PaletteManager::generatePalette(const std::string& name, int colorCount, bool includeTransparency)
⋮----
// Generate colors with evenly distributed hues and varying saturation/value
⋮----
float saturation = 0.7f + 0.3f * ((i % 3) / 2.0f); // Alternate between 0.7 and 1.0
float value = 0.7f + 0.3f * ((i % 2)); // Alternate between 0.7 and 1.0
⋮----
// Convert HSV to RGB
⋮----
// Add black and white if there's room
⋮----
colors[0] = glm::vec4(0.0f, 0.0f, 0.0f, 1.0f); // Black
colors[1] = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f); // White
⋮----
// Add transparent color if requested
⋮----
// Create the palette
⋮----
bool PaletteManager::extractPaletteFromImage(const std::string& name, const std::string& imagePath, int maxColors)
⋮----
// Load the image data
// Note: In a real implementation, this would use the engine's resource system
// For demonstration purposes, we'll use a placeholder implementation
⋮----
// Placeholder for image loading (would use the engine's Resource system)
⋮----
/*if (!imageResource->load(imagePath))
        {
            Log::error("Failed to load image for palette extraction: " + imagePath);
            return false;
        }*/
⋮----
// Placeholder implementation for color quantization
// In a real implementation, this would use median cut, k-means clustering,
// or another color quantization algorithm
⋮----
// Simulated colors for demonstration (please replace with actual implementation)
⋮----
glm::vec4(0.0f, 0.0f, 0.0f, 1.0f), // Black
glm::vec4(1.0f, 1.0f, 1.0f, 1.0f), // White
glm::vec4(0.8f, 0.1f, 0.1f, 1.0f), // Red
glm::vec4(0.1f, 0.7f, 0.2f, 1.0f), // Green
glm::vec4(0.2f, 0.3f, 0.8f, 1.0f), // Blue
glm::vec4(0.9f, 0.8f, 0.2f, 1.0f), // Yellow
glm::vec4(0.8f, 0.3f, 0.7f, 1.0f), // Magenta
glm::vec4(0.3f, 0.8f, 0.9f, 1.0f)  // Cyan
⋮----
// Limit to maxColors
⋮----
bool PaletteManager::addColorToPalette(const std::string& name, const glm::vec4& color)
⋮----
// Update the texture
⋮----
bool PaletteManager::removeColorFromPalette(const std::string& name, int index)
⋮----
bool PaletteManager::updateColorInPalette(const std::string& name, int index, const glm::vec4& color)
⋮----
glm::vec4 PaletteManager::findNearestColor(const glm::vec4& color, const std::string& paletteName) const
⋮----
// Use the active palette if none specified
⋮----
return color; // Return original color if no palette or index found
⋮----
int PaletteManager::findNearestColorIndex(const glm::vec4& color, const std::string& paletteName) const
⋮----
// Find the nearest color by distance
⋮----
void PaletteManager::addTimeOfDayVariant(const std::string& basePalette, float timeOfDay, const std::string& variantPalette)
⋮----
// Clamp time of day to 0-24 range
⋮----
// Add the variant
⋮----
void PaletteManager::updateTimeOfDay(float timeOfDay)
⋮----
// If no active palette or no variants, nothing to do
⋮----
// Check if the active palette has time variants
⋮----
// Find the surrounding time points
⋮----
// If we have an exact match for this time
⋮----
// Check if we're not already using this palette
⋮----
// Just switch to that palette directly
⋮----
// Find the two closest time points
⋮----
// Handle wrap-around case
⋮----
// Find the maximum time
⋮----
// Find the minimum time
⋮----
// Calculate blend factor
⋮----
// Handle wrap-around case (prev = 22, next = 2, time = 23)
⋮----
// We're in the wraparound region (e.g. time = 1)
⋮----
// Normal case
⋮----
// Create blended palette
⋮----
// Create a blend of the two palettes
⋮----
// Only blend if the palettes have the same number of colors
⋮----
// Create or update the blended palette
⋮----
// Set as active palette without disrupting time-of-day system
⋮----
// Restore original palette in time variants to prevent recursion
⋮----
// If palettes have different sizes, just use the closer palette
⋮----
void PaletteManager::blendToPalette(const std::string& targetPalette, float duration)
⋮----
// If no active palette, just set the target as active immediately
⋮----
// Don't blend to the same palette
⋮----
void PaletteManager::updatePaletteBlend(float deltaTime)
⋮----
// If no blend in progress, return
⋮----
// Update blend progress
⋮----
// If blend complete, set target as active
⋮----
// Create a blend palette
⋮----
// If the palettes have different sizes, use the smaller one's size
⋮----
// Set as active palette (without resetting the blend)
⋮----
// Restore blend state
⋮----
float PaletteManager::getPaletteBlendProgress() const
⋮----
void PaletteManager::bindPaletteTextures(std::shared_ptr<Shader> shader)
⋮----
// Make sure the active palette has a texture
⋮----
// Bind the active palette texture
⋮----
// Bind the dithering texture if enabled
⋮----
// Set other palette-related uniforms
⋮----
void PaletteManager::updatePaletteTexture(const std::string& name)
⋮----
// Create a 1D texture from the palette colors
⋮----
texture->initialize(static_cast<int>(colors.size()), 1, TextureFormat::RGBA8); // RGBA format
⋮----
// Create color data for the texture
⋮----
// Update the texture with the color data
⋮----
// Store the texture
⋮----
void PaletteManager::createDitheringTextures()
⋮----
// Generate the appropriate dithering texture based on the current pattern
⋮----
// Generate 8x8 Bayer matrix
⋮----
// Construct 8x8 matrix from 4x4 matrix
⋮----
// Use 4x4 pattern values and shift based on quadrant
⋮----
// Set value based on the 8x8 matrix pattern
⋮----
// In a real implementation, you would load a blue noise texture
// For now, create a placeholder with random values
⋮----
// In a real implementation, you would generate white noise
⋮----
// Ordered dithering pattern (similar to Bayer but with different values)
⋮----
// For error diffusion, we need special handling in the shader
// Just create a simple pattern for now
⋮----
// No dithering, clear the texture
⋮----
void PaletteManager::createDitheringTexture(const std::vector<float>& pattern, int width, int height)
⋮----
// Convert the float pattern to a texture
⋮----
texture->initialize(width, height, TextureFormat::R8); // R format
⋮----
// Convert float values [0,1] to byte values [0,255]
⋮----
// Update the texture with the pattern data
⋮----
float PaletteManager::colorDistance(const glm::vec4& a, const glm::vec4& b) const
⋮----
// Perceptual color distance using weighted Euclidean distance
// These weights approximate human visual perception
⋮----
// Handle alpha differently - only consider it significant if the difference is large
⋮----
// Handle fully transparent colors as a special case
⋮----
return 0.0f; // Both fully transparent, consider them identical
⋮----
// If one is transparent and the other isn't, they're very different
⋮----
return 2.0f; // Maximum distance for colors with different transparency
⋮----
// Color component differences
⋮----
// Weighted Euclidean distance
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderContext.cpp">
// -------------------------------------------------------------------------
// RenderContext.cpp
⋮----
RenderContext::RenderContext()
⋮----
// Default initialization
⋮----
// No specific cleanup needed
⋮----
void RenderContext::setViewMatrix(const glm::mat4& view)
⋮----
void RenderContext::setProjectionMatrix(const glm::mat4& projection)
⋮----
void RenderContext::updateMatrices()
⋮----
const glm::mat4& RenderContext::getViewMatrix() const
⋮----
const glm::mat4& RenderContext::getProjectionMatrix() const
⋮----
const glm::mat4& RenderContext::getViewProjectionMatrix() const
⋮----
// Note: The caller should ensure updateMatrices() is called when needed
⋮----
void RenderContext::setCameraPosition(const glm::vec3& position)
⋮----
void RenderContext::setCameraDirection(const glm::vec3& direction)
⋮----
const glm::vec3& RenderContext::getCameraPosition() const
⋮----
const glm::vec3& RenderContext::getCameraDirection() const
⋮----
void RenderContext::setViewport(int x, int y, int width, int height)
⋮----
void RenderContext::setRenderSize(int width, int height)
⋮----
const glm::ivec4& RenderContext::getViewport() const
⋮----
const glm::ivec2& RenderContext::getRenderSize() const
⋮----
const Utility::Frustum& RenderContext::getFrustum() const
⋮----
// Note: The caller should ensure updateFrustum() is called when needed
⋮----
void RenderContext::updateFrustum()
⋮----
// Make sure matrices are up to date
⋮----
// Update the frustum from the view-projection matrix
⋮----
void RenderContext::bindShaderUniforms(std::shared_ptr<Shader> shader)
⋮----
// Bind common matrices
⋮----
// Bind camera information
⋮----
// Bind viewport and render size information
⋮----
glm::vec3 RenderContext::worldToViewSpace(const glm::vec3& worldPos) const
⋮----
glm::vec4 RenderContext::worldToClipSpace(const glm::vec3& worldPos) const
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderPipeline.cpp">
// -------------------------------------------------------------------------
// RenderPipeline.cpp
⋮----
RenderPipeline::RenderPipeline(const std::string& name)
⋮----
bool RenderPipeline::initialize()
⋮----
// Initialize all stages
⋮----
// Setup connections between stages
⋮----
// Validate the pipeline configuration
⋮----
void RenderPipeline::shutdown()
⋮----
// Shutdown in reverse order
⋮----
// Clear all intermediate targets
⋮----
void RenderPipeline::render(const RenderContext& context)
⋮----
// Execute each stage in order
⋮----
void RenderPipeline::addStage(std::shared_ptr<RenderStage> stage)
⋮----
// Check for duplicate stage names
⋮----
// If already initialized, initialize the new stage and update connections
⋮----
void RenderPipeline::removeStage(const std::string& stageName)
⋮----
// If initialized, shut down the stage before removing
⋮----
// Update connections if initialized
⋮----
void RenderPipeline::clearStages()
⋮----
// If initialized, shut down all stages before clearing
⋮----
std::shared_ptr<RenderStage> RenderPipeline::getStageByName(const std::string& stageName)
⋮----
const std::vector<std::shared_ptr<RenderStage>>& RenderPipeline::getStages() const
⋮----
void RenderPipeline::setOutput(std::shared_ptr<RenderTarget> target)
⋮----
// Update the final stage's output if we have stages
⋮----
std::shared_ptr<RenderTarget> RenderPipeline::getOutput() const
⋮----
std::shared_ptr<RenderTarget> RenderPipeline::createIntermediateTarget(
⋮----
// Check if a target with this name already exists
⋮----
// Create a new render target
⋮----
std::shared_ptr<RenderTarget> RenderPipeline::getIntermediateTarget(const std::string& name)
⋮----
bool RenderPipeline::validate()
⋮----
// Check if output is set
⋮----
// Check if we have any stages
⋮----
// Check if all stages have outputs set
⋮----
// Validate stage dependencies
⋮----
void RenderPipeline::saveToFile(const std::string& filepath)
⋮----
// Create root node
⋮----
// Save basic pipeline info
⋮----
// Save stages
⋮----
// Let the stage serialize its own parameters
⋮----
// Save intermediate targets
⋮----
// Save stage connections
⋮----
// Save inputs
⋮----
// Save output
⋮----
// Write to file
⋮----
bool RenderPipeline::loadFromFile(const std::string& filepath)
⋮----
// Clear existing pipeline
⋮----
// Read from file
⋮----
// Load basic pipeline info
⋮----
// Load intermediate targets
⋮----
// Load stages (this requires a factory system to create the right stage types)
// This is simplified for the example
⋮----
// Create stage based on type
⋮----
// In a real implementation, we'd use a factory to create the right stage type
// For now, we'll assume a hypothetical StageFactory
⋮----
// Deserialize parameters
⋮----
// Setup connections
⋮----
// Set inputs
⋮----
// Set output
⋮----
// Initialize the pipeline
⋮----
void RenderPipeline::debugDrawPipeline(const glm::vec2& position, float scale)
⋮----
// Draw nodes for render targets
⋮----
// Draw output target first
⋮----
// Draw intermediate targets
⋮----
// Draw nodes for render stages
⋮----
// Draw connections
⋮----
// Draw input connections
⋮----
// Draw output connection
⋮----
const std::string& RenderPipeline::getName() const
⋮----
void RenderPipeline::setupStageConnections()
⋮----
// If no stages, nothing to do
⋮----
// For simple linear pipeline, connect stages in sequence
⋮----
// Create an intermediate target if needed
⋮----
// Create a new target matching the output dimensions
⋮----
// Default to some reasonable size
⋮----
// Set output of current stage
⋮----
// Set input of next stage
⋮----
// Set output of last stage to pipeline output
⋮----
void RenderPipeline::resizeIntermediateTargets(int width, int height)
⋮----
bool RenderPipeline::validateStageDependencies()
⋮----
// Check for output target existence
⋮----
// Check for cyclic dependencies - simplified version
// In a real implementation, we'd do a proper graph traversal
⋮----
// For now, just check that all inputs exist before they're used
⋮----
// Add all intermediate targets
⋮----
// Add output target
⋮----
// Check each stage
⋮----
// Check inputs
⋮----
// Add its output to available targets
⋮----
// ForwardRenderPipeline implementation
ForwardRenderPipeline::ForwardRenderPipeline()
⋮----
bool ForwardRenderPipeline::initialize()
⋮----
// Create default stages before initializing
⋮----
void ForwardRenderPipeline::createDefaultStages()
⋮----
// Clear any existing stages
⋮----
// Create the standard stages for forward rendering
⋮----
// 1. Shadow Map Stage
⋮----
// 2. Depth Prepass Stage
⋮----
// 3. Skybox Stage
⋮----
// 4. Opaque Geometry Stage
⋮----
// 5. Transparent Geometry Stage
⋮----
// 6. Post-Processing Stage
⋮----
// 7. UI Stage
⋮----
// 8. Debug Stage
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderStage.cpp">
// -------------------------------------------------------------------------
// RenderStage.cpp
⋮----
// OpenGL headers
⋮----
RenderStage::RenderStage(const std::string& name)
⋮----
void RenderStage::setInput(std::shared_ptr<RenderTarget> input, int index)
⋮----
// Resize inputs vector if necessary
⋮----
void RenderStage::setOutput(std::shared_ptr<RenderTarget> output)
⋮----
std::shared_ptr<RenderTarget> RenderStage::getInput(int index) const
⋮----
std::shared_ptr<RenderTarget> RenderStage::getOutput() const
⋮----
bool RenderStage::hasParameter(const std::string& name) const
⋮----
void RenderStage::setEnabled(bool enabled)
⋮----
bool RenderStage::isEnabled() const
⋮----
const std::string& RenderStage::getName() const
⋮----
void RenderStage::bindInput(int index)
⋮----
// Bind default framebuffer
⋮----
void RenderStage::bindOutput()
⋮----
void RenderStage::clearOutput(bool clearColor, bool clearDepth, bool clearStencil)
⋮----
// Clear default framebuffer
⋮----
void RenderStage::setViewport(int x, int y, int width, int height)
⋮----
void RenderStage::resetViewport()
⋮----
// Get viewport from context or use defaults
// In a real implementation, this would come from the RenderContext
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderStage.inl">
// -------------------------------------------------------------------------
// RenderStage.h
// -------------------------------------------------------------------------
#pragma once

namespace PixelCraft::Rendering
{

    template<typename T>
    void RenderStage::setParameter(const std::string& name, const T& value)
    {
        ParameterValue param;
        param.value = value;
        m_parameters[name] = param;
    }

    template<typename T>
    T RenderStage::getParameter(const std::string& name, const T& defaultValue) const
    {
        auto it = m_parameters.find(name);
        if (it == m_parameters.end())
        {
            return defaultValue;
        }

        try
        {
            return std::get<T>(it->second.value);
        }
        catch (const std::bad_variant_access&)
        {
            Core::Logger::warn("RenderStage: Parameter type mismatch for '" + name + "' in stage '" + m_name + "'");
            return defaultValue;
        }
    }

} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderSystem.cpp">
// -------------------------------------------------------------------------
// RenderSystem.cpp
⋮----
RenderSystem::RenderSystem()
⋮----
// Constructor implementation
⋮----
bool RenderSystem::initialize()
⋮----
// Initialize subsystems
⋮----
// Initialize debug renderer
⋮----
// Set default viewport to match window size
⋮----
// Initialize render context
⋮----
// Clear render queues
⋮----
// Set up default rendering pipeline
⋮----
void RenderSystem::update(float deltaTime)
⋮----
// Update light manager
⋮----
// Update debug renderer
⋮----
// Update active render pipeline
⋮----
// Clear render statistics for the new frame
⋮----
void RenderSystem::render()
⋮----
// Set viewport
// In a real implementation, this would call the appropriate graphics API
// to set the actual viewport dimensions
⋮----
// Update frustum for culling
⋮----
// Perform frustum culling
⋮----
// Sort render queues for optimal rendering
⋮----
// Get active pipeline
⋮----
// Configure pipeline with current render context
⋮----
// Render opaque objects first
⋮----
// Render transparent objects (back to front)
⋮----
// Render UI elements
⋮----
// Render debug visualizations
⋮----
// Update render statistics
⋮----
void RenderSystem::shutdown()
⋮----
// Clear pipelines
⋮----
// Shutdown subsystems in reverse order of initialization
⋮----
std::vector<std::string> RenderSystem::getDependencies() const
⋮----
// Return dependencies
⋮----
void RenderSystem::createRenderPipeline(const std::string& name, std::shared_ptr<RenderPipeline> pipeline)
⋮----
std::shared_ptr<RenderPipeline> RenderSystem::getRenderPipeline(const std::string& name)
⋮----
void RenderSystem::setActivePipeline(const std::string& name)
⋮----
const std::string& RenderSystem::getActivePipeline() const
⋮----
void RenderSystem::submitRenderable(const RenderableObject& renderable)
⋮----
// Skip incomplete renderables
⋮----
// Determine which queue to use based on the object's layer
⋮----
void RenderSystem::clearRenderQueue()
⋮----
void RenderSystem::setMainCamera(const Camera& camera)
⋮----
// Update render context with camera information
⋮----
void RenderSystem::setViewport(int x, int y, int width, int height)
⋮----
// Update render context with new viewport dimensions
⋮----
std::shared_ptr<Shader> RenderSystem::createShader(const std::string& name)
⋮----
// Get the resource manager
⋮----
// Create or get the shader resource
⋮----
std::shared_ptr<Texture> RenderSystem::createTexture(const std::string& name)
⋮----
// Create or get the texture resource
⋮----
std::shared_ptr<Material> RenderSystem::createMaterial(const std::string& name)
⋮----
// Create or get the material resource
⋮----
std::shared_ptr<Mesh> RenderSystem::createMesh(const std::string& name)
⋮----
// Create or get the mesh resource
⋮----
LightManager& RenderSystem::getLightManager()
⋮----
PaletteManager& RenderSystem::getPaletteManager()
⋮----
void RenderSystem::drawLine(const glm::vec3& start, const glm::vec3& end, const glm::vec3& color)
⋮----
void RenderSystem::drawBox(const Utility::AABB& box, const glm::vec3& color)
⋮----
// Get the min and max points of the AABB
⋮----
// Draw the 12 edges of the box
// Bottom face
⋮----
// Top face
⋮----
// Connecting edges
⋮----
void RenderSystem::drawSphere(const glm::vec3& center, float radius, const glm::vec3& color)
⋮----
// Draw a sphere using lines
// We'll approximate a sphere by drawing three circles in the XY, XZ, and YZ planes
⋮----
// XY plane circle
⋮----
// XZ plane circle
⋮----
// YZ plane circle
⋮----
void RenderSystem::takeScreenshot(const std::string& filepath)
⋮----
// In a real implementation, this would:
// 1. Read the framebuffer pixels
// 2. Create an image from the pixel data
// 3. Save the image to the specified filepath
⋮----
// Placeholder implementation
// In a real engine, this would use the graphics API to read pixels and save them
⋮----
// Example pseudo-code:
// unsigned char* pixels = new unsigned char[m_viewportWidth * m_viewportHeight * 4];
// glReadPixels(0, 0, m_viewportWidth, m_viewportHeight, GL_RGBA, GL_UNSIGNED_BYTE, pixels);
// Utility::saveImage(filepath, pixels, m_viewportWidth, m_viewportHeight, 4);
// delete[] pixels;
⋮----
void RenderSystem::renderToTexture(std::shared_ptr<Texture> texture)
⋮----
// 1. Create a framebuffer object
// 2. Attach the texture as a color attachment
// 3. Set the framebuffer as the render target
// 4. Render the scene
// 5. Reset to the default framebuffer
⋮----
// In a real engine, this would use framebuffer objects to render the scene to a texture
⋮----
// GLuint fbo;
// glGenFramebuffers(1, &fbo);
// glBindFramebuffer(GL_FRAMEBUFFER, fbo);
// glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, texture->getTextureID(), 0);
// glViewport(0, 0, texture->getWidth(), texture->getHeight());
// render();
// glBindFramebuffer(GL_FRAMEBUFFER, 0);
// glViewport(m_viewportX, m_viewportY, m_viewportWidth, m_viewportHeight);
// glDeleteFramebuffers(1, &fbo);
⋮----
int RenderSystem::getDrawCallCount() const
⋮----
int RenderSystem::getTriangleCount() const
⋮----
int RenderSystem::getVisibleObjectCount() const
⋮----
void RenderSystem::sortRenderQueues()
⋮----
// Sort opaque objects front to back (for early z-culling)
⋮----
// Get the distance from the camera to the object centers
⋮----
// Sort front to back (smaller distance first)
⋮----
// Sort transparent objects back to front (for proper blending)
⋮----
// Sort back to front (larger distance first)
⋮----
// Sort UI objects by layer
⋮----
void RenderSystem::submitQueueToRenderer(const std::vector<RenderableObject>& queue)
⋮----
// In a real implementation, this would iterate through the queue
// and render each object using its material and mesh
⋮----
// Get the active pipeline
⋮----
// Track the current material to minimize state changes
⋮----
// Render all objects in the queue
⋮----
// Skip objects without mesh or material
⋮----
// Bind material if different from current
⋮----
// Set object-specific parameters
⋮----
// Set shadow parameters if applicable
⋮----
// Bind and draw the mesh
⋮----
// Update statistics
⋮----
// Unbind the last material
⋮----
void RenderSystem::cullObjects()
⋮----
// Get the frustum from the render context
⋮----
// Temporary storage for culled objects
⋮----
// UI objects are not culled as they are in screen space
⋮----
// Cull opaque objects
⋮----
// Cull transparent objects
⋮----
// Update queues with culled objects
⋮----
// Update visible object count
⋮----
void RenderSystem::updateRenderStats()
⋮----
// In a real implementation, this would update engine profiling metrics
// or debug information for monitoring performance
⋮----
// Example: Update FPS counter, memory usage, etc.
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/RenderTarget.cpp">
// -------------------------------------------------------------------------
// RenderTarget.cpp
⋮----
// OpenGL headers
⋮----
RenderTarget::RenderTarget(int width, int height, bool multisampled)
⋮----
, m_multisampleCount(4) // Default multisample count
⋮----
bool RenderTarget::initialize()
⋮----
// Generate framebuffer
⋮----
// If multisampled, also create resolve framebuffer
⋮----
// Initialize empty vectors for color attachments
⋮----
void RenderTarget::shutdown()
⋮----
// Delete framebuffers
⋮----
// Clear texture references
⋮----
bool RenderTarget::isInitialized() const
⋮----
bool RenderTarget::addColorAttachment(TextureFormat format, int index)
⋮----
// Create texture attachment
⋮----
// Create multisampled texture if needed
⋮----
// Create multisampled texture
⋮----
// Attach to framebuffer
⋮----
// Also create resolve texture
⋮----
// Bind resolve framebuffer and attach texture
⋮----
// Rebind main framebuffer
⋮----
// Create normal texture
⋮----
// Setup draw buffers (necessary for MRT)
⋮----
bool RenderTarget::setDepthAttachment(TextureFormat format)
⋮----
// Create depth texture
⋮----
// Create multisampled depth texture
⋮----
// Bind resolve framebuffer and attach normal depth texture
⋮----
// Switch back to main framebuffer
⋮----
// Create normal depth texture
⋮----
bool RenderTarget::setStencilAttachment()
⋮----
// Create stencil texture
⋮----
// Create multisampled stencil texture
⋮----
// Bind resolve framebuffer and attach normal stencil texture
⋮----
// Create normal stencil texture
⋮----
bool RenderTarget::setDepthStencilAttachment()
⋮----
// Create combined depth-stencil texture
⋮----
// Create multisampled depth-stencil texture
⋮----
// Bind resolve framebuffer and attach normal depth-stencil texture
⋮----
// Create normal depth-stencil texture
⋮----
bool RenderTarget::validate()
⋮----
void RenderTarget::bind()
⋮----
void RenderTarget::unbind()
⋮----
// If multisampled, resolve to resolve framebuffer
⋮----
// Bind default framebuffer
⋮----
void RenderTarget::clear(bool clearColor, bool clearDepth, bool clearStencil)
⋮----
void RenderTarget::clearColor(int index, const glm::vec4& color)
⋮----
// Store current clear color
⋮----
// Set new clear color
⋮----
// Restore original clear color
⋮----
std::shared_ptr<Texture> RenderTarget::getColorTexture(int index)
⋮----
// For multisampled textures, return the resolved texture
⋮----
std::shared_ptr<Texture> RenderTarget::getDepthTexture()
⋮----
std::shared_ptr<Texture> RenderTarget::getStencilTexture()
⋮----
std::shared_ptr<Texture> RenderTarget::getDepthStencilTexture()
⋮----
void RenderTarget::blit(std::shared_ptr<RenderTarget> target,
⋮----
// Use resolve framebuffer as source if multisampled
⋮----
// Blit from source to destination
⋮----
// Unbind framebuffers
⋮----
void RenderTarget::resize(int width, int height)
⋮----
// If dimensions haven't changed, do nothing
⋮----
// Store texture formats and recreate
⋮----
// Save existing texture formats
⋮----
// Update dimensions
⋮----
// Recreate framebuffer with new size
⋮----
// Recreate attachments
⋮----
void RenderTarget::readPixels(int x, int y, int width, int height, void* data, TextureFormat format)
⋮----
// Ensure x, y, width, height are valid
⋮----
// Determine the GL format and type based on the TextureFormat
⋮----
// Bind the appropriate framebuffer
⋮----
// Set read buffer to first color attachment
⋮----
// Perform pixel read
⋮----
// Unbind framebuffer
⋮----
uint32_t RenderTarget::getFramebufferID() const
⋮----
int RenderTarget::getWidth() const
⋮----
int RenderTarget::getHeight() const
⋮----
bool RenderTarget::isMultisampled() const
⋮----
int RenderTarget::getMultisampleCount() const
⋮----
void RenderTarget::resolveMultisampledTextures()
⋮----
// For each color attachment, blit from multisampled to resolve
⋮----
// Resolve depth if present
⋮----
// Resolve stencil if present (stencil can't be blitted separately, only with depth)
⋮----
// Reset framebuffer bindings
⋮----
bool RenderTarget::checkStatus()
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Shader.cpp">
// -------------------------------------------------------------------------
// Shader.cpp
⋮----
Shader::Shader(const std::string& name)
⋮----
bool Shader::load()
⋮----
// Load shader source files
⋮----
// Compile the shader program
⋮----
void Shader::unload()
⋮----
bool Shader::onReload()
⋮----
// Save the old program ID in case we need to roll back
⋮----
// Clear uniform locations as they will be invalidated
⋮----
// Reload source files
⋮----
// If loading failed, restore the old program and return false
⋮----
// Cleanup the new failed program if it was created
⋮----
// Restore the old program
⋮----
// Delete the old program now that we've successfully recompiled
⋮----
bool Shader::compile()
⋮----
// Create a new program
⋮----
// Compile each shader stage
⋮----
// Link the program if all shaders compiled successfully
⋮----
// Detach and delete individual shaders
⋮----
// If compilation or linking failed, delete the program and return false
⋮----
// Validate the program
⋮----
// Update the program ID and extract attributes
⋮----
void Shader::bind()
⋮----
void Shader::unbind()
⋮----
bool Shader::isValid() const
⋮----
void Shader::setSourceFile(ShaderType type, const std::string& filepath)
⋮----
// If already loaded, we'll need to reload the shader
⋮----
// We don't recompile immediately - it will happen on next use or explicit reload
⋮----
void Shader::setSource(ShaderType type, const std::string& source)
⋮----
// Clear the file path since we're using direct source code
⋮----
// If already loaded, we'll need to mark for recompilation
⋮----
const std::vector<ShaderAttribute>& Shader::getAttributes() const
⋮----
void Shader::dispatchCompute(uint32_t numGroupsX, uint32_t numGroupsY, uint32_t numGroupsZ)
⋮----
void Shader::setFloat(const std::string& name, float value)
⋮----
void Shader::setInt(const std::string& name, int value)
⋮----
void Shader::setVec2(const std::string& name, const glm::vec2& value)
⋮----
void Shader::setVec3(const std::string& name, const glm::vec3& value)
⋮----
void Shader::setVec4(const std::string& name, const glm::vec4& value)
⋮----
void Shader::setMat3(const std::string& name, const glm::mat3& value)
⋮----
void Shader::setMat4(const std::string& name, const glm::mat4& value)
⋮----
GLenum Shader::getGLShaderType(ShaderType type) const
⋮----
GLint Shader::getUniformLocation(const std::string& name)
⋮----
// Check if we've already cached the location
⋮----
// Look up the location and cache it
⋮----
bool Shader::compileShader(ShaderType type, GLuint& shaderID)
⋮----
// Not an error, this shader stage is just not present
⋮----
// Create the shader object
⋮----
// Set the source and compile
⋮----
// Check for errors
⋮----
void Shader::extractAttributes()
⋮----
// Get the number of active attributes
⋮----
// Get the maximum name length
⋮----
// Allocate a buffer for the name
std::vector<char> nameBuffer(maxNameLength);
⋮----
// Loop through all active attributes
⋮----
std::string Shader::loadShaderSource(const std::string& filepath)
⋮----
void Shader::logShaderError(GLuint shader)
⋮----
std::vector<char> log(logLength);
⋮----
void Shader::logProgramError(GLuint program)
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/ShaderManager.cpp">
// -------------------------------------------------------------------------
// ShaderManager.cpp
⋮----
ShaderManager::ShaderManager()
⋮----
bool ShaderManager::initialize()
⋮----
void ShaderManager::update(float deltaTime)
⋮----
// Check for hot-reloading if enabled
⋮----
void ShaderManager::render()
⋮----
// Nothing to render for shader manager
⋮----
void ShaderManager::shutdown()
⋮----
// Clear all cached shaders
⋮----
std::vector<std::string> ShaderManager::getDependencies() const
⋮----
// ShaderManager only depends on core systems
⋮----
std::shared_ptr<Shader> ShaderManager::createShader(const std::string& name)
⋮----
// Check if shader already exists
⋮----
// Create a new shader
⋮----
std::shared_ptr<Shader> ShaderManager::getShader(const std::string& name)
⋮----
std::shared_ptr<Shader> ShaderManager::createStandardShader(
⋮----
std::shared_ptr<Shader> ShaderManager::createComputeShader(
⋮----
void ShaderManager::reloadAllShaders()
⋮----
void ShaderManager::checkForModifiedShaders()
⋮----
// Check each shader file for modifications
⋮----
// If we haven't seen this file before, store its timestamp
⋮----
// Check if file has been modified since we last loaded it
⋮----
// Reload the shader if any of its source files were modified
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Rendering/Texture.cpp">
// -------------------------------------------------------------------------
// Texture.cpp
⋮----
Texture::Texture(const std::string& name)
⋮----
, m_filterMode(TextureFilterMode::Nearest) // Default to nearest for pixel art
⋮----
, m_pixelGridAligned(true)  // Default to pixel grid alignment for pixel art
⋮----
bool Texture::initialize()
⋮----
// Generate texture ID
⋮----
// Set default values
⋮----
bool Texture::initialize(int width, int height, TextureFormat format, int multisampleCount)
⋮----
// Generate texture
⋮----
// Determine OpenGL format
⋮----
// Allocate storage
⋮----
// Set texture parameters
⋮----
// Allocate pixel data for CPU-side access
⋮----
bool Texture::initialize(int width, int height, TextureFormat format)
⋮----
bool Texture::initialize(int width, int height, TextureFormat format, const void* data)
⋮----
// Upload data
⋮----
// Keep a copy of the pixel data for CPU-side access
⋮----
void Texture::setData(const void* data)
⋮----
bool Texture::load()
⋮----
void Texture::unload()
⋮----
bool Texture::onReload()
⋮----
// Store current settings
⋮----
// Unload and reload
⋮----
// Restore settings if successful
⋮----
void Texture::bind(uint32_t textureUnit)
⋮----
void Texture::unbind()
⋮----
void Texture::setPixelGridAlignment(bool enabled)
⋮----
// For pixel art, we force nearest filtering
⋮----
// Restore current filter mode
⋮----
bool Texture::isPixelGridAligned() const
⋮----
void Texture::setFilterMode(TextureFilterMode mode)
⋮----
// If mipmaps are not generated but mipmap filtering is requested, use non-mipmap version
⋮----
void Texture::setWrapMode(TextureWrapMode mode)
⋮----
TextureFilterMode Texture::getFilterMode() const
⋮----
TextureWrapMode Texture::getWrapMode() const
⋮----
bool Texture::setMultisampleCount(int samples)
⋮----
// Validate input
⋮----
// No change needed
⋮----
// Store old state
⋮----
// If we have dimensions, we need to recreate the texture
⋮----
// Multisampled textures can't have CPU-side data
⋮----
// Preserve data only when staying non-multisampled
⋮----
// Recreate the texture with new sample count
⋮----
// Allocate texture storage based on new multisample status
⋮----
// Set texture parameters (if not multisampled)
⋮----
// Restore data if we had it before
⋮----
// Create new pixel data for non-multisampled textures
⋮----
// Multisampled textures can't have mipmaps
⋮----
void Texture::generateMipmaps()
⋮----
// Update filter mode to account for mipmaps
⋮----
bool Texture::hasMipmaps() const
⋮----
bool Texture::resize(int width, int height, bool preserveData)
⋮----
// Nothing to do if dimensions are the same
⋮----
// Store old data if needed
⋮----
// Create new texture storage
⋮----
// Allocate texture storage based on multisample status
⋮----
// Restore data if needed
⋮----
// Initialize new data to zero
⋮----
// Copy old data, taking into account possibly different dimensions
⋮----
// Copy available channels
⋮----
// Upload the restored data to GPU
⋮----
{  // Can't update multisampled textures directly
⋮----
// Create new empty pixel data (not for multisampled textures)
⋮----
// Reset mipmaps
⋮----
bool Texture::setFormat(TextureFormat format, bool preserveData)
⋮----
// Update format
⋮----
// Create new texture storage with new format
⋮----
// Convert and copy old data
⋮----
// Extract color from old format
⋮----
// Store color in new format
⋮----
// Create new empty pixel data
⋮----
void Texture::setPixel(int x, int y, const glm::vec4& color)
⋮----
// Calculate pixel index
⋮----
// Update pixel data
⋮----
// Update the texture on GPU with this single pixel
⋮----
glm::vec4 Texture::getPixel(int x, int y)
⋮----
// Read pixel data
⋮----
void Texture::update(const void* data, int x, int y, int width, int height)
⋮----
// Use full dimensions if not specified
⋮----
// Validate coordinates
⋮----
// Update the texture data
⋮----
// Update local copy if we have one
⋮----
// Full texture update
⋮----
// Partial update - copy region by region
⋮----
// Regenerate mipmaps if necessary
⋮----
void Texture::applyPaletteMapping(std::shared_ptr<PaletteManager> paletteManager)
⋮----
// Process each pixel
⋮----
uint32_t Texture::getID() const
⋮----
int Texture::getWidth() const
⋮----
int Texture::getHeight() const
⋮----
TextureFormat Texture::getFormat() const
⋮----
bool Texture::loadFromFile(const std::string& filepath)
⋮----
// Use stb_image to load the file
⋮----
// Determine format based on channels
⋮----
// Create texture from loaded data
⋮----
// Free the loaded data
⋮----
void Texture::setTextureParameters()
⋮----
// Multisampled textures don't support texture parameters
⋮----
// Set filtering and wrapping modes
⋮----
// Apply pixel grid alignment if needed
⋮----
int Texture::getFormatChannelCount(TextureFormat format)
⋮----
// Single channel formats
⋮----
// Dual channel formats
⋮----
// Three channel formats
⋮----
// Four channel formats
⋮----
void Texture::convertFormat(TextureFormat format, uint32_t& internalFormat, uint32_t& dataFormat, uint32_t& dataType)
⋮----
// Standard formats
⋮----
// Float formats (16-bit)
⋮----
// Float formats (32-bit)
⋮----
// Special float formats
⋮----
// Integer formats
⋮----
// Unsigned integer formats
⋮----
// Special formats
⋮----
// sRGB formats
⋮----
// Depth/stencil formats
⋮----
// Compressed formats - DXT
⋮----
// Compressed formats - ETC2
⋮----
// Compressed formats - ASTC
⋮----
} // namespace PixelCraft::Rendering
</file>

<file path="src/Utility/AABB.cpp">
// -------------------------------------------------------------------------
// AABB.cpp
⋮----
AABB::AABB()
⋮----
AABB::AABB(const glm::vec3& min, const glm::vec3& max)
⋮----
AABB::AABB(const glm::vec3& center, float halfExtentX, float halfExtentY, float halfExtentZ)
⋮----
AABB AABB::createFromPoints(const std::vector<glm::vec3>& points)
⋮----
AABB AABB::createFromSphere(const glm::vec3& center, float radius)
⋮----
glm::vec3 extent(radius, radius, radius);
⋮----
AABB AABB::createFromTransformedAABB(const AABB& aabb, const glm::mat4& transform)
⋮----
// Get the 8 corners of the source AABB
⋮----
// Transform each corner
⋮----
// Find the min/max of the transformed corners
⋮----
glm::vec3 AABB::getMin() const
⋮----
glm::vec3 AABB::getMax() const
⋮----
void AABB::setMin(const glm::vec3& min)
⋮----
void AABB::setMax(const glm::vec3& max)
⋮----
glm::vec3 AABB::getCenter() const
⋮----
glm::vec3 AABB::getExtents() const
⋮----
glm::vec3 AABB::getSize() const
⋮----
float AABB::getVolume() const
⋮----
float AABB::getSurfaceArea() const
⋮----
float AABB::getLongestAxis() const
⋮----
int AABB::getLongestAxisIndex() const
⋮----
return 0; // X is longest
⋮----
return 1; // Y is longest
⋮----
return 2; // Z is longest
⋮----
float AABB::getShortestAxis() const
⋮----
int AABB::getShortestAxisIndex() const
⋮----
return 0; // X is shortest
⋮----
return 1; // Y is shortest
⋮----
return 2; // Z is shortest
⋮----
glm::vec3 AABB::getCorner(int index) const
⋮----
// Use binary pattern:
// bit 0 (LSB): x-coordinate (0 = min.x, 1 = max.x)
// bit 1: y-coordinate (0 = min.y, 1 = max.y)
// bit 2: z-coordinate (0 = min.z, 1 = max.z)
⋮----
std::array<glm::vec3, 8> AABB::getAllCorners() const
⋮----
void AABB::expand(float amount)
⋮----
void AABB::expand(const glm::vec3& amount)
⋮----
void AABB::translate(const glm::vec3& delta)
⋮----
void AABB::transform(const glm::mat4& transform)
⋮----
AABB AABB::merge(const AABB& other) const
⋮----
void AABB::include(const glm::vec3& point)
⋮----
void AABB::include(const AABB& other)
⋮----
bool AABB::isEmpty() const
⋮----
bool AABB::isValid() const
⋮----
bool AABB::contains(const glm::vec3& point) const
⋮----
bool AABB::contains(const AABB& other) const
⋮----
bool AABB::intersects(const AABB& other) const
⋮----
bool AABB::intersects(const Ray& ray, float& tMin, float& tMax) const
⋮----
// Implementation based on the slab method
// Assumes Ray has getOrigin(), getDirection(), and getInvDirection() methods
⋮----
// Get ray properties
⋮----
// For each axis
⋮----
// Ray is parallel to slab. Check if origin is within slab
⋮----
// Ray is not parallel - compute intersection distances
⋮----
// Ensure t1 <= t2
⋮----
// Update tMin and tMax
⋮----
// Check for no intersection
⋮----
// If we get here, ray intersects AABB
⋮----
bool AABB::intersects(const Frustum& frustum) const
⋮----
// This implementation requires the Frustum class to have a method
// that tests against an AABB or its points.
// Without knowing the exact Frustum API, we'll provide a skeleton.
⋮----
// Typical frustum-AABB test approaches:
// 1. Test if any AABB corner is inside the frustum
// 2. Test AABB against each frustum plane with early-out
⋮----
// NOTE: This is a placeholder implementation.
// Actual implementation depends on Frustum class interface.
⋮----
// Assuming Frustum has a containsPoint method
// auto corners = getAllCorners();
// for (const auto& corner : corners) {
//     if (frustum.containsPoint(corner)) {
//         return true;
//     }
// }
⋮----
// Conservative fallback: assume intersection
⋮----
bool AABB::intersects(const glm::vec3& center, float radius) const
⋮----
// Get closest point on AABB to sphere center
⋮----
// Check if squared distance from closest point to sphere center is <= radius²
⋮----
glm::vec3 AABB::getClosestPoint(const glm::vec3& point) const
⋮----
// Clamp point to AABB bounds
⋮----
float AABB::getDistanceSquared(const glm::vec3& point) const
⋮----
// If point is inside AABB, distance is 0
⋮----
// Otherwise, distance is from point to closest point on AABB
⋮----
float AABB::getDistance(const glm::vec3& point) const
⋮----
void AABB::debugDraw(const glm::vec3& color) const
⋮----
// Get all 8 corners of the AABB
⋮----
// Draw the 12 edges of the AABB
// Assumes DebugDraw has a drawLine(start, end, color) method
⋮----
// Bottom face
⋮----
// Top face
⋮----
// Connecting edges
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Color.cpp">
// -------------------------------------------------------------------------
// Color.cpp
⋮----
// Define static constant colors
⋮----
Color::Color() : m_r(0.0f), m_g(0.0f), m_b(0.0f), m_a(1.0f)
⋮----
Color::Color(float r, float g, float b, float a) : m_r(r), m_g(g), m_b(b), m_a(a)
⋮----
Color::Color(uint8_t r, uint8_t g, uint8_t b, uint8_t a)
⋮----
// No need to clamp as division by 255 ensures range [0,1]
⋮----
Color::Color(uint32_t rgba)
⋮----
Color Color::fromHSV(float h, float s, float v, float a)
⋮----
Color Color::fromHSL(float h, float s, float l, float a)
⋮----
Color Color::fromString(const std::string& hexString)
⋮----
// Skip # if present
⋮----
return Color::Black; // Return black on invalid input
⋮----
// Format detection
⋮----
// #RGB format, expand to #RRGGBB
uint8_t r = ((value & 0xF00) >> 8) * 17; // * 17 to expand 0xR to 0xRR
⋮----
// #RGBA format, expand to #RRGGBBAA
⋮----
// #RRGGBB format
⋮----
// #RRGGBBAA format
⋮----
return Color::Black; // Default for invalid formats
⋮----
Color Color::lerp(const Color& a, const Color& b, float t)
⋮----
// Clamp t to [0,1]
⋮----
Color Color::random(float alpha)
⋮----
static std::mt19937 gen(rd());
⋮----
float Color::r() const
⋮----
float Color::g() const
⋮----
float Color::b() const
⋮----
float Color::a() const
⋮----
void Color::setR(float r)
⋮----
void Color::setG(float g)
⋮----
void Color::setB(float b)
⋮----
void Color::setA(float a)
⋮----
uint8_t Color::rByte() const
⋮----
uint8_t Color::gByte() const
⋮----
uint8_t Color::bByte() const
⋮----
uint8_t Color::aByte() const
⋮----
void Color::setRByte(uint8_t r)
⋮----
void Color::setGByte(uint8_t g)
⋮----
void Color::setBByte(uint8_t b)
⋮----
void Color::setAByte(uint8_t a)
⋮----
glm::vec3 Color::rgb() const
⋮----
glm::vec4 Color::rgba() const
⋮----
void Color::setRGB(const glm::vec3& rgb)
⋮----
void Color::setRGBA(const glm::vec4& rgba)
⋮----
uint32_t Color::toInt() const
⋮----
void Color::setFromInt(uint32_t rgba)
⋮----
glm::vec3 Color::toHSV() const
⋮----
// Hue calculation
⋮----
// Saturation calculation
⋮----
// Value is simply the max
⋮----
glm::vec3 Color::toHSL() const
⋮----
// Lightness is the average of max and min
⋮----
void Color::setHSV(float h, float s, float v)
⋮----
// Clamp inputs
⋮----
// HSV to RGB conversion
float c = v * s; // Chroma
float hp = h / 60.0f; // H'
⋮----
// No need to clamp as the calculations should ensure range [0,1]
⋮----
float Color::hueToRGB(float p, float q, float t)
⋮----
void Color::setHSL(float h, float s, float l)
⋮----
// HSL to RGB conversion
// If saturation is 0, the color is a shade of gray
⋮----
float hNorm = h / 360.0f; // Normalize hue to [0,1]
⋮----
// No need to clamp as hueToRGB ensures range [0,1]
⋮----
std::string Color::toHexString(bool includeAlpha) const
⋮----
std::string Color::toString() const
⋮----
Color Color::withAlpha(float alpha) const
⋮----
Color Color::saturate(float amount) const
⋮----
Color Color::desaturate(float amount) const
⋮----
Color Color::lighten(float amount) const
⋮----
Color Color::darken(float amount) const
⋮----
Color Color::complementary() const
⋮----
// Add 180 degrees to hue for complementary color
⋮----
Color Color::blend(const Color& other, float factor) const
⋮----
Color Color::multiply(const Color& other) const
⋮----
Color Color::screen(const Color& other) const
⋮----
Color Color::overlay(const Color& other) const
⋮----
std::vector<Color> Color::analogous(float angle) const
⋮----
// Clamp angle to reasonable range
⋮----
// Create colors with hues on either side of the original
⋮----
// Add angle to hue, wrapping around 360 degrees
⋮----
// Subtract angle from hue, wrapping around 360 degrees
⋮----
std::vector<Color> Color::triadic() const
⋮----
// Create colors with hues 120 degrees apart
⋮----
std::vector<Color> Color::tetradic() const
⋮----
// Create a rectangle on the color wheel (90 degrees apart)
⋮----
std::vector<Color> Color::monochromatic(int steps) const
⋮----
// Vary lightness to create monochromatic colors
⋮----
float l = t * 0.8f + 0.1f; // Range from 0.1 to 0.9
⋮----
// Prevent division by zero
⋮----
void Color::clamp()
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/DebugDraw.cpp">
// -------------------------------------------------------------------------
// DebugDraw.cpp
⋮----
// Static members initialization
⋮----
// Singleton accessor
DebugDraw& DebugDraw::getInstance()
⋮----
std::lock_guard<std::mutex> lock(s_mutex);
⋮----
DebugDraw::DebugDraw()
⋮----
bool DebugDraw::initialize()
⋮----
// Get the render system from the application
⋮----
// Load the debug shader
⋮----
// Set shader source
⋮----
// Compile shader
⋮----
// Create VAO and VBO for lines
⋮----
// Position attribute
⋮----
// Color attribute
⋮----
// Create VAO and VBO for text
⋮----
// Create VAO and VBO for billboards
⋮----
// Load font texture
⋮----
// Continue without text rendering capability
⋮----
// Create primitive meshes
⋮----
void DebugDraw::shutdown()
⋮----
// Delete OpenGL resources
⋮----
// Clear all debug primitives
⋮----
// Reset primitive meshes
⋮----
// Reset shader and font texture
⋮----
void DebugDraw::begin()
⋮----
// Clear single-frame primitives
⋮----
void DebugDraw::flush()
⋮----
// Render 3D elements first
⋮----
// Then render 2D elements (screen-space)
⋮----
void DebugDraw::clear()
⋮----
void DebugDraw::drawLine(const glm::vec3& start, const glm::vec3& end,
⋮----
void DebugDraw::drawRay(const glm::vec3& origin, const glm::vec3& direction,
⋮----
void DebugDraw::drawLineStrip(const std::vector<glm::vec3>& points,
⋮----
void DebugDraw::drawBox(const glm::vec3& center, const glm::vec3& dimensions,
⋮----
shape.scale = dimensions * 0.5f; // Half extents
⋮----
void DebugDraw::drawBox(const AABB& aabb, const glm::vec4& color,
⋮----
void DebugDraw::drawSphere(const glm::vec3& center, float radius,
⋮----
void DebugDraw::drawCylinder(const glm::vec3& base, const glm::vec3& top,
⋮----
// Calculate position, scale, and rotation
⋮----
// Create a rotation from the default up vector (0,1,0) to the direction
⋮----
// Vectors are parallel, no rotation needed
⋮----
// Vectors are opposite, rotate 180 degrees around X axis
⋮----
// Normal case, create rotation from cross product
⋮----
void DebugDraw::drawCone(const glm::vec3& apex, const glm::vec3& direction,
⋮----
void DebugDraw::drawCapsule(const glm::vec3& start, const glm::vec3& end,
⋮----
void DebugDraw::drawArrow(const glm::vec3& start, const glm::vec3& end,
⋮----
// Draw the shaft of the arrow
⋮----
// Calculate the direction of the arrow
⋮----
// Calculate the length of the arrow
⋮----
// Only draw the head if the arrow has some length
⋮----
// Calculate the size of the head
⋮----
// Calculate perpendicular vectors to create the arrow head
⋮----
// Calculate the positions of the arrow head points
⋮----
// Draw the arrow head
⋮----
void DebugDraw::drawCircle(const glm::vec3& center, float radius,
⋮----
// Calculate two perpendicular vectors in the plane
⋮----
// Create circle points
⋮----
// Draw the circle as a line strip
⋮----
void DebugDraw::drawFrustum(const Frustum& frustum, const glm::vec4& color,
⋮----
// Get the corners of the frustum
⋮----
// Draw the near plane
⋮----
// Draw the far plane
⋮----
// Connect near and far planes
⋮----
void DebugDraw::drawGrid(const glm::vec3& center, const glm::vec2& size,
⋮----
// Calculate grid dimensions
⋮----
// Calculate start positions
⋮----
// Draw grid lines
⋮----
// X lines (along Z axis)
⋮----
// Z lines (along X axis)
⋮----
// X lines (along Y axis)
⋮----
// Y lines (along X axis)
⋮----
void DebugDraw::drawAxes(const glm::vec3& position, float size,
⋮----
// X axis (red)
⋮----
// Y axis (green)
⋮----
// Z axis (blue)
⋮----
void DebugDraw::drawText(const std::string& text, const glm::vec3& position,
⋮----
void DebugDraw::draw2DText(const std::string& text, const glm::vec2& position,
⋮----
void DebugDraw::drawRect2D(const glm::vec2& position, const glm::vec2& size,
⋮----
// For filled rectangles, we would normally use a quad or triangle mesh
// For simplicity, we'll just use multiple lines to simulate a filled rectangle
float stepSize = 1.0f; // 1 pixel step
⋮----
// For wireframe, just draw the outline
⋮----
void DebugDraw::drawCircle2D(const glm::vec2& center, float radius,
⋮----
// For filled circles, we would normally use a triangle fan
// For simplicity, we'll draw lines from center to each point on the perimeter
⋮----
void DebugDraw::drawLine2D(const glm::vec2& start, const glm::vec2& end,
⋮----
void DebugDraw::setCamera(std::weak_ptr<Camera> camera)
⋮----
void DebugDraw::update(float deltaTime)
⋮----
void DebugDraw::renderLines()
⋮----
// Get camera for view/projection matrices
⋮----
// Set up shader
⋮----
// Setup line rendering
⋮----
// We'll sort lines by depth test flag to minimize state changes
⋮----
// Render depth-tested lines first
⋮----
// Enable depth testing
⋮----
// Prepare line data
⋮----
lineData.reserve(depthTestLines.size() * 14); // 7 floats per vertex, 2 vertices per line
⋮----
// Start point
⋮----
// End point
⋮----
// Upload line data
⋮----
// Draw lines
glLineWidth(1.0f); // Note: Line width is limited on modern hardware
⋮----
// Then render lines without depth testing
⋮----
// Disable depth testing
⋮----
lineData.reserve(noDepthTestLines.size() * 14); // 7 floats per vertex, 2 vertices per line
⋮----
// Clean up
⋮----
// Restore default state
⋮----
void DebugDraw::renderShapes()
⋮----
// We'll sort shapes by type and depth test flag to minimize state changes
// This is a simple approach - a more sophisticated renderer would use more advanced batching
⋮----
// Process each shape type
⋮----
// Get the mesh for this shape type
⋮----
// Capsules are special - we need to handle them differently
// For now, we'll skip them
⋮----
// Arrows are drawn using lines, not meshes
⋮----
// Frustums are drawn using lines, not meshes
⋮----
// Bind the mesh
⋮----
// Render depth-tested shapes first, then non-depth-tested
⋮----
// Set depth test state
⋮----
// Render each shape of this type and depth test setting
⋮----
// Calculate model matrix
⋮----
// Set uniforms
⋮----
// Set wireframe mode
⋮----
// Draw the mesh
⋮----
// Unbind the mesh
⋮----
void DebugDraw::renderTexts()
⋮----
// Set up shader for text rendering
// Note: In a real implementation, we would use a specific text shader with font texture
⋮----
// Bind the font texture
⋮----
// Setup text rendering
⋮----
// Enable alpha blending for text
⋮----
// We'll sort texts by depth test flag to minimize state changes
⋮----
// Render each text
// Note: This is a simplified implementation - a real text renderer would be more complex
⋮----
// Render depth-tested texts first
⋮----
// Extract rotation from view matrix to billboard the text
glm::mat3 rotMat(view);
⋮----
// Draw the text
// For simplicity, we're just drawing a quad
// In a real implementation, we'd generate vertices for each character
⋮----
// Then render texts without depth testing
⋮----
void DebugDraw::render2DElements()
⋮----
// Get the viewport dimensions
⋮----
// Create an orthographic projection matrix
⋮----
// Disable depth testing for 2D elements
⋮----
// Render 2D lines
⋮----
lineData.reserve(m_lines2D.size() * 14); // 7 floats per vertex, 2 vertices per line
⋮----
// Render 2D texts
⋮----
void DebugDraw::createPrimitiveMeshes()
⋮----
// Get the render system
⋮----
// Create a box mesh
⋮----
// Box vertices, normals, UVs, and indices would be set here
// For simplicity, we're not showing the full implementation
⋮----
// Create a sphere mesh
⋮----
// Create a cylinder mesh
⋮----
// Create a cone mesh
⋮----
// Global convenience functions
void drawLine(const glm::vec3& start, const glm::vec3& end, const glm::vec4& color)
⋮----
void drawBox(const glm::vec3& center, const glm::vec3& dimensions, const glm::vec4& color)
⋮----
void drawSphere(const glm::vec3& center, float radius, const glm::vec4& color)
⋮----
void drawText(const std::string& text, const glm::vec3& position, const glm::vec4& color)
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/FileSystem.cpp">
// -------------------------------------------------------------------------
// FileSystem.cpp
⋮----
// Static member initialization
⋮----
bool FileSystem::initialize()
⋮----
// Initialize mount points with default paths
⋮----
// Start file watcher thread
⋮----
void FileSystem::shutdown()
⋮----
// Stop file watcher thread
⋮----
// Clear all mount points and watchers
std::lock_guard<std::mutex> lock(s_fileSystemMutex);
⋮----
// File Reading Functions
FileResult FileSystem::readFile(const std::string& path, std::string& outContent)
⋮----
// Resolve virtual path if needed
⋮----
// Check if file exists and is accessible
⋮----
// Open file
std::ifstream file(resolvedPath);
⋮----
// Read content
⋮----
FileResult FileSystem::readFileBinary(const std::string& path, std::vector<uint8_t>& outData)
⋮----
// Get file size
⋮----
// Empty file, return success with empty vector
⋮----
// Resize output vector
⋮----
// Read data
std::ifstream file(resolvedPath, std::ios::binary);
⋮----
// File Writing Functions
FileResult FileSystem::writeFile(const std::string& path, const std::string& content)
⋮----
// Ensure directory exists
⋮----
std::ofstream file(resolvedPath);
⋮----
// Write content
⋮----
FileResult FileSystem::writeFileBinary(const std::string& path, const std::vector<uint8_t>& data)
⋮----
std::ofstream file(resolvedPath, std::ios::binary);
⋮----
// Write data
⋮----
FileResult FileSystem::appendFile(const std::string& path, const std::string& content)
⋮----
// Open file in append mode
std::ofstream file(resolvedPath, std::ios::app);
⋮----
// Append content
⋮----
FileResult FileSystem::appendFileBinary(const std::string& path, const std::vector<uint8_t>& data)
⋮----
// Open file in binary append mode
⋮----
// Append data
⋮----
// File Operation Functions
bool FileSystem::fileExists(const std::string& path)
⋮----
bool FileSystem::deleteFile(const std::string& path)
⋮----
bool FileSystem::copyFile(const std::string& source, const std::string& destination, bool overwrite)
⋮----
// Resolve virtual paths if needed
⋮----
// Check if destination exists and we're not overwriting
⋮----
// Ensure destination directory exists
⋮----
// Copy file
⋮----
bool FileSystem::moveFile(const std::string& source, const std::string& destination, bool overwrite)
⋮----
// If destination exists and overwrite is true, delete destination first
⋮----
// Move file
⋮----
size_t FileSystem::getFileSize(const std::string& path)
⋮----
time_t FileSystem::getFileModificationTime(const std::string& path)
⋮----
// Directory Operation Functions
bool FileSystem::createDirectory(const std::string& path)
⋮----
// If directory already exists, return true
⋮----
bool FileSystem::deleteDirectory(const std::string& path, bool recursive)
⋮----
// Use std::filesystem to remove recursively
⋮----
// Check if directory is empty
⋮----
bool FileSystem::directoryExists(const std::string& path)
⋮----
std::vector<FileInfo> FileSystem::listFiles(const std::string& directory, const std::string& filter)
⋮----
// Prepare filter as regex
⋮----
// Convert wildcard to regex
⋮----
// Replace . with \. (escape dot)
⋮----
// Replace * with .*
⋮----
// Replace ? with .
⋮----
// Iterate directory
⋮----
// Apply filter
⋮----
std::vector<FileInfo> FileSystem::listDirectories(const std::string& directory)
⋮----
info.extension = ""; // Directories don't have extensions
info.size = 0; // Size doesn't apply to directories
⋮----
// Path Utility Functions
std::string FileSystem::getPathExtension(const std::string& path)
⋮----
fs::path fsPath(normalizePath(path));
⋮----
std::string FileSystem::getFileName(const std::string& path)
⋮----
std::string FileSystem::getFileNameWithoutExtension(const std::string& path)
⋮----
std::string FileSystem::getDirectoryPath(const std::string& path)
⋮----
std::string FileSystem::normalizePath(const std::string& path)
⋮----
// Replace backslashes with forward slashes
⋮----
// Remove duplicate slashes
⋮----
// Normalize path using filesystem
fs::path fsPath(normalized);
⋮----
std::string FileSystem::combinePaths(const std::string& path1, const std::string& path2)
⋮----
fs::path p1(normalizePath(path1));
fs::path p2(normalizePath(path2));
⋮----
// File Watching Functions
uint64_t FileSystem::addFileWatcher(const std::string& path, std::function<void(const std::string&)> callback)
⋮----
// Check if file exists
⋮----
// Generate watcher ID
⋮----
// Add to watchers map
⋮----
void FileSystem::removeFileWatcher(uint64_t watcherId)
⋮----
void FileSystem::fileWatcherThreadFunc()
⋮----
// Initialize last modified times
⋮----
// Check each watched file for changes
⋮----
// Check if we have a previous time recorded
⋮----
// Compare times
⋮----
// File was modified
⋮----
it->second = currentModifiedTime; // Update last modified time
⋮----
// First time seeing this file
⋮----
// Trigger callbacks outside the lock
⋮----
// Sleep for a while to avoid high CPU usage
⋮----
// Virtual File System Functions
void FileSystem::mountDirectory(const std::string& virtualPath, const std::string& realPath)
⋮----
// Normalize paths
⋮----
// Check if real path exists
⋮----
// Try to create the directory
⋮----
// Add/update mount point
⋮----
void FileSystem::unmountDirectory(const std::string& virtualPath)
⋮----
// Normalize path
⋮----
// Check if mount point exists
⋮----
std::string FileSystem::resolveVirtualPath(const std::string& virtualPath)
⋮----
// Asynchronous Operations
std::future<std::string> FileSystem::readFileAsync(const std::string& path)
⋮----
std::future<std::vector<uint8_t>> FileSystem::readFileBinaryAsync(const std::string& path)
⋮----
// Private Helper Methods
std::string FileSystem::resolvePathInternal(const std::string& path)
⋮----
// Normalize path first
⋮----
// Check for virtual path format (e.g., "virtual://assets/textures/file.png")
⋮----
// Extract virtual part
normalizedPath = normalizedPath.substr(10); // Remove "virtual://"
⋮----
// Find first directory separator
⋮----
// No slash, treat the whole string as mount point
⋮----
// Mount point not found
⋮----
// Extract mount point name
⋮----
// Look up mount point
⋮----
// Combine real path with remaining path
⋮----
FileResult FileSystem::checkFileAccess(const std::string& path, FileMode mode)
⋮----
// Check access rights based on mode
⋮----
// Use filesystem permissions to check access
⋮----
// Check owner permissions (assuming running as owner)
⋮----
// Check based on mode
⋮----
bool FileSystem::ensureDirectoryExists(const std::string& path)
⋮----
// Platform-specific implementations
FileResult FileSystem::platformReadFile(const std::string& path, void* buffer, size_t bufferSize, size_t& bytesRead, FileMode mode)
⋮----
// This function would contain platform-specific file reading code
// For now, we'll use std::fstream which is cross-platform
⋮----
std::ifstream file(path, openMode);
⋮----
FileResult FileSystem::platformWriteFile(const std::string& path, const void* buffer, size_t bufferSize, FileMode mode)
⋮----
// This function would contain platform-specific file writing code
⋮----
std::ofstream file(path, openMode);
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Frustum_SIMD.cpp">
// -------------------------------------------------------------------------
// Frustum_SIMD.cpp - SIMD-optimized implementation of sphere culling
⋮----
// SIMD-optimized version of testSphereIntersection
// This can replace the original implementation in Frustum.cpp
IntersectionType Frustum::testSphereIntersection(const glm::vec3& center, float radius) const
⋮----
// Optimization using SSE intrinsics
⋮----
// Process planes in groups of 4 for SIMD efficiency
⋮----
// Process first 4 planes
⋮----
// Calculate dot product (normalX * centerX + normalY * centerY + normalZ * centerZ)
⋮----
// Sum dot products and add distance to get signed distance
⋮----
// Test if any distance < -radius (outside)
⋮----
// Test if any distance < radius (not fully inside)
⋮----
// Process remaining 2 planes
⋮----
// Calculate dot product
⋮----
// Sum dot products and add distance
⋮----
// Mask to only consider the first 2 values
⋮----
// Check if any plane has the sphere completely outside
⋮----
// Check if all planes have the sphere completely inside
⋮----
// If we get here, the sphere intersects the frustum
⋮----
} // namespace PixelCraft::Utility
⋮----
#endif // __SSE__
</file>

<file path="src/Utility/Frustum.cpp">
// -------------------------------------------------------------------------
// Frustum.cpp
⋮----
//-----------------------------------------------------------------------------
// Plane Implementation
⋮----
Plane::Plane() : m_normal(0.0f, 1.0f, 0.0f), m_distance(0.0f)
⋮----
Plane::Plane(const glm::vec3& normal, float distance) : m_normal(normal), m_distance(distance)
⋮----
Plane::Plane(const glm::vec3& normal, const glm::vec3& point) : m_normal(normal)
⋮----
Plane::Plane(float a, float b, float c, float d) : m_normal(a, b, c), m_distance(d)
⋮----
void Plane::normalize()
⋮----
float Plane::getSignedDistance(const glm::vec3& point) const
⋮----
const glm::vec3& Plane::getNormal() const
⋮----
float Plane::getDistance() const
⋮----
void Plane::setNormal(const glm::vec3& normal)
⋮----
void Plane::setDistance(float distance)
⋮----
// Frustum Implementation
⋮----
Frustum::Frustum() : m_planesNormalized(false)
⋮----
void Frustum::initialize()
⋮----
// Initialize with a default unit frustum
⋮----
// Initialize corners
⋮----
void Frustum::update(const glm::mat4& viewProjection)
⋮----
// Also calculate corners - for this we need the inverse view-projection matrix
⋮----
void Frustum::extractPlanes(const glm::mat4& matrix)
⋮----
// Extract frustum planes from view-projection matrix
// Method: Gribb/Hartmann method (efficient extraction)
⋮----
// Left plane
⋮----
// Right plane
⋮----
// Bottom plane
⋮----
// Top plane
⋮----
// Near plane
⋮----
// Far plane
⋮----
// Normalize all planes
⋮----
void Frustum::extractCorners(const glm::mat4& invViewProj)
⋮----
// Frustum corners in NDC space
⋮----
// Near face (z = -1)
glm::vec4(-1.0f, -1.0f, -1.0f, 1.0f), // Bottom-left
glm::vec4(1.0f, -1.0f, -1.0f, 1.0f),  // Bottom-right
glm::vec4(1.0f, 1.0f, -1.0f, 1.0f),   // Top-right
glm::vec4(-1.0f, 1.0f, -1.0f, 1.0f),  // Top-left
⋮----
// Far face (z = 1)
glm::vec4(-1.0f, -1.0f, 1.0f, 1.0f),  // Bottom-left
glm::vec4(1.0f, -1.0f, 1.0f, 1.0f),   // Bottom-right
glm::vec4(1.0f, 1.0f, 1.0f, 1.0f),    // Top-right
glm::vec4(-1.0f, 1.0f, 1.0f, 1.0f)    // Top-left
⋮----
// Transform NDC corners to world space
⋮----
// Perspective divide
⋮----
const Plane& Frustum::getPlane(FrustumPlane planeType) const
⋮----
Plane& Frustum::getPlane(FrustumPlane planeType)
⋮----
const std::array<Plane, 6>& Frustum::getPlanes() const
⋮----
const std::array<glm::vec3, 8>& Frustum::getCorners() const
⋮----
bool Frustum::testPoint(const glm::vec3& point) const
⋮----
// For a point to be inside the frustum, it must be on the positive
// side of all planes (or on the plane)
⋮----
bool Frustum::testSphere(const glm::vec3& center, float radius) const
⋮----
// For a sphere to be inside or intersect, the distance to each plane
// must be greater than -radius
⋮----
IntersectionType Frustum::testSphereIntersection(const glm::vec3& center, float radius) const
⋮----
// SIMD optimization potential here with intrinsics
⋮----
// Outside
⋮----
// Intersecting
⋮----
bool Frustum::testAABB(const glm::vec3& min, const glm::vec3& max) const
⋮----
// Quick test - if any plane has the box completely on the negative side,
// the box is outside the frustum
⋮----
// Find the corner of the box that is furthest in the direction of the plane normal
⋮----
// If this corner is outside, the entire box is outside
⋮----
// If we get here, the box is either intersecting or inside the frustum
⋮----
IntersectionType Frustum::testAABBIntersection(const glm::vec3& min, const glm::vec3& max) const
⋮----
// More detailed test than testAABB
⋮----
// Find the positive vertex (p-vertex)
⋮----
// Find the negative vertex (n-vertex)
⋮----
// Check p-vertex
⋮----
// Check n-vertex (if n-vertex is outside, the box is intersecting)
⋮----
void Frustum::debugDraw(const glm::vec3& color) const
⋮----
// Note: This implementation depends on the DebugDraw utility
// A reference implementation is provided but actual usage would require
// the DebugDraw system to be integrated
⋮----
// Draw near face
/*
        DebugDraw::drawLine(m_corners[0], m_corners[1], color);
        DebugDraw::drawLine(m_corners[1], m_corners[2], color);
        DebugDraw::drawLine(m_corners[2], m_corners[3], color);
        DebugDraw::drawLine(m_corners[3], m_corners[0], color);

        // Draw far face
        DebugDraw::drawLine(m_corners[4], m_corners[5], color);
        DebugDraw::drawLine(m_corners[5], m_corners[6], color);
        DebugDraw::drawLine(m_corners[6], m_corners[7], color);
        DebugDraw::drawLine(m_corners[7], m_corners[4], color);

        // Draw edges connecting near and far faces
        DebugDraw::drawLine(m_corners[0], m_corners[4], color);
        DebugDraw::drawLine(m_corners[1], m_corners[5], color);
        DebugDraw::drawLine(m_corners[2], m_corners[6], color);
        DebugDraw::drawLine(m_corners[3], m_corners[7], color);
        */
⋮----
// For now, let's just use comments as a placeholder
// The actual implementation would call the DebugDraw system
// once it's integrated
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Math.cpp">
// -------------------------------------------------------------------------
// Math.cpp
⋮----
// Initialize static members
std::mt19937 Math::s_randomEngine(static_cast<unsigned int>(std::time(nullptr)));
⋮----
// Initialize noise tables on first use
⋮----
float Math::lerp(float a, float b, float t)
⋮----
glm::vec2 Math::lerp(const glm::vec2& a, const glm::vec2& b, float t)
⋮----
// SIMD optimized implementation for vec2
⋮----
// a + t * (b - a)
⋮----
// Extract the results
⋮----
glm::vec3 Math::lerp(const glm::vec3& a, const glm::vec3& b, float t)
⋮----
// SIMD optimized implementation for vec3
⋮----
glm::vec4 Math::lerp(const glm::vec4& a, const glm::vec4& b, float t)
⋮----
// SIMD optimized implementation for vec4
⋮----
float Math::smoothStep(float a, float b, float t)
⋮----
// Clamp t to [0, 1]
⋮----
// Apply smoothstep formula: 3t² - 2t³
⋮----
// Interpolate between a and b
⋮----
float Math::smootherStep(float a, float b, float t)
⋮----
// Apply Ken Perlin's improved smoothstep: 6t^5 - 15t^4 + 10t^3
⋮----
float Math::clamp(float value, float min, float max)
⋮----
int Math::clamp(int value, int min, int max)
⋮----
float Math::wrapAngle(float angle)
⋮----
// Wrap the angle to (-PI, PI]
⋮----
float Math::angleBetween(const glm::vec2& a, const glm::vec2& b)
⋮----
// Calculate the signed angle between two 2D vectors
⋮----
float Math::angleBetween(const glm::vec3& a, const glm::vec3& b)
⋮----
// Calculate the angle between two 3D vectors
⋮----
// Protect against zero vectors
⋮----
// Clamp to prevent floating-point errors
⋮----
float Math::randomRange(float min, float max)
⋮----
int Math::randomRange(int min, int max)
⋮----
std::uniform_int_distribution<int> intDist(min, max);
⋮----
glm::vec2 Math::randomDirection2D()
⋮----
glm::vec3 Math::randomDirection3D()
⋮----
// Generate a random point on a unit sphere
⋮----
glm::vec3 Math::randomPointOnSphere()
⋮----
// This is the same as randomDirection3D()
⋮----
glm::vec3 Math::randomPointInSphere()
⋮----
// Generate a random direction and scale by random radius with cubic distribution
float radius = std::cbrt(randomRange(0.0f, 1.0f)); // Cubic root for uniform distribution
⋮----
// Initialize the noise tables
void Math::initializeNoise()
⋮----
// Initialize permutation table with a random sequence
⋮----
// Shuffle permutation table
⋮----
// Mirror into the second half
⋮----
// Generate random gradient vectors for 2D noise
⋮----
// Generate random gradient vectors for 3D noise
⋮----
int Math::perm(int i)
⋮----
float Math::grad(int hash, float x)
⋮----
float grad = 1.0f + (h & 7);  // Gradient value 1-8
if (h & 8) grad = -grad;      // Random sign
return (grad * x);            // Multiply the gradient with the distance
⋮----
float Math::grad(int hash, float x, float y)
⋮----
float Math::grad(int hash, float x, float y, float z)
⋮----
float Math::perlinNoise(float x)
⋮----
float Math::perlinNoise(float x, float y)
⋮----
// Integer part of coordinates
⋮----
// Fractional part of coordinates
⋮----
// Compute fade curves
⋮----
// Hash coordinates of the 4 square corners
⋮----
// Blend the gradients
⋮----
// Scale to range [-1, 1]
⋮----
float Math::perlinNoise(float x, float y, float z)
⋮----
// Hash coordinates of the 8 cube corners
⋮----
// Blend the gradients of the 8 corners
⋮----
float Math::simplexNoise(float x, float y)
⋮----
const float F2 = 0.366025403f; // F2 = 0.5*(sqrt(3.0)-1.0)
const float G2 = 0.211324865f; // G2 = (3.0-sqrt(3.0))/6.0
⋮----
// Skew the input space to determine which simplex cell we're in
⋮----
float X0 = i - t; // Unskew the cell origin back to (x,y) space
⋮----
float x0 = x - X0; // The x,y distances from the cell origin
⋮----
// Determine which simplex we are in
int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
⋮----
{ // lower triangle, XY order: (0,0)->(1,0)->(1,1)
⋮----
{ // upper triangle, YX order: (0,0)->(0,1)->(1,1)
⋮----
// A step of (1,0) in (i,j) means a step of (1-G2,G2) in (x,y), and
// a step of (0,1) in (i,j) means a step of (G2,1-G2) in (x,y).
float x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
⋮----
float x2 = x0 - 1.0f + 2.0f * G2; // Offsets for last corner in (x,y) unskewed coords
⋮----
// Work out the hashed gradient indices of the three simplex corners
⋮----
// Calculate contribution from the three corners
⋮----
// Add contributions from each corner to get the final noise value.
// The result is scaled to return values in the interval [-1,1].
⋮----
float Math::simplexNoise(float x, float y, float z)
⋮----
float X0 = i - t; // Unskew the cell origin back to (x,y,z) space
⋮----
float x0 = x - X0; // The x,y,z distances from the cell origin
⋮----
int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords
⋮----
{ // X Y Z order
⋮----
{ // X Z Y order
⋮----
{ // Z X Y order
⋮----
{ // x0<y0
⋮----
{ // Z Y X order
⋮----
{ // Y Z X order
⋮----
{ // Y X Z order
⋮----
// A step of (1,0,0) in (i,j,k) means a step of (1-G3,G3,G3) in (x,y,z),
// a step of (0,1,0) in (i,j,k) means a step of (G3,1-G3,G3) in (x,y,z), and
// a step of (0,0,1) in (i,j,k) means a step of (G3,G3,1-G3) in (x,y,z).
float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
⋮----
float x2 = x0 - i2 + 2.0f * G3; // Offsets for third corner in (x,y,z) coords
⋮----
float x3 = x0 - 1.0f + 3.0f * G3; // Offsets for last corner in (x,y,z) coords
⋮----
// Work out the hashed gradient indices of the four simplex corners
⋮----
// Calculate contribution from the four corners
⋮----
float Math::fractalNoise(float x, float y, int octaves, float persistence)
⋮----
float maxValue = 0.0f;  // Used for normalizing result to -1.0 - 1.0
⋮----
glm::vec3 Math::projectOnPlane(const glm::vec3& vector, const glm::vec3& planeNormal)
⋮----
// Project vector onto plane: v - (v·n)n where n is normalized
⋮----
// Handle near-zero normals
⋮----
glm::vec3 Math::reflect(const glm::vec3& vector, const glm::vec3& normal)
⋮----
// Reflect vector: v - 2(v·n)n where n is normalized
⋮----
glm::vec3 Math::calculateNormal(const glm::vec3& a, const glm::vec3& b, const glm::vec3& c)
⋮----
// Calculate vectors along two edges of the triangle
⋮----
// Cross product of the two edges gives us the normal
⋮----
// Normalize the result
⋮----
// Fallback if the triangle is degenerate
⋮----
glm::vec3 Math::calculateTangent(const glm::vec3& p1, const glm::vec3& p2, const glm::vec3& p3,
⋮----
// Calculate edges of the triangle in both 3D space and UV space
⋮----
// Solve the linear system to find the tangent
⋮----
bool Math::equals(float a, float b, float epsilon)
⋮----
bool Math::equals(const glm::vec2& a, const glm::vec2& b, float epsilon)
⋮----
bool Math::equals(const glm::vec3& a, const glm::vec3& b, float epsilon)
⋮----
glm::mat4 Math::createTransformMatrix(const glm::vec3& position, const glm::quat& rotation, const glm::vec3& scale)
⋮----
// Create transformation matrix in TRS order (scale, then rotate, then translate)
⋮----
// Combine the transformations (order matters!)
⋮----
void Math::decomposeTransform(const glm::mat4& transform, glm::vec3& position, glm::quat& rotation, glm::vec3& scale)
⋮----
// Extract the position from the last column
⋮----
// Extract the scale
⋮----
// Create rotation matrix by removing scale from the upper 3x3 portion
⋮----
// Convert to quaternion
⋮----
glm::vec3 Math::transformPoint(const glm::mat4& matrix, const glm::vec3& point)
⋮----
// Transform a point (applying translation)
⋮----
glm::vec3 Math::transformDirection(const glm::mat4& matrix, const glm::vec3& direction)
⋮----
// Transform a direction (ignoring translation)
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Profiler.cpp">
// -------------------------------------------------------------------------
// Profiler.cpp
⋮----
// Initialize thread-local storage
⋮----
//-------------------------------------------------------------------------
// ScopedProfiler Implementation
⋮----
ScopedProfiler::ScopedProfiler(const std::string& name) : m_name(name)
⋮----
// Profiler Implementation
⋮----
Profiler& Profiler::getInstance()
⋮----
Profiler::Profiler()
⋮----
bool Profiler::initialize()
⋮----
std::lock_guard<std::mutex> lock(m_profilerMutex);
⋮----
// Set main thread name if not already set
⋮----
void Profiler::shutdown()
⋮----
// Output final stats if requested
⋮----
// Clean up resources
⋮----
void Profiler::enableProfiling(bool enable)
⋮----
// Clear active samples when disabling
⋮----
bool Profiler::isProfilingEnabled() const
⋮----
void Profiler::beginSample(const std::string& name)
⋮----
// Get or create the profile sample
⋮----
// Set up parent-child relationship
⋮----
// Check if this child already exists in the parent's children
⋮----
// Add as a new child
⋮----
// Set parent for this sample
⋮----
// Push to active samples stack
⋮----
void Profiler::endSample()
⋮----
// Update the sample
⋮----
// Update statistics
⋮----
// Pop from active samples stack
⋮----
void Profiler::beginFrame()
⋮----
// Reset active sample stacks to handle cases where samples were not properly ended
⋮----
// Clear active GPU queries
⋮----
void Profiler::endFrame()
⋮----
// Calculate frame time
⋮----
// Store frame stats
⋮----
// Limit stored frame stats
⋮----
// Output stats if requested
⋮----
const ProfileSample* Profiler::getSample(const std::string& name) const
⋮----
const std::vector<std::string>& Profiler::getSampleNames() const
⋮----
const std::vector<FrameStats>& Profiler::getFrameStats() const
⋮----
void Profiler::resetStats()
⋮----
// Reset all samples
⋮----
// Clear frame stats
⋮----
void Profiler::resetSample(const std::string& name)
⋮----
void Profiler::setOutputFrequency(uint32_t frameInterval)
⋮----
void Profiler::outputToLog()
⋮----
void Profiler::outputToFile(const std::string& filename)
⋮----
// Logger::error("Failed to open profiler output file: " + filename);
⋮----
void Profiler::outputToConsole()
⋮----
void Profiler::setDisplayMode(ProfilerDisplayMode mode)
⋮----
ProfilerDisplayMode Profiler::getDisplayMode() const
⋮----
void Profiler::render()
⋮----
void Profiler::setThreadName(const std::string& name)
⋮----
std::string Profiler::getThreadName(std::thread::id threadId) const
⋮----
void Profiler::beginGPUSample(const std::string& name)
⋮----
// Implementation will depend on graphics API (OpenGL, DirectX, etc.)
// Here's a placeholder for the interface
⋮----
// Get or create the GPU query
⋮----
// Create query objects
// glGenQueries(2, &queryId); // Start and end query IDs
⋮----
// Begin query
// glBeginQuery(GL_TIME_ELAPSED, queryId);
⋮----
void Profiler::endGPUSample()
⋮----
// End query
// glEndQuery(GL_TIME_ELAPSED);
⋮----
// Results will be available later, need to poll
// This is simplified - real implementation would need to handle async results
⋮----
// For now, use CPU time as placeholder
⋮----
sample.duration = 0.0; // Will be populated when GPU query results are available
⋮----
void Profiler::setPerformanceMarker(const std::string& name)
⋮----
// Integration with performance monitoring tools
// This is platform-specific (PIX, RenderDoc, etc.)
⋮----
// Example for PIX on Windows:
// PIXSetMarker(0, name.c_str());
⋮----
void Profiler::beginPerformanceMarker(const std::string& name)
⋮----
// PIXBeginEvent(0, name.c_str());
⋮----
void Profiler::endPerformanceMarker()
⋮----
// PIXEndEvent();
⋮----
double Profiler::getCurrentTimeMs()
⋮----
return duration.count() / 1000000.0; // Convert to milliseconds
⋮----
void Profiler::updateSampleStatistics(ProfileSample& sample, double duration)
⋮----
// Update min/max times
⋮----
// Update average (running average)
⋮----
// Incremental average calculation
⋮----
// Update call count
⋮----
ProfileSample& Profiler::getThreadSample(const std::string& name)
⋮----
// Check if the sample already exists
⋮----
// Create a new sample
⋮----
void Profiler::renderUI()
⋮----
// This would typically use a UI library like ImGui
⋮----
// Example implementation with ImGui:
/*
        if (ImGui::Begin("Profiler", nullptr, ImGuiWindowFlags_AlwaysAutoResize)) {
            // Display mode selection
            const char* modes[] = { "Disabled", "Simple", "Detailed", "Hierarchical", "Graph" };
            int currentMode = static_cast<int>(m_displayMode);
            if (ImGui::Combo("Display Mode", &currentMode, modes, IM_ARRAYSIZE(modes))) {
                m_displayMode = static_cast<ProfilerDisplayMode>(currentMode);
            }

            ImGui::Separator();

            // Frame time display
            ImGui::Text("Frame Time: %s", formatTime(m_frameTime).c_str());
            ImGui::Text("FPS: %.1f", 1000.0 / m_frameTime);

            ImGui::Separator();

            switch (m_displayMode) {
                case ProfilerDisplayMode::Simple:
                    renderSimpleView();
                    break;
                case ProfilerDisplayMode::Detailed:
                    renderDetailedView();
                    break;
                case ProfilerDisplayMode::Hierarchical:
                    renderHierarchicalView();
                    break;
                case ProfilerDisplayMode::Graph:
                    renderGraphView();
                    break;
                default:
                    break;
            }
        }
        ImGui::End();
        */
⋮----
std::string Profiler::formatTime(double timeMs)
⋮----
// Microseconds
⋮----
// Milliseconds
⋮----
// Seconds
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Random.cpp">
// -------------------------------------------------------------------------
// Random.cpp
⋮----
// Initialize thread-local engine
⋮----
// Singleton instance management
⋮----
void createInstance()
⋮----
Random::Random(uint32_t seed)
⋮----
void Random::seed(uint32_t seed)
⋮----
// For thread-local engine, use the base seed plus a hash of the thread ID
// to ensure different threads get different sequences
⋮----
void Random::seedFromTime()
⋮----
uint32_t Random::getSeed() const
⋮----
int32_t Random::getInt()
⋮----
int32_t Random::getInt(int32_t min, int32_t max)
⋮----
std::uniform_int_distribution<int32_t> dist(min, max);
⋮----
uint32_t Random::getUint()
⋮----
uint32_t Random::getUint(uint32_t min, uint32_t max)
⋮----
std::uniform_int_distribution<uint32_t> dist(min, max);
⋮----
float Random::getFloat()
⋮----
float Random::getFloat(float min, float max)
⋮----
double Random::getDouble()
⋮----
double Random::getDouble(double min, double max)
⋮----
bool Random::getBool()
⋮----
bool Random::getBool(float probability)
⋮----
glm::vec2 Random::getVec2()
⋮----
glm::vec2 Random::getVec2(float min, float max)
⋮----
glm::vec2 Random::getVec2(const glm::vec2& min, const glm::vec2& max)
⋮----
glm::vec3 Random::getVec3()
⋮----
glm::vec3 Random::getVec3(float min, float max)
⋮----
glm::vec3 Random::getVec3(const glm::vec3& min, const glm::vec3& max)
⋮----
glm::vec4 Random::getVec4()
⋮----
glm::vec4 Random::getVec4(float min, float max)
⋮----
glm::vec4 Random::getVec4(const glm::vec4& min, const glm::vec4& max)
⋮----
glm::vec2 Random::getDir2D()
⋮----
// Generate a random angle and convert to a unit vector
⋮----
glm::vec3 Random::getDir3D()
⋮----
// Uniform distribution on a sphere
// Use the method described by Marsaglia (1972)
⋮----
glm::vec2 Random::getPointInCircle(float radius)
⋮----
// Generate a point in the unit circle with uniform distribution
// Use polar coordinates with adjusted radius for uniform distribution
⋮----
glm::vec2 Random::getPointOnCircle(float radius)
⋮----
// Generate a random angle and convert to point on circle
⋮----
glm::vec3 Random::getPointInSphere(float radius)
⋮----
// Generate a point in the unit sphere with uniform distribution
// Use spherical coordinates with adjusted radius for uniform distribution
float r = radius * std::cbrt(getFloat());  // Cube root for uniform distribution
⋮----
glm::vec3 Random::getPointOnSphere(float radius)
⋮----
// Generate a random direction and scale to radius
⋮----
glm::vec3 Random::getPointInCube(float size)
⋮----
glm::vec3 Random::getPointInBox(const glm::vec3& dimensions)
⋮----
float Random::getAngle()
⋮----
glm::quat Random::getQuat()
⋮----
// Generate a random rotation quaternion
// Based on "Uniform Random Rotations" by Ken Shoemake
⋮----
float Random::getNormal(float mean, float stdDev)
⋮----
// Use standard normal distribution and transform to desired parameters
⋮----
float Random::getExponential(float lambda)
⋮----
std::exponential_distribution<float> dist(lambda);
⋮----
Color Random::getColor(bool randomAlpha)
⋮----
Color Random::getColorHSV(float minHue, float maxHue,
⋮----
// Generate random HSV values in the specified ranges
⋮----
// Ensure hue is in the range [0, 360)
⋮----
// HSV to RGB conversion
⋮----
bool Random::chance(float probability)
⋮----
int Random::roll(int sides)
⋮----
int Random::rollDice(int count, int sides)
⋮----
Random& Random::getInstance()
⋮----
// Global convenience functions
int32_t randomInt(int32_t min, int32_t max)
⋮----
float randomFloat(float min, float max)
⋮----
bool randomBool(float probability)
⋮----
glm::vec3 randomDir3D()
⋮----
Color randomColor()
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Ray.cpp">
// -------------------------------------------------------------------------
// Ray.cpp
⋮----
Ray::Ray()
⋮----
Ray::Ray(const glm::vec3& origin, const glm::vec3& direction)
⋮----
void Ray::setOrigin(const glm::vec3& origin)
⋮----
void Ray::setDirection(const glm::vec3& direction)
⋮----
// Don't normalize if given a zero vector to avoid NaNs
⋮----
void Ray::updateCachedValues()
⋮----
// Calculate inverse direction components
⋮----
// Store signs of direction components for optimized AABB test
⋮----
Ray Ray::transform(const glm::mat4& matrix) const
⋮----
// Transform origin point by full matrix
⋮----
// Transform direction by rotation part of matrix (upper 3x3)
// Direction is a vector, not a point, so we don't apply translation
⋮----
bool Ray::intersectAABB(const AABB& aabb, float& tMin, float& tMax) const
⋮----
// Get AABB bounds
⋮----
// Optimized slab method using precomputed inverse direction
⋮----
bool Ray::intersectSphere(const glm::vec3& center, float radius, float& t) const
⋮----
// Calculate vector from ray origin to sphere center
⋮----
// Quadratic coefficients
float a = glm::dot(m_direction, m_direction); // Always 1 for normalized direction
⋮----
// Calculate discriminant
⋮----
// No intersection
⋮----
// Calculate closest intersection
⋮----
// Check for valid intersections (in front of ray origin)
⋮----
// Sphere is behind ray origin
⋮----
bool Ray::intersectPlane(const glm::vec3& normal, float distance, float& t) const
⋮----
// Calculate dot product between ray direction and plane normal
⋮----
// Check if ray is parallel to plane
⋮----
// Calculate intersection distance
⋮----
// Check if intersection is in front of ray origin
⋮----
bool Ray::intersectPlane(const glm::vec3& normal, const glm::vec3& point, float& t) const
⋮----
// Convert to plane equation form Ax + By + Cz + D = 0
// where D = -dot(normal, point)
⋮----
// Use the other plane intersection method
⋮----
bool Ray::intersectTriangle(const glm::vec3& v0, const glm::vec3& v1, const glm::vec3& v2,
⋮----
// Implementation of Möller–Trumbore algorithm
⋮----
// Edge vectors
⋮----
// Calculate determinant
⋮----
// Check backface culling
⋮----
// Check if ray is parallel to triangle
⋮----
// Calculate u parameter
⋮----
// Check if intersection is outside triangle (u coordinate)
⋮----
// Calculate v parameter
⋮----
// Check if intersection is outside triangle (u+v coordinate)
⋮----
// Calculate t parameter (distance along ray)
⋮----
bool Ray::intersectTriangleMesh(const std::vector<glm::vec3>& vertices,
⋮----
// Initialize results
⋮----
// Iterate through all triangles in the mesh
⋮----
// Get triangle vertices
⋮----
// Test intersection with triangle
⋮----
// If closer than previous hits, update result
⋮----
float Ray::distanceToPoint(const glm::vec3& point) const
⋮----
// Vector from ray origin to point
⋮----
// Project onto ray direction
⋮----
// Calculate closest point on ray
⋮----
// Point projects behind ray origin
⋮----
// Point projects onto ray
⋮----
// Return distance to closest point
⋮----
float Ray::distanceToLineSegment(const glm::vec3& start, const glm::vec3& end,
⋮----
// Calculate segment direction and length
⋮----
// Handle degenerate segment
⋮----
// Normalize segment direction
⋮----
// Compute ray-segment closest points
// Parameterize ray as p(t) = origin + t * direction
// Parameterize segment as q(s) = start + s * direction
⋮----
// Closest points satisfy:
// (p(t) - q(s)) dot direction = 0
// (p(t) - q(s)) dot segmentDir = 0
⋮----
// Set up the linear system
⋮----
float a = 1.0f;                             // dot(direction, direction) = 1 (normalized)
⋮----
float d = -1.0f;                            // -dot(segmentDir, segmentDir) = -1 (normalized)
⋮----
// Compute determinant
⋮----
// Check if ray and segment are parallel
⋮----
// Find closest point on segment to ray origin
⋮----
// Clamp to segment bounds
⋮----
// Calculate closest point on segment
⋮----
// Parameter along ray
⋮----
t = std::max(0.0f, t);  // Ensure t is positive
⋮----
// Return distance
⋮----
// Solve linear system
⋮----
// Clamp segment parameter to valid range [0, segmentLength]
⋮----
// Recalculate ray parameter using clamped segment parameter
⋮----
// Return distance between closest points
⋮----
float Ray::distanceToPlane(const glm::vec3& normal, float distance) const
⋮----
// Calculate signed distance from ray origin to plane
⋮----
float Ray::distanceToPlane(const glm::vec3& normal, const glm::vec3& point) const
⋮----
// Convert to plane equation form
⋮----
// Use the other distance method
⋮----
void Ray::setDifferentials(const glm::vec3& dPdx, const glm::vec3& dPdy,
⋮----
void Ray::debugDraw(float length, const glm::vec3& color) const
⋮----
// Draw ray as a line from origin to origin + direction * length
⋮----
// Use the engine's debug drawing system
⋮----
// Draw a small sphere at the origin to indicate the ray's start point
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/StringUtils.cpp">
// -------------------------------------------------------------------------
// StringUtils.cpp
⋮----
// Trimming Functions
⋮----
std::string StringUtils::trim(const std::string& str)
⋮----
std::string StringUtils::trimLeft(const std::string& str)
⋮----
std::string StringUtils::trimRight(const std::string& str)
⋮----
// Case Conversion Functions
⋮----
std::string StringUtils::toUpper(const std::string& str)
⋮----
std::string StringUtils::toLower(const std::string& str)
⋮----
std::string StringUtils::toTitleCase(const std::string& str)
⋮----
std::string StringUtils::toCamelCase(const std::string& str)
⋮----
// First convert to title case
⋮----
// Then make the first character lowercase
⋮----
// Remove spaces, hyphens, and underscores
⋮----
std::string StringUtils::toPascalCase(const std::string& str)
⋮----
// Convert to title case
⋮----
std::string StringUtils::toSnakeCase(const std::string& str)
⋮----
result.reserve(str.size() * 2); // Allocate more space to avoid reallocations
⋮----
// Skip spaces, hyphens, and underscores
⋮----
// If uppercase and not the first character, add underscore before it
⋮----
std::string StringUtils::toKebabCase(const std::string& str)
⋮----
// Convert to snake case first
⋮----
// Replace underscores with hyphens
⋮----
// Splitting and Joining Functions
⋮----
std::vector<std::string> StringUtils::split(const std::string& str, const std::string& delimiter)
⋮----
std::vector<std::string> StringUtils::splitByWhitespace(const std::string& str)
⋮----
std::stringstream ss(str);
⋮----
std::string StringUtils::join(const std::vector<std::string>& strings, const std::string& delimiter)
⋮----
// Find and Replace Functions
⋮----
std::string StringUtils::replace(const std::string& str, const std::string& from, const std::string& to)
⋮----
std::string StringUtils::replaceAll(const std::string& str, const std::string& from, const std::string& to)
⋮----
pos += to.length(); // Skip the replacement to avoid infinite loop if 'to' contains 'from'
⋮----
// String Checking Functions
⋮----
bool StringUtils::startsWith(const std::string& str, const std::string& prefix)
⋮----
bool StringUtils::endsWith(const std::string& str, const std::string& suffix)
⋮----
bool StringUtils::contains(const std::string& str, const std::string& substring)
⋮----
bool StringUtils::isAlpha(const std::string& str)
⋮----
bool StringUtils::isNumeric(const std::string& str)
⋮----
bool StringUtils::isAlphaNumeric(const std::string& str)
⋮----
// Padding Functions
⋮----
std::string StringUtils::padLeft(const std::string& str, size_t totalWidth, char padChar)
⋮----
std::string StringUtils::padRight(const std::string& str, size_t totalWidth, char padChar)
⋮----
std::string StringUtils::center(const std::string& str, size_t totalWidth, char padChar)
⋮----
// Parsing Functions
⋮----
int StringUtils::parseInt(const std::string& str, int defaultValue)
⋮----
float StringUtils::parseFloat(const std::string& str, float defaultValue)
⋮----
bool StringUtils::parseBool(const std::string& str, bool defaultValue)
⋮----
// Conversion Functions
⋮----
std::string StringUtils::toString(int value)
⋮----
std::string StringUtils::toString(float value, int precision)
⋮----
std::string StringUtils::toString(double value, int precision)
⋮----
std::string StringUtils::toString(bool value)
⋮----
std::string StringUtils::toString(const glm::vec2& value, int precision)
⋮----
std::string StringUtils::toString(const glm::vec3& value, int precision)
⋮----
std::string StringUtils::toString(const glm::vec4& value, int precision)
⋮----
// Encoding/Decoding Functions
⋮----
std::string StringUtils::urlEncode(const std::string& str)
⋮----
// Keep alphanumeric and other accepted characters intact
⋮----
// Any other characters are percent-encoded
⋮----
std::string StringUtils::urlDecode(const std::string& str)
⋮----
static inline bool isBase64(unsigned char c)
⋮----
std::string StringUtils::base64Encode(const std::vector<uint8_t>& data)
⋮----
std::vector<uint8_t> StringUtils::base64Decode(const std::string& str)
⋮----
// Hash Functions
⋮----
size_t StringUtils::hash(const std::string& str)
⋮----
std::string StringUtils::md5(const std::string& str)
⋮----
std::string StringUtils::sha1(const std::string& str)
⋮----
// Path Utilities
⋮----
std::string StringUtils::getPathExtension(const std::string& path)
⋮----
std::filesystem::path fsPath(path);
⋮----
// Remove the leading dot from the extension
⋮----
std::string StringUtils::getFileName(const std::string& path)
⋮----
std::string StringUtils::getFileNameWithoutExtension(const std::string& path)
⋮----
std::string StringUtils::getDirectoryPath(const std::string& path)
⋮----
std::string StringUtils::normalizePath(const std::string& path)
⋮----
std::string StringUtils::combinePaths(const std::string& path1, const std::string& path2)
⋮----
std::filesystem::path fsPath1(path1);
std::filesystem::path fsPath2(path2);
⋮----
} // namespace PixelCraft::Utility
</file>

<file path="src/Utility/Transform.cpp">
// -------------------------------------------------------------------------
// Transform.cpp
⋮----
Transform::Transform()
⋮----
, m_rotation(1.0f, 0.0f, 0.0f, 0.0f)  // Identity quaternion
⋮----
Transform::Transform(const glm::vec3& position)
⋮----
Transform::Transform(const glm::vec3& position, const glm::quat& rotation)
⋮----
// Ensure rotation quaternion is normalized
⋮----
Transform::Transform(const glm::vec3& position, const glm::quat& rotation, const glm::vec3& scale)
⋮----
Transform::Transform(const glm::mat4& matrix)
⋮----
void Transform::setPosition(const glm::vec3& position)
⋮----
void Transform::setPosition(float x, float y, float z)
⋮----
const glm::vec3& Transform::getPosition() const
⋮----
void Transform::translate(const glm::vec3& delta)
⋮----
void Transform::translate(float x, float y, float z)
⋮----
void Transform::setRotation(const glm::quat& rotation)
⋮----
m_rotation = glm::normalize(rotation); // Ensure quaternion is normalized
⋮----
void Transform::setRotation(const glm::vec3& eulerAngles)
⋮----
// Convert Euler angles (in radians) to quaternion
⋮----
// Ensure quaternion is normalized
⋮----
void Transform::setRotation(float yaw, float pitch, float roll)
⋮----
// Create rotation quaternion from Euler angles (in radians)
// Note: GLM expects the angles in the order: pitch, yaw, roll
⋮----
void Transform::setRotationFromAxisAngle(const glm::vec3& axis, float angle)
⋮----
const glm::quat& Transform::getRotation() const
⋮----
glm::vec3 Transform::getEulerAngles() const
⋮----
// Convert quaternion to Euler angles (in radians)
⋮----
void Transform::rotate(const glm::quat& rotation)
⋮----
// Apply rotation (quaternion multiplication)
⋮----
void Transform::rotate(const glm::vec3& eulerAngles)
⋮----
// Create rotation quaternion from Euler angles and apply it
⋮----
void Transform::rotate(float yaw, float pitch, float roll)
⋮----
void Transform::rotateAround(const glm::vec3& point, const glm::quat& rotation)
⋮----
// 1. Translate position relative to the rotation point
⋮----
// 2. Rotate the relative position
⋮----
// 3. Translate back to world space
⋮----
// 4. Apply rotation to current rotation
⋮----
void Transform::setScale(const glm::vec3& scale)
⋮----
void Transform::setScale(float uniformScale)
⋮----
void Transform::setScale(float x, float y, float z)
⋮----
const glm::vec3& Transform::getScale() const
⋮----
void Transform::scaleBy(const glm::vec3& scale)
⋮----
void Transform::scaleBy(float scale)
⋮----
glm::vec3 Transform::getForward() const
⋮----
// Forward is -Z axis rotated by quaternion
⋮----
glm::vec3 Transform::getRight() const
⋮----
// Right is +X axis rotated by quaternion
⋮----
glm::vec3 Transform::getUp() const
⋮----
// Up is +Y axis rotated by quaternion
⋮----
const glm::mat4& Transform::getMatrix() const
⋮----
glm::mat4 Transform::getInverseMatrix() const
⋮----
// For a TRS (translation-rotation-scale) matrix, the inverse can be computed efficiently
// if we know the components. This is more efficient than inverting the matrix directly.
⋮----
// Inverse scale (reciprocal)
⋮----
// Inverse rotation (conjugate of quaternion)
⋮----
// Build the inverse scale matrix
⋮----
// Build the inverse rotation matrix
⋮----
// Transform the negated position by inverse rotation and scale
⋮----
// Build the inverse translation matrix
⋮----
// Combine the inverse matrices in reverse order
// For a TRS matrix, the inverse is S^-1 * R^-1 * T^-1
⋮----
void Transform::setFromMatrix(const glm::mat4& matrix)
⋮----
void Transform::decompose(const glm::mat4& matrix, glm::vec3& position, glm::quat& rotation, glm::vec3& scale)
⋮----
// Extract translation
⋮----
// Extract the rotation and scale
glm::mat3 rotScaleMat(matrix);
⋮----
// Extract scale by calculating the length of each axis
⋮----
// Determine if the matrix includes reflection/shear
// We do this by checking if the cross product of the x and y axes
// points in the same direction as the z axis
⋮----
// Matrix includes reflection, adjust scale and one axis
⋮----
// Remove scaling from rotation matrix
⋮----
// Reconstruct the normalized rotation matrix
glm::mat3 rotMat(columnX, columnY, columnZ);
⋮----
// Convert rotation matrix to quaternion
⋮----
rotation = glm::normalize(rotation); // Ensure the quaternion is normalized
⋮----
glm::vec3 Transform::transformPoint(const glm::vec3& point) const
⋮----
// Transform point: M * point
// We can do this more efficiently by directly applying TRS components
⋮----
// Apply scale
⋮----
// Apply rotation
⋮----
// Apply translation
⋮----
glm::vec3 Transform::transformDirection(const glm::vec3& direction) const
⋮----
// Transform direction vector: only apply rotation
⋮----
glm::vec3 Transform::inverseTransformPoint(const glm::vec3& point) const
⋮----
// Inverse transform point: M^-1 * point
// We can do this more efficiently by directly applying inverse TRS components
⋮----
// Apply inverse translation
⋮----
// Apply inverse rotation (conjugate quaternion)
⋮----
// Apply inverse scale
⋮----
glm::vec3 Transform::inverseTransformDirection(const glm::vec3& direction) const
⋮----
// Inverse transform direction: only apply inverse rotation
⋮----
Transform Transform::combinedWith(const Transform& parent) const
⋮----
// Combine transforms: parent * this
⋮----
// Scale = parent.scale * this.scale
⋮----
// Rotation = parent.rotation * this.rotation
⋮----
// Position = parent.position + (parent.rotation * (parent.scale * this.position))
⋮----
Transform Transform::relativeTo(const Transform& parent) const
⋮----
// Compute this transform relative to the parent transform
⋮----
// Inverse scale
⋮----
// Inverse rotation
⋮----
// Position = parent^-1 * this.position
⋮----
// Rotation = parent^-1 * this.rotation
⋮----
// Scale = this.scale / parent.scale
⋮----
Transform Transform::lerp(const Transform& a, const Transform& b, float t)
⋮----
// Clamp t to [0,1]
⋮----
// Linear interpolation of position and scale
⋮----
// Spherical linear interpolation of rotation
⋮----
// Create and return the interpolated transform
⋮----
void Transform::lookAt(const glm::vec3& target, const glm::vec3& up)
⋮----
// Compute look direction
⋮----
// Edge case: target is very close to position
⋮----
// Construct a rotation matrix that looks in the direction of the target
⋮----
// Extract rotation quaternion from the look matrix
// Note that lookAt returns a view matrix which is the inverse of what we want
// We need to take the upper-left 3x3 of the matrix, which is the rotation part
glm::mat3 rotMat(lookMatrix);
rotMat = glm::transpose(rotMat); // Transpose to convert from view to model
⋮----
// Convert the rotation matrix to a quaternion
⋮----
void Transform::reset()
⋮----
m_rotation = glm::quat(1.0f, 0.0f, 0.0f, 0.0f); // Identity quaternion
⋮----
void Transform::markDirty()
⋮----
void Transform::updateMatrix() const
⋮----
// Build transformation matrix: Translation * Rotation * Scale
⋮----
} // namespace PixelCraft::Utility
</file>

</files>
