This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.
The content has been processed where content has been compressed (code blocks are separated by ⋮---- delimiter).

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: include/Core, include/Voxel, include/ECS, src/Voxel, src/ECS
- Files matching these patterns are excluded: include/ECS/Error.h, include/ECS/Components, src/ECS/Components, include/ECS/Schemas, src/ECS/Schemas
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Content has been compressed - code blocks are separated by ⋮---- delimiter
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
include/Core/Application.h
include/Core/ConfigManager.h
include/Core/Logger.h
include/Core/MemoryManager.h
include/Core/MemoryPool.h
include/Core/Resource.h
include/Core/ResourceManager.h
include/Core/Subsystem.h
include/Core/ThreadSafeQueue.h
include/ECS/Component.h
include/ECS/ComponentPool.h
include/ECS/ComponentRegistry.h
include/ECS/Deserializer.h
include/ECS/Entity.h
include/ECS/EntityMetadata.h
include/ECS/FlatBufferSerializer.h
include/ECS/Registry.h
include/ECS/Scene.h
include/ECS/Serializer.h
include/ECS/System.h
include/ECS/Types.h
include/ECS/UUID.h
include/ECS/View.h
include/ECS/World.h
include/Voxel/BiomeManager.h
include/Voxel/Chunk.h
include/Voxel/ChunkCoord.h
include/Voxel/ChunkManager.h
include/Voxel/ChunkMesh.h
include/Voxel/ChunkStorage.h
include/Voxel/DistributionControl.h
include/Voxel/FeaturePlacement.h
include/Voxel/FileChunkStorage.h
include/Voxel/GenerationParameters.h
include/Voxel/Grid.h
include/Voxel/NoiseGenerator.h
include/Voxel/ProceduralGenerationSystem.h
include/Voxel/StreamingManager.h
include/Voxel/Voxel.h
src/ECS/Component.cpp
src/ECS/ComponentRegistry.cpp
src/ECS/Deserializer.cpp
src/ECS/Entity.cpp
src/ECS/EntityMetadata.cpp
src/ECS/Error.cpp
src/ECS/FlatBufferSerializer.cpp
src/ECS/Registry.cpp
src/ECS/Scene.cpp
src/ECS/Serializer.cpp
src/ECS/System.cpp
src/ECS/UUID.cpp
src/ECS/World.cpp
src/Voxel/BiomeManager.cpp
src/Voxel/Chunk.cpp
src/Voxel/ChunkManager.cpp
src/Voxel/ChunkMesh.cpp
src/Voxel/ChunkStorage.cpp
src/Voxel/DistributionControl.cpp
src/Voxel/FeaturePlacement.cpp
src/Voxel/FileChunkStorage.cpp
src/Voxel/GenerationParameters.cpp
src/Voxel/Grid.cpp
src/Voxel/NoiseGenerator.cpp
src/Voxel/ProceduralGenerationSystem.cpp
src/Voxel/StreamingManager.cpp
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="include/Core/Application.h">
// -------------------------------------------------------------------------
// Application.h
⋮----
/**
     * @brief Central engine controller with modular subsystem management
     */
⋮----
/**
         * @brief Get the singleton instance of the Application
         * @return Reference to the Application instance
         */
static Application* getInstance();
⋮----
/**
         * @brief Deleted copy constructor to enforce singleton
         */
⋮----
/**
         * @brief Deleted assignment operator to enforce singleton
         */
⋮----
/**
         * @brief Initialize the application and still unregistered subsystems
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Run the main application loop
         */
void run();
⋮----
/**
         * @brief Update all subsystems for a single frame
         * @param deltaTime Time since last update
         */
void update(float deltaTime);
⋮----
/**
         * @brief Render a single frame
         */
void render();
⋮----
/**
         * @brief Shut down the application and all subsystems
         */
void shutdown();
⋮----
/**
         * @brief Request the application to quit
         */
void quit();
⋮----
/**
         * @brief Get the time elapsed since the last frame
         * @return Delta time in seconds
         */
float getDeltaTime() const;
⋮----
/**
         * @brief Get a subsystem by type
         * @tparam T Type of subsystem to retrieve
         * @return Shared pointer to the requested subsystem
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
/**
         * @brief Register a subsystem with the application
         * @tparam T Type of subsystem to register
         * @param subsystem Shared pointer to the subsystem
         * @return True if registration was successful
         */
⋮----
/**
         * @brief Private constructor to enforce singleton
         */
⋮----
/**
         * @brief Sort subsystems based on their dependencies
         * @return True if dependencies could be resolved without cycles
         */
bool sortSubsystemDependencies();
⋮----
/**
         * @brief Initialize a specific subsystem and its dependencies
         * @param typeIndex Type index of the subsystem to initialize
         * @param initializedSystems Set of already initialized subsystems
         * @return True if initialization was successful
         */
bool initializeSubsystem(const std::type_index& typeIndex, std::set<std::type_index>& initializedSystems);
⋮----
// Singleton instance
⋮----
// Member variables
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ConfigManager.h">
// -------------------------------------------------------------------------
// ConfigManager.h
⋮----
//#include "Events/Event.h"
⋮----
// Forward delcarations
⋮----
/**
     * @brief Engine and game configuration with hot-reloading support
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the ConfigManager instance
         */
⋮----
/**
         * @brief Initialize the configuration system
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the configuration system to check for file system
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Shut down the configuration system
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the subsystem dependencies
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Load configuration from file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         * @return True if loading was successful
         */
⋮----
/**
         * @brief Save configuration to a file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         * @return True if saving was successful
         */
bool saveConfig(const std::string& filename, const std::string& section = "");
⋮----
/**
         * @brief Get a configuration value with type safety
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Configuration value or default if not found
         */
⋮----
T get(const std::string& key, const T& defaultValue = T()) const;
⋮----
/**
         * @brief Get an integer configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Integer value or default if not found
         */
int getInt(const std::string& key, int defaultValue = 0) const;
⋮----
/**
         * @brief Get a float configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Float value or default if not found
         */
float getFloat(const std::string& key, float defaultValue = 0.0f) const;
⋮----
/**
         * @brief Get a boolean configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Boolean value or default if not found
         */
bool getBool(const std::string& key, bool defaultValue = false) const;
⋮----
/**
         * @brief Get a string configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return String value or default if not found
         */
std::string getString(const std::string& key, const std::string& defaultValue = "") const;
⋮----
/**
         * @brief Get a vec2 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec2 value or default if not found
         */
glm::vec2 getVec2(const std::string& key, const glm::vec2& defaultValue = glm::vec2(0.0f)) const;
⋮----
/**
         * @brief Get a vec3 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec3 value or default if not found
         */
glm::vec3 getVec3(const std::string& key, const glm::vec3& defaultValue = glm::vec3(0.0f)) const;
⋮----
/**
         * @brief Get a vec4 configuration value
         * @param key Configuration key
         * @param defaultValue Default value if key doesn't exist
         * @return Vec4 value or default if not found
         */
glm::vec4 getVec4(const std::string& key, const glm::vec4& defaultValue = glm::vec4(0.0f)) const;
⋮----
/**
         * @brief Set a configuration value
         * @param key Configuration key
         * @param value Value to set
         */
⋮----
void set(const std::string& key, const T& value);
⋮----
/**
         * @brief Check if a configuration key exists
         * @param key Configuration key
         * @return True if the key exists
         */
bool hasKey(const std::string& key) const;
⋮----
/**
         * @brief Watch a configuration file for changes
         * @param filename Path to the configuration file
         * @param enable Whether to enable disable watching
         */
void watch(const std::string& filename, bool enable = true);
⋮----
/**
         * @brief Callback type for configuration changes
         */
⋮----
/**
         * @brief Register a callback for configuration changes
         * @param callback Function to call when configuration changes
         * @return Callback ID for unregistering
         */
uint64_t registerChangeCallback(const ConfigChangeCallback& callback);
⋮----
/**
         * @brief Unregister a change callback
         * @param callbackId ID from registerChangeCallback
         */
void unregisterChangeCallback(uint64_t callbackId);
⋮----
/**
         * @brief Private constructor for singleton
         */
ConfigManager();
⋮----
/**
         * @brief Private destructor for singleton
         */
//~ConfigManager();
⋮----
/**
         * @brief Check watched files for changes
         */
void checkWatchedFiles();
⋮----
/**
         * @brief Parse a configuration file
         * @param filename Path to the configuration file
         * @param section Optional section name for grouping
         */
void parseConfigFile(const std::string& filename, const std::string& section);
⋮----
/**
         * @brief Notify callbacks about configuration changes
         * @param key Changed configuration key
         * @param section Section containing the key
         */
void notifyConfigChange(const std::string& key, const std::string& section);
⋮----
/**
         * @brief Determine file format from extension
         * @param filename Path to the configuration file
         * @return String indicating the format ("json", "yaml", etc.)
         */
std::string getFileFormat(const std::string& filename) const;
⋮----
/**
         * @brief Convert string to appropriate variant type
         * @param value String representation of value
         * @param type Type hint string ("int", "float", etc.)
         * @return Variant containing the converted value
         */
⋮----
stringToVariant(const std::string& value, const std::string& type) const;
⋮----
// Config storage - maps keys to values of various types
⋮----
// Maps sections to filename
⋮----
// Maps filenames to section
⋮----
// Set of files being watched for changes
⋮----
// File watcher implementation
⋮----
// Callback management
⋮----
// Threading protection
⋮----
// Last check time for file changes
⋮----
// Check interval for file changes in seconds
⋮----
// Singleton instance
⋮----
/**
     * @brief Event for configuration changes
     */
//class ConfigChangeEvent : public Events::Event
//{
//public:
//    /**
//     * @brief Constructor
//     * @param key Changed configuration key
//     * @param section Section containing the key
//     */
//    ConfigChangeEvent(const std::string& key, const std::string& section)
//        : m_key(key), m_section(section)
//    {
//    }
⋮----
//     * @brief Get the changed key
//     * @return Configuration key
⋮----
//    const std::string& getKey() const
⋮----
//        return m_key;
⋮----
//     * @brief Get the section
//     * @return Section name
⋮----
//    const std::string& getSection() const
⋮----
//        return m_section;
⋮----
//     * @brief Get the event type name
//     * @return Type name string
⋮----
//    std::string getTypeName() const override
⋮----
//        return "ConfigChangeEvent";
⋮----
//     * @brief Get the event type index
//     * @return Type index for event system
⋮----
//    static std::type_index getTypeIndex()
⋮----
//        return std::type_index(typeid(ConfigChangeEvent));
⋮----
//private:
//    std::string m_key;
//    std::string m_section;
//};
⋮----
/**
     * @brief Helper for file change monitoring
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Add a file to watch
         * @param filename Path to the file
         */
void addWatch(const std::string& filename);
⋮----
/**
         * @brief Remove a file from watching
         * @param filename Path to the file
         */
void removeWatch(const std::string& filename);
⋮----
/**
         * @brief Check if any watched files have changed
         * @return Vector of changed filenames
         */
⋮----
// Maps filenames to last modification times
⋮----
// Template implementation for get
⋮----
// Template implementation for set
⋮----
// Find which section this key belongs to
for (const auto& [sec, file] : m_configFiles)
⋮----
if (!sec.empty())
⋮----
// If the key starts with the section name and a dot
⋮----
// Notify about the change
⋮----
// Template specializations for common types
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Logger.h">
// -------------------------------------------------------------------------
// Logger.h
⋮----
/**
     * @brief Log severity levels
     */
enum class LogLevel
⋮----
Debug,   // Detailed information for debugging
Info,    // General information about system operation
Warning, // Potential issues that aren't critical errors
Error,   // Errors that affect functionality but don't crash
Fatal,   // Critical errors that prevent operation
⋮----
/**
     * @brief Abstract base class for log output channels
     */
⋮----
/**
         * @brief Write a log message to the channel
         * @param level The severity level of the message
         * @param message The formatted message to write
         */
virtual void write(LogLevel level, const std::string& message) = 0;
⋮----
/**
         * @brief Flush any buffered messages
         */
virtual void flush() = 0;
⋮----
/**
     * Channel for logging to console output
     */
⋮----
void write(LogLevel level, const std::string& message) override;
void flush() override;
⋮----
/**
     * @brief Channel for logging to a file
     */
⋮----
/**
         * @brief Constructor
         * @param filename Path to the log file
         */
⋮----
/**
     * @brief Thread-safe logging system with multiple output channels
     */
⋮----
/**
         * @brief Get the singleton logger instance
         * @return Reference to the logger instance
         */
⋮----
/**
         * @brief Initialize the logging system
         * @return True if initialization succeeded
         */
bool initialize();
⋮----
/**
         * @brief Shut down the logging system and flush all channels
         */
void shutdown();
⋮----
/**
         * @brief Set the minimum severity level for logging
         * @param level The minimum level to log
         */
void setLogLevel(LogLevel level);
⋮----
/**
         * @brief Get the current minimum severity level
         * @return The current log level
         */
LogLevel getLogLevel() const;
⋮----
/**
         * @brief Add an output channel
         * @param channel Shared pointer to a log channel
         */
void addChannel(std::shared_ptr<LogChannel> channel);
⋮----
/**
         * @brief Remove an output channel
         * @param channel Shared pointer to the channel to remove
         */
void removeChannel(std::shared_ptr<LogChannel> channel);
⋮----
/**
         * @brief Set a category for subsequent log messages
         * @param category The category name
         */
void setCategory(const std::string& category);
⋮----
/**
         * @brief Clear the current category
         */
void clearCategory();
⋮----
/**
         * @brief Log a message with specific severity
         * @param level The severity level
         * @param message The message to log
         */
void log(LogLevel level, const std::string& message);
⋮----
/**
         * @brief Log a debug message
         * @param message The message to log
         */
void debug(const std::string& message);
⋮----
/**
         * @brief Log an info message
         * @param message The message to log
         */
void info(const std::string& message);
⋮----
/**
         * @brief Log a warning message
         * @param message The message to log
         */
void warn(const std::string& message);
⋮----
/**
         * @brief Log an error message
         * @param message The message to log
         */
void error(const std::string& message);
⋮----
/**
         * @brief Log a fatal error message
         * @param message The message to log
         */
void fatal(const std::string& message);
⋮----
Logger();
⋮----
// Prevent copying
⋮----
/**
         * @brief Format a log message with timestamp and context
         * @param level The severity level
         * @param message The raw message
         * @return Formatted message ready for output
         */
std::string formatMessage(LogLevel level, const std::string& message);
⋮----
/**
         * @brief Convert a log level to its string representation
         * @param level The log level
         * @return String representation of the log level
         */
std::string logLevelToString(LogLevel level);
⋮----
// Global convenience functions
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/MemoryManager.h">
// -------------------------------------------------------------------------
// MemoryManager.h
⋮----
/**
     * @brief Central memory management system with pooling, defragmentation, and diagnostics
     * 
     * Manages multiple typed memory pools, provides custom allocators for smart pointers,
     * and tracks memory usage throughout the engine.
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the MemoryManager instance
         */
⋮----
/**
         * @brief Initialize the memory manager
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the memory manager and release all memory
         */
void shutdown();
⋮----
/**
         * @brief Create a memory pool for a specific type
         * @tparam T Type of objects to be allocated from the pool
         * @param initialCapacity Initial number of objects the pool can hold
         * @return Pointer to the created memory pool
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
// Return existing pool if already created
⋮----
// Create new pool
⋮----
// Update statistics
⋮----
/**
         * @brief Get an existing memory pool for a specific type
         * @tparam T Type of objects allocated from the pool
         * @return Pointer to the memory pool or nullptr if not found
         */
⋮----
/**
         * @brief Allocate a single object of type T from its pool
         * @tparam T Type of object to allocate
         * @return Pointer to the allocated object (nullptr if allocation failed)
         */
⋮----
// Construct the object in-place
⋮----
/**
         * @brief Deallocate an object previously allocated from a pool
         * @tparam T Type of object to deallocate
         * @param ptr Pointer to the object
         */
⋮----
// Call destructor
⋮----
// Return memory to the pool
⋮----
/**
         * @brief Structure for tracking memory allocation statistics
         */
struct AllocationStats
⋮----
size_t totalAllocated{0};     // Total bytes allocated since startup
size_t totalFreed{0};         // Total bytes freed since startup
size_t currentUsage{0};       // Current memory usage in bytes
size_t peakUsage{0};          // Peak memory usage in bytes
size_t totalCapacity{0};      // Total capacity of all pools in bytes
int activePoolCount{0};       // Number of active memory pools
int allocationCount{0};       // Number of allocation operations
int deallocationCount{0};     // Number of deallocation operations
⋮----
/**
         * @brief Get current memory allocation statistics
         * @return Statistics structure with allocation data
         */
AllocationStats getAllocStats() const;
⋮----
/**
         * @brief Defragment all memory pools
         * 
         * This is a potentially expensive operation and should be used during
         * loading screens or other non-performance-critical moments.
         */
void defragmentAll();
⋮----
/**
         * @brief Release all unused memory pools
         * @return Number of pools released
         */
int releaseUnused();
⋮----
/**
         * @brief Custom deleter for use with smart pointers
         * @tparam T Type of object to delete
         */
⋮----
void operator()(T* ptr) const
⋮----
/**
         * @brief Create a shared_ptr using pool allocation
         * @tparam T Type of object to create
         * @tparam Args Constructor argument types
         * @param args Constructor arguments
         * @return shared_ptr to the newly created object
         */
⋮----
// Placement new with constructor arguments
new(ptr) T(std::forward<Args>(args)...);
⋮----
// Create shared_ptr with custom deleter
⋮----
/**
         * @brief Create a unique_ptr using pool allocation
         * @tparam T Type of object to create
         * @tparam Args Constructor argument types
         * @param args Constructor arguments
         * @return unique_ptr to the newly created object
         */
⋮----
// Create unique_ptr with custom deleter
⋮----
/**
         * @brief Private constructor for singleton pattern
         */
⋮----
/**
         * @brief Private destructor for singleton pattern
         */
//~MemoryManager();
⋮----
// Delete copy/move constructors and assignment operators
⋮----
/**
     * @brief Convenience function to create a shared_ptr using the memory manager
     * @tparam T Type of object to create
     * @tparam Args Constructor argument types
     * @param args Constructor arguments
     * @return shared_ptr to he newly created object
     */
⋮----
/**
     * @brief Convenience function to create a unique_ptr using the memory manager
     * @tparam T Type of object to create
     * @tparam Args Constructor argument types
     * @param args Constructor arguments
     * @return unique_ptr to the newly created object
     */
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/MemoryPool.h">
// -------------------------------------------------------------------------
// MemoryPool.h
⋮----
/**
     * @brief Type-specific memory pool for efficient allocation and deallocation
     * 
     * Provides a contiguous block of memory for fixed-size objects with
     * minimal overhead. Supports defragmentation, reserving capacity, and
     * tracking allocation statistics.
     */
⋮----
/**
         * @brief Constructor
         * @param objectSize Size of each object in bytes
         * @param initialCapacity Initial number of objects the pool can hold
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Allocate a block of memory from the pool
         * @return Pointer to allocated memory or nullptr if allocation failed
         */
void* allocate();
⋮----
/**
         * @brief Return a block of memory to the pool
         * @param ptr Pointer to memory previously allocated by this pool
         */
void deallocate(void* ptr);
⋮----
/**
         * @brief Get the number of currently used blocks
         * @return Number of allocated blocks
         */
size_t getUsedBlocks() const;
⋮----
/**
         * @brief Get the number of free blocks
         * @return Number of unallocated blocks
         */
size_t getFreeBlocks() const;
⋮----
/**
         * @brief Get the total capacity of the pool
         * @return Total number of blocks (used + free)
         */
size_t getCapacity() const;
⋮----
/**
         * @brief Get the size of each object in the pool
         * @return Size in bytes of each object
         */
size_t getObjectSize() const;
⋮----
/**
         * @brief Ensure the pool has at least the specified capacity
         * @param newCapacity Minimum number of objects the pool should hold
         */
void reserve(size_t newCapacity);
⋮----
/**
         * @brief Defragment the memory pool to consolidate free blocks
         * 
         * This operation may be expensive and should be used sparingly,
         * typically during loading screens or other non-performance-critical moments
         */
void defragment();
⋮----
/**
         * @brief Check if a pointer belongs to this memory pool
         * @param ptr Pointer to check
         * @return True if the pointer was allocated from this pool
         */
bool owns(void* ptr) const;
⋮----
/**
         * @brief Structure for tracking memory pool statistics
         */
struct PoolStats
⋮----
size_t objectSize;        // Size of each object in bytes
size_t capacity;          // Total capacity in objects
size_t usedBlocks;        // Number of allocated objects
size_t freeBlocks;        // Number of available objects
size_t memoryUsage;       // Total memory usage in bytes
size_t fragmentationRatio;// Fragmentation percentage (0-100)
⋮----
/**
         * @brief Get statistics about the memory pool
         * @return PoolStats structure with current statistics
         */
PoolStats getStats() const;
⋮----
/**
         * @brief Grow the pool by allocating more memory
         * @param additionalCapacity Number of objects to add
         * @return True if growth was successful
         */
bool grow(size_t additionalCapacity);
⋮----
/**
         * @brief Check if the pointer is aligned and within the pool's memory range
         * @param ptr Pointer to validate
         * @return True if the pointer is valid for this pool
         */
bool isValidPointer(void* ptr) const;
⋮----
size_t m_objectSize;               // Size of each object in bytes
size_t m_capacity;                 // Total numbers of objects the pool can hold
std::atomic<size_t> m_usedBlocks;  // Number of currently allocated blocks
⋮----
unsigned char* m_memory;           // Raw memory block
std::vector<void*> m_freeBlocks;   // Stack of free block pointers
⋮----
mutable std::mutex m_mutex;        // Mutex for thread safety
bool m_initialized;                // Flag to track initialization status
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Resource.h">
// -------------------------------------------------------------------------
// Resource.h
⋮----
/**
     * @brief Base class for all engine resources with reference coutings
     */
⋮----
/**
         * @brief Constructor
         * @param path The file path for this resource
         */
⋮----
/**
         * @brief Virtual destructor
         */
virtual ~Resource();
⋮----
/**
         * @brief Load the resource from its path
         * @return True if loading was successful
         */
virtual bool load() = 0;
⋮----
/**
         * @brief Unload the resource and free memory
         */
virtual void unload() = 0;
⋮----
/**
         * @brief Check if the resource is currently loaded
         * @return True if the resource is loaded
         */
bool isLoaded() const
⋮----
/**
         * @brief Get the file path for this resource
         * @return The resource file path
         */
const std::string& getPath() const
⋮----
/**
         * @brief Get the name of this resource
         * @return The resource name
         */
const std::string& getName() const
⋮----
/**
         * @brief Get the current reference count
         * @return Number of references to this resource
         */
int getRefCount() const
⋮----
/**
         * @brief Called when hot-reloading this resource
         * @return True if reloading was successful
         */
virtual bool onReload();
⋮----
/**
         * @brief Increment the reference count
         * @return The new reference count
         */
int addRef()
⋮----
/**
         * @brief Decrement the reference count
         * @return The new reference count
         */
int releaseRef()
⋮----
std::string m_path;    ///< File path of the resource
std::string m_name;    ///< Name of the resource (derived from path)
bool m_loaded;         ///< Whether the resource is currently loaded
std::atomic<int> m_refCount; ///< Reference count for memory management
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ResourceManager.h">
// -------------------------------------------------------------------------
// ResourceManager.h
⋮----
/**
     * @brief Unified resource loading, caching, and hot-reloading
     */
⋮----
/**
         * @brief Get the singleton instance
         * @return Reference to the ResourceManager instance
         */
⋮----
/**
         * @brief Initialize the resource manager
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the resource manager and release resources
         */
void shutdown();
⋮----
/**
         * @brief Load a resource of the specified type
         * @param path The file path of the resource
         * @return Shared pointer to the loaded resource
         */
⋮----
// Check if already loaded
⋮----
// Create and load the resources
⋮----
resource->addRef(); // Initial reference
⋮----
// Queue for async loading
⋮----
// Load synchronously
⋮----
// Store file modification time for hot reloading
⋮----
// Store in the resource map
⋮----
/**
         * @brief Load a resource asynchronously
         * @param path The file path of the resource
         * @param callback Function to call when loading completes
         */
⋮----
// Create the resource
⋮----
/**
         * @brief Unload a resource and release memory
         * @param path The file path of the resource to unload
         */
⋮----
// Decrement reference count
⋮----
// If no more reference, unload and remove from map
⋮----
// If no more resources of this type, remove the type map
⋮----
// Actually unload the resource outside the lock to prevent deadlocks
⋮----
/**
         * @brief Get a resource without loading it
         * @param path The file path of the resource
         * @return Shared pointer to the resource or nullptr if not found
         */
⋮----
/**
         * @brief Create a new resource without a file path
         * @param name The name of the resource
         * @return Shared pointer to the created resource
         */
⋮----
// Create the resource with a virtual path
⋮----
// Check if already exists
⋮----
/**
         * @brief Check for modified resources and reload them
         */
void reloadModified();
⋮----
/**
         * @brief Enable or disable asynchronous loading
         * @param enabled True to enable async loading, false for synchronous
         */
void setAsyncLoading(bool enabled);
⋮----
/**
         * @brief Constructor (private for singleton)
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
// Prevent copying
⋮----
/**
         * @brief Async loading thread function
         */
void asyncLoadingThreadFunc();
⋮----
// Type-specific resource maps
⋮----
// File modification times for hot reloading
⋮----
// Async loading queue
struct ResourceTask
⋮----
std::type_index typeIndex = typeid(void); // Default to void type
⋮----
// Mutex for resource map access
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/Subsystem.h">
// -------------------------------------------------------------------------
// Subsystem.h
⋮----
/**
     * @brief Base class for all engine subsystems with standardized lifecycle.
     * 
     * Provides a common interface for initialization, updating, rendering,
     * and shutdown that all engine subsystems must implement.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Virtual destructor for proper cleanup of derived classes
         */
virtual ~Subsystem();
⋮----
/**
         * @brief Initialize the subsystem
         * @return True if initialization was successful, false otherwise
         */
virtual bool initialize() = 0;
⋮----
/**
         * @brief Update the subsystem logic
         * @param deltaTime Time elapsed since the last update in seconds
         */
virtual void update(float deltaTime) = 0;
⋮----
/**
         * @brief Render any visual elements of the subsystem
         */
virtual void render() = 0;
⋮----
/**
         * @brief Shutdown the subsystem and release resources
         */
virtual void shutdown() = 0;
⋮----
/**
         * @brief Check if the subsystem has been initialized
         * @return True if initialized, false otherwise
         */
bool isInitialized() const;
⋮----
/**
         * @brief Check if the subsystem is currently active
         * @return True if active, false otherwise
         */
bool isActive() const;
⋮----
/**
         * @brief Set the active state of the subsystem
         * @param active The new active state
         */
void setActive(bool active);
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name as a string
         */
virtual std::string getName() const = 0
⋮----
/**
         * @brief Get the dependencies of this subsystem
         * @return Vector of the subsystem names that this subsystem depends on
         */
virtual std::vector<std::string> getDependencies() const;
⋮----
/** @brief Flag indicating whether the subsystem has been initialized */
⋮----
/** @brief Name of the subsystem */
⋮----
/** @brief Flag indicating whether the subsystem is active */
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/Core/ThreadSafeQueue.h">
// -------------------------------------------------------------------------
// ThreadSafeQueue.h
⋮----
/**
     * @brief Thread-safe queue for asynchronous resource loading
     */
⋮----
/**
         * @brief Add an item to the queue
         * @param item The item to add
         */
⋮----
/**
         * @brief Wait and pop an item from the queue
         * @param item Output parameter for the popped item
         */
void waitAndPop(T& item)
⋮----
/**
         * @brief Signal shutdown to wake up any waiting threads
         */
void shutdown()
⋮----
} // namespace PixelCraft::Core
</file>

<file path="include/ECS/Component.h">
// -------------------------------------------------------------------------
// Component.h
⋮----
// Forward declarations
⋮----
/**
         * @brief Schema definition for FlatBuffers serialization
         */
⋮----
/**
             * @brief Get the schema definition as a string
             * @return String representation of the FlatBuffers schema
             */
⋮----
/**
             * @brief Get the schema unique identifier
             * @return The unique identifier for this schema
             */
virtual std::string getIdentifier() const = 0;
⋮----
/**
             * @brief Get the schema version
             * @return The schema version number
             */
virtual uint32_t getVersion() const = 0;
⋮----
/**
     * @brief Base class for all components in the ECS architecture
     *
     * The Component class defines the interface that all components must implement.
     * It provides serialization capabilities, lifecycle methods, type identification,
     * and entity ownership tracking.
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Virtual destructor for proper inheritance
         */
virtual ~Component() = default;
⋮----
/**
         * @brief Initialize the component
         *
         * Called after the component is created and attached to an entity.
         * Override in derived classes to implement component-specific initialization.
         */
virtual void initialize();
⋮----
/**
         * @brief Create a copy of this component
         *
         * @return A unique pointer to a new component instance
         */
virtual std::unique_ptr<Component> clone() = 0;
⋮----
/**
         * @brief Get the component type ID
         *
         * @return The unique type identifier for this component
         */
virtual ComponentTypeID getTypeID() const = 0;
⋮----
/**
         * @brief Get the component type name
         *
         * @return The string representation of the component type
         */
virtual std::string getTypeName() const = 0;
⋮----
/**
         * @brief Serialize the component to binary format
         *
         * @param serializer The serializer object to write to
         */
⋮----
/**
         * @brief Deserialize the component from binary format
         *
         * @param deserializer The deserializer object to read from
         */
⋮----
/**
         * @brief Get the FlatBuffers schema for this component type
         *
         * @return Pointer to the schema definition for zero-copy serialization
         */
static std::unique_ptr<FlatBuffers::Schema> getSchema();
⋮----
/**
         * @brief Set the entity that owns this component
         *
         * @param owner The entity ID of the owner
         */
void setOwner(EntityID owner);
⋮----
/**
         * @brief Get the entity that owns this component
         *
         * @return The entity ID of the owner
         */
EntityID getOwner() const
⋮----
/**
         * @brief Get the component version
         *
         * @return The version number for backward compatibility
         */
uint32_t getVersion() const
⋮----
/**
         * @brief Set the component version
         *
         * @param version The version number to set
         */
void setVersion(uint32_t version)
⋮----
/**
         * @brief Enable or disable the component
         *
         * @param enabled True to enable, false to disable
         */
void setEnabled(bool enabled);
⋮----
/**
         * @brief Check if the component is enabled
         *
         * @return True if the component is enabled
         */
bool isEnabled() const;
⋮----
EntityID m_owner;       ///< ID of the entity that owns this component
uint32_t m_version;     ///< The component version for backward compatibility
bool m_enabled;         ///< Flag indicating if this component is enabled
⋮----
/**
     * @brief Macro for component type definition
     *
     * Use this macro in derived component classes to implement
     * the required type identification and schema methods.
     *
     * @param TypeName The name of the component class
     * @param TypeID The unique ID for this component type
     */
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/ComponentPool.h">
// -------------------------------------------------------------------------
// ComponentPool.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Interface for type-erased component pool
     */
⋮----
/**
         * @brief Virtual destructor
         */
⋮----
/**
         * @brief Notifies the pool that an entity has been destroyed
         * @param entity The entity ID that was destroyed
         */
virtual void entityDestroyed(EntityID entity) = 0;
⋮----
/**
         * @brief Check if the entity has a component in this pool
         * @param entity Entity ID to check
         * @return True if the entity has a component in this pool
         */
virtual bool has(EntityID entity) const = 0;
⋮----
/**
         * @brief Gets a raw pointer to the component for the specified entity
         * @param entity The entity ID to get the component for
         * @return Raw pointer to the component
         */
virtual void* getRaw(EntityID entity) = 0;
⋮----
/**
         * @brief Gets a const raw pointer to the component for the specified entity
         * @param entity The entity ID to get the component for
         * @return Const raw pointer to the component
         */
virtual const void* getRaw(EntityID entity) const = 0;
⋮----
/**
         * @brief Gets the number of components in the pool
         * @return The number of active components
         */
virtual size_t size() const = 0;
⋮----
/**
         * @brief Serializes all components in the pool
         * @param serializer The serializer to use
         */
⋮----
/**
         * @brief Deserializes all components in the pool
         * @param deserializer The deserializer to use
         */
⋮----
/**
         * @brief Serializes a specific component
         * @param entity The entity ID whose component should be serialized
         * @param serializer The serializer to use
         */
virtual void serializeComponent(EntityID entity, Serializer& serializer) = 0;
⋮----
/**
         * @brief Deserializes a component for a specific entity
         * @param entity The entity ID to deserialize a component for
         * @param deserializer The deserializer to use
         */
virtual void deserializeComponent(EntityID entity, Deserializer& deserializer) = 0;
⋮----
/**
         * @brief Checks if components in this pool should be serialized
         * @return True if components should be serialized
         */
virtual bool isSerializable() const = 0;
⋮----
/**
     * @brief Type-safe storage for components with efficient memory management and thread safety
     *
     * Thread safety guarantees:
     * - Component creation/destruction is thread-safe
     * - Component access is thread-safe
     * - Multiple readers can access components concurrently
     * - Writers obtain exclusive access to the component pool
     *
     * @tparam T Component type to store
     */
⋮----
/**
         * @brief Constructs a component pool
         * @param isSerializable Whether components in this pool should be serialized
         */
⋮----
// Preallocate storage to reduce reallocations
⋮----
/**
         * @brief Destructor - cleans up all components
         */
⋮----
/**
         * @brief Creates a component for the specified entity using default constructor
         * @param entity The entity ID to create a component for
         * @return Reference to the created component
         * @thread_safety Thread-safe, acquires pool lock
         * @throws std::runtime_error If the entity already has a component of this type
         */
⋮----
// Get next available index (reuse or create new)
⋮----
// If we're adding a new component at the end
⋮----
// Default construct the component in-place
⋮----
// Default construct in existing slot
⋮----
// Map entity to this index
⋮----
/**
         * @brief Creates a component for the specified entity with constructor arguments
         * @param entity The entity ID to create a component for
         * @param args Constructor arguments for the component
         * @return Reference to the created component
         * @thread_safety Thread-safe, acquires pool lock
         * @throws std::runtime_error If the entity already has a component of this type
         */
⋮----
// Forward arguments to emplace_back for in-place construction
⋮----
// Perfect-forward constructor arguments to existing slot
⋮----
/**
         * @brief Destroys the component for the specified entity
         * @param entity The entity ID whose component should be destroyed
         * @return True if a component was destroyed, false if the entity had no component
         * @thread_safety Thread-safe, acquires pool lock
         */
bool destroy(EntityID entity)
⋮----
return false; // Entity doesn't have a component in this pool
⋮----
// Get the component index
⋮----
// Add index to free indices queue for reuse
⋮----
// Remove entity from map
⋮----
/**
         * @brief Gets the component for the specified entity
         * @param entity The entity ID to get the component for
         * @return Reference to the component
         * @thread_safety Thread-safe, acquires shared pool lock
         * @throws std::out_of_range If the entity has no component of this type
         */
⋮----
/**
         * @brief Gets the component for the specified entity (const version)
         * @param entity The entity ID to get the component for
         * @return Const reference to the component
         * @thread_safety Thread-safe, acquires shared pool lock
         * @throws std::out_of_range If the entity has no component of this type
         */
const T& get(EntityID entity) const
⋮----
/**
         * @brief Checks if the entity has a component in this pool
         * @param entity The entity ID to check
         * @return True if the entity has a component in this pool, false otherwise
         * @thread_safety Thread-safe, acquires shared pool lock
         */
bool has(EntityID entity) const override
⋮----
/**
         * @brief Notifies the pool that an entity has been destroyed
         * @param entity The entity ID that was destroyed
         * @thread_safety Thread-safe, acquires pool lock
         */
void entityDestroyed(EntityID entity) override
⋮----
/**
         * @brief Gets a raw pointer to the component for the specified entity
         * @param entity The entity ID to get the component for
         * @return Raw pointer to the component
         * @thread_safety Thread-safe, acquires shared pool lock
         * @throws std::out_of_range If the entity has no component of this type
         */
void* getRaw(EntityID entity) override
⋮----
/**
         * @brief Gets a const raw pointer to the component for the specified entity
         * @param entity The entity ID to get the component for
         * @return Const raw pointer to the component
         * @thread_safety Thread-safe, acquires shared pool lock
         * @throws std::out_of_range If the entity has no component of this type
         */
const void* getRaw(EntityID entity) const override
⋮----
/**
         * @brief Gets the number of components in the pool
         * @return The number of components
         * @thread_safety Thread-safe, acquires shared pool lock
         */
size_t size() const override
⋮----
/**
         * @brief Serializes all components in the pool
         * @param serializer The serializer to use
         * @thread_safety Thread-safe, acquires shared pool lock
         */
void serializeAll(Serializer& serializer) override
⋮----
// Serialize number of components
⋮----
// Serialize each entity-component pair
⋮----
// Write entity ID
serializer.writeUInt32(entity);
⋮----
// Release the shared lock temporarily during serialization
// to avoid blocking other readers while serializing
⋮----
// Serialize the component
⋮----
// Reacquire the shared lock
⋮----
/**
         * @brief Deserializes all components in the pool
         * @param deserializer The deserializer to use
         * @thread_safety Thread-safe, acquires exclusive pool lock
         */
⋮----
// Clear existing components
⋮----
std::queue<size_t>().swap(m_freeIndices); // Clear free indices
⋮----
// Deserialize number of components
⋮----
// Preallocate space
⋮----
// Deserialize each entity-component pair
⋮----
// Read entity ID
⋮----
// Create a new component and deserialize into it
⋮----
// Release the lock temporarily during deserialization
⋮----
// Deserialize component - this might acquire locks internally
⋮----
// Reacquire the lock
⋮----
/**
         * @brief Serializes a component for a specific entity
         * @param entity The entity ID whose component should be serialized
         * @param serializer The serializer to use
         * @thread_safety Thread-safe, acquires shared pool lock
         */
void serializeComponent(EntityID entity, Serializer& serializer) override
⋮----
// Release the lock during serialization to avoid blocking other operations
⋮----
// Serialize component data
⋮----
/**
         * @brief Deserializes a component for a specific entity
         * @param entity The entity ID to deserialize a component for
         * @param deserializer The deserializer to use
         * @thread_safety Thread-safe, acquires exclusive pool lock
         */
void deserializeComponent(EntityID entity, Deserializer& deserializer) override
⋮----
// Get or create the component
⋮----
// Release the lock during deserialization
⋮----
// Deserialize component data
⋮----
/**
         * @brief Checks if components in this pool should be serialized
         * @return True if components should be serialized
         * @thread_safety Thread-safe, no locks required (immutable after construction)
         */
bool isSerializable() const override
⋮----
/**
         * @brief Executes a function for each entity-component pair in the pool
         * @param func The function to execute
         * @thread_safety Thread-safe if func is thread-safe, acquires shared pool lock
         */
void forEach(const std::function<void(EntityID, T&)>& func)
⋮----
func(entity, m_components[index]);
⋮----
/**
         * @brief Gets the component data vector for advanced operations
         * @return Reference to the component vector
         * @thread_safety NOT thread-safe, intended for advanced usage with external synchronization
         * @note This method bypasses internal locks and should be used with caution
         */
⋮----
/**
         * @brief Gets the component data vector (const version)
         * @return Const reference to the component vector
         * @thread_safety NOT thread-safe, intended for advanced usage with external synchronization
         * @note This method bypasses internal locks and should be used with caution
         */
const std::vector<T>& unsafeGetData() const
⋮----
std::vector<T> m_components;                  ///< Dense array of components
std::map<EntityID, size_t> m_entityMap;       ///< Maps entity IDs to component indices
std::queue<size_t> m_freeIndices;             ///< Queue of free indices for reuse
bool m_isSerializable;                        ///< Flag indicating if components should be serialized
⋮----
// Mutex for thread safety
mutable std::shared_mutex m_poolMutex;        ///< Mutex for thread-safe pool access
⋮----
/**
         * @brief Gets the next available index for a component
         * @return The index to use for a new component
         * @note Assumes m_poolMutex is already locked
         */
size_t getNextAvailableIndex()
⋮----
// Reuse an existing slot
⋮----
// Return the next index (will be at the end of the vector)
⋮----
/**
         * @brief Internal method to create a component without acquiring the lock
         * @param entity The entity ID to create a component for
         * @return Reference to the created component
         * @note Assumes m_poolMutex is already locked
         */
⋮----
/**
         * @brief Implementation for serializing a component
         * @param entity The entity ID whose component should be serialized
         * @param index The index of the component in the components array
         * @param serializer The serializer to use
         */
void serializeComponentImpl(EntityID entity, size_t index, Serializer& serializer)
⋮----
// For components with standard serialization support
⋮----
// Need to get a copy or lock to ensure thread safety
⋮----
// Serialize the copy
⋮----
// For simple POD types
⋮----
// For other types, you need a custom serialization approach
⋮----
/**
         * @brief Implementation for deserializing a component
         * @param component Reference to the component to deserialize into
         * @param deserializer The deserializer to use
         */
⋮----
// For components with standard deserialization support
⋮----
else if constexpr (std::is_trivially_copyable_v<T>)
⋮----
// For other types, you need a custom deserialization approach
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/ComponentRegistry.h">
// -------------------------------------------------------------------------
// ComponentRegistry.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Central registry for component types and factories
     * 
     * Manages component type registration, component creation,
     * pool management, and serialization settings.
     */
⋮----
/**
         * @brief Function type for component creation
         */
⋮----
/**
         * @brief Get the singleton instance of the registry
         * @return Reference to the registry
         */
static ComponentRegistry& getInstance();
⋮----
/**
         * @brief Register a component type
         * @tparam T The component type to register
         * @param name Optional name for the component type (defaults to demangled type name)
         * @return The component type ID
         */
⋮----
/**
         * @brief Get or register the component type ID
         * @tparam T The component type
         * @return The component type ID
         */
⋮----
static ComponentTypeID getComponentTypeID();
⋮----
/**
         * @brief Get the component name for a component ID
         * @param typeID Component type ID
         * @return Name of the component type
         */
static std::string getComponentName(ComponentTypeID typeID);
⋮----
/**
         * @brief Get the component type ID for a name
         * @param name Name of the component type
         * @return Component type ID, or 0 if not found
         */
static ComponentTypeID getComponentTypeID(const std::string& name);
⋮----
/**
         * @brief Create a component by type ID
         * @param typeID Component type ID
         * @return Unique pointer to created component
         */
static std::unique_ptr<Component> createComponent(ComponentTypeID typeID);
⋮----
/**
         * @brief Create a component by name
         * @param name Name of the component type
         * @return Unique pointer to created component
         */
static std::unique_ptr<Component> createComponent(const std::string& name);
⋮----
/**
         * @brief Check if a component type is serializable
         * @param typeID Component type ID
         * @return True if serializable, false otherwise
         */
static bool isSerializable(ComponentTypeID typeID);
⋮----
/**
         * @brief Set whether a component type is serializable
         * @param typeID Component type ID
         * @param serializable True to enable serialization, false to disable
         */
static void setSerializable(ComponentTypeID typeID, bool serializable);
⋮----
/**
         * @brief Get the component pool for a component type
         * @tparam T The component type
         * @return Pointer to the component pool
         */
⋮----
// Private constructor & destructor for singleton
⋮----
// Static data members
⋮----
/**
         * @brief Helper to get demangled type name
         * @tparam T Type to get name for
         * @return Demangled name of the type
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
// Check if already registered
⋮----
// Verify we're not exceeding maximum component types
⋮----
// Assign new type ID
⋮----
// Get component name (use provided or generate from type)
⋮----
// Register component
⋮----
// Register factory function
⋮----
// Default to serializable
⋮----
// If not registered, register it now
⋮----
// Check if pool exists
⋮----
// Create a new pool
⋮----
std::string ComponentRegistry::getDemangledTypeName()
⋮----
// Simple demangling for readability
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Deserializer.h">
// -------------------------------------------------------------------------
// Deserializer.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Deserializer class for binary deserialization with backward compatibility
     *
     * This class provides functionality to read binary data from a stream with support for:
     * - Cross-platform endianness handling
     * - Entity reference resolution via UUID lookup
     * - Hierarchical object composition with nested begin/end markers
     * - Array deserialization with size tracking
     * - Version compatibility for backward compatibility
     * - Integration with FlatBuffers for efficient binary deserialization
     */
⋮----
/**
         * @brief Constructor for Deserializer
         * @param stream Input stream containing serialized data
         * @param byteOrder Byte order to use for deserialization (default: Native)
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Set the registry for entity reference resolution
         * @param registry Weak pointer to entity registry
         */
void setRegistry(std::weak_ptr<Registry> registry);
⋮----
/**
         * @brief Read a primitive value from the stream
         * @tparam T Arithmetic type to read
         * @param value Reference to store the read value
         */
⋮----
/**
         * @brief Read a boolean value from the stream
         * @param value Reference to store the read boolean
         */
void readBool(bool& value);
⋮----
/**
         * @brief Read a 16-bit integer value from the stream
         * @param value Reference to store the read integer
         */
void readInt16(int16_t& value);
⋮----
/**
         * @brief Read an unsigned 16-bit integer value from the stream
         * @param value Reference to store the read unsigned integer
         */
void readUInt16(uint16_t& value);
⋮----
/**
         * @brief Read a 32-bit integer value from the stream
         * @param value Reference to store the read integer
         */
void readInt32(int32_t& value);
⋮----
/**
         * @brief Read an unsigned 32-bit integer value from the stream
         * @param value Reference to store the read unsigned integer
         */
void readUInt32(uint32_t& value);
⋮----
/**
         * @brief Read a 64-bit integer value from the stream
         * @param value Reference to store the read integer
         */
void readInt64(int64_t& value);
⋮----
/**
         * @brief Read an unsigned 64-bit integer value from the stream
         * @param value Reference to store the read unsigned integer
         */
void readUInt64(uint64_t& value);
⋮----
/**
         * @brief Read a float value from the stream
         * @param value Reference to store the read float
         */
void readFloat(float& value);
⋮----
/**
         * @brief Read a double value from the stream
         * @param value Reference to store the read double
         */
void readDouble(double& value);
⋮----
/**
         * @brief Read a string value from the stream
         * @param value Reference to store the read string
         */
void readString(std::string& value);
⋮----
/**
         * @brief Read raw bytes from the stream
         * @param data Pointer to the buffer to store the data
         * @param size Number of bytes to read
         */
void readBytes(void* data, size_t size);
⋮----
/**
         * @brief Read an entity reference and resolve it to an EntityID
         * @return The resolved EntityID
         */
EntityID readEntityRef();
⋮----
/**
         * @brief Read a 2D vector from the stream
         * @param value Reference to store the read vector
         */
void readVec2(glm::vec2& value);
⋮----
/**
         * @brief Read a 3D vector from the stream
         * @param value Reference to store the read vector
         */
void readVec3(glm::vec3& value);
⋮----
/**
         * @brief Read a 4D vector from the stream
         * @param value Reference to store the read vector
         */
void readVec4(glm::vec4& value);
⋮----
/**
         * @brief Read a quaternion from the stream
         * @param value Reference to store the read quaternion
         */
void readQuat(glm::quat& value);
⋮----
/**
         * @brief Read a 4x4 matrix from the stream
         * @param value Reference to store the read matrix
         */
void readMat4(glm::mat4& value);
⋮----
/**
         * @brief Begin reading a nested object
         * @param name Expected name of the object
         * @return True if object exists and was begun successfully, false otherwise
         */
bool beginObject(const std::string& name);
⋮----
/**
         * @brief End reading a nested object
         */
void endObject();
⋮----
/**
         * @brief Begin reading an array
         * @param name Expected name of the array
         * @param size Reference to store the array size
         * @return True if array exists and was begun successfully, false otherwise
         */
bool beginArray(const std::string& name, size_t& size);
⋮----
/**
         * @brief End reading an array
         */
void endArray();
⋮----
/**
         * @brief Read a FlatBuffer from the stream
         * @param size Reference to store the buffer size
         * @return Pointer to the buffer data (owned by the deserializer)
         */
const uint8_t* readFlatBuffer(size_t& size);
⋮----
/**
         * @brief Get the current position in the stream
         * @return Current position in bytes
         */
size_t getPosition() const;
⋮----
/**
         * @brief Align the stream to the specified boundary
         * @param alignment Alignment boundary in bytes
         */
void align(size_t alignment);
⋮----
/**
         * @brief Check if the end of the stream has been reached
         * @return True if at the end of stream, false otherwise
         */
bool isEndOfStream() const;
⋮----
/**
         * @brief Read version information from the stream
         * @return Version number
         */
uint32_t readVersion();
⋮----
/**
         * @brief Check if an error has occurred during deserialization
         * @return True if an error has occurred, false otherwise
         */
bool hasError() const;
⋮----
/**
         * @brief Get the error message if an error has occurred
         * @return Error message string
         */
std::string getErrorMessage() const;
⋮----
std::istream& m_stream;                  //!< Reference to the input stream
std::weak_ptr<Registry> m_registry;      //!< Weak reference to entity registry
std::vector<std::string> m_objectStack;  //!< Stack of object names for context
ByteOrder m_byteOrder;                   //!< Byte order to use for deserialization
bool m_hasError;                         //!< Error flag
std::string m_errorMessage;              //!< Error message
std::vector<uint8_t> m_flatBufferData;   //!< Storage for FlatBuffer data
⋮----
/**
         * @brief Read raw bytes from the stream without endianness conversion
         * @param data Pointer to the buffer to store the data
         * @param size Number of bytes to read
         */
void readRaw(void* data, size_t size);
⋮----
/**
         * @brief Convert the endianness of a value if needed
         * @tparam T Type of the value to convert
         * @param value Reference to the value to convert
         */
⋮----
void convertEndianness(T& value)
⋮----
// Implementation depends on the type
⋮----
// No conversion needed for single byte
⋮----
/**
         * @brief Determine if byte swapping is needed based on the current byte order
         * @return True if byte swapping is needed, false otherwise
         */
bool needByteSwap() const;
⋮----
/**
         * @brief Set an error message
         * @param message Error message to set
         */
void setError(const std::string& message);
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Entity.h">
// -------------------------------------------------------------------------
// Entity.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Lightweight entity handle with component and serialization operations
     */
⋮----
/**
         * @brief Default constructor creates a null entity
         */
⋮----
/**
         * @brief Constructor with ID and registry reference
         * @param id The entity ID
         * @param registry Weak reference to the registry
         */
⋮----
/**
         * @brief Check if the entity is valid
         * @return True if the entity is valid and exists in the registry
         */
bool isValid() const;
⋮----
/**
         * @brief Destroy the entity and all its components
         */
void destroy();
⋮----
/**
         * @brief Add a component to the entity
         * @tparam T Component type
         * @tparam Args Constructor argument types
         * @param args Constructor arguments
         * @return Reference to the created component
         */
⋮----
T& addComponent(Args&&... args);
⋮----
/**
         * @brief Remove a component from the entity
         * @tparam T Component type to remove
         * @return True if component was removed
         */
⋮----
bool removeComponent();
⋮----
/**
         * @brief Get a component from the entity
         * @tparam T Component type to retrieve
         * @return Reference to the component
         */
⋮----
T& getComponent();
⋮----
/**
         * @brief Get a const component from the entity
         * @tparam T Component type to retrieve
         * @return Const reference to the component
         */
⋮----
const T& getComponent() const;
⋮----
/**
         * @brief Check if the entity has a specific component
         * @tparam T Component type to check for
         * @return True if the entity has the component
         */
⋮----
bool hasComponent() const;
⋮----
/**
         * @brief Get the component mask for this entity
         * @return The component mask
         */
const ComponentMask& getComponentMask() const;
⋮----
/**
         * @brief Serialize the entity to the given serializer
         * @param serializer The serializer to use
         */
void serialize(Serializer& serializer);
⋮----
/**
         * @brief Deserialize the entity from the given deserializer
         * @param deserializer The deserializer to use
         */
void deserialize(Deserializer& deserializer);
⋮----
/**
         * @brief Get the entity's UUID
         * @return The UUID of the entity
         */
UUID getUUID() const;
⋮----
/**
         * @brief Set the entity's UUID
         * @param uuid The UUID to set
         */
void setUUID(const UUID& uuid);
⋮----
/**
         * @brief Enable or disable UUID generation for this entity
         * @param needsUUID True to enable UUID generation
         */
void setNeedsUUID(bool needsUUID);
⋮----
/**
         * @brief Check if the entity has UUID generation enabled
         * @return True if UUID generation is enabled
         */
bool needsUUID() const;
⋮----
/**
         * @brief Set the entity's name
         * @param name The name to set
         */
void setName(const std::string& name);
⋮----
/**
         * @brief Get the entity's name
         * @return The name of the entity
         */
std::string getName() const;
⋮----
/**
         * @brief Add a tag to the entity
         * @param tag The tag to add
         */
void addTag(const std::string& tag);
⋮----
/**
         * @brief Remove a tag from the entity
         * @param tag The tag to remove
         */
void removeTag(const std::string& tag);
⋮----
/**
         * @brief Check if the entity has a tag
         * @param tag The tag to check for
         * @return True if the entity has the tag
         */
bool hasTag(const std::string& tag) const;
⋮----
/**
         * @brief Set the entity's parent
         * @param parent The parent entity
         */
void setParent(Entity parent);
⋮----
/**
         * @brief Get the entity's parent
         * @return The parent entity
         */
Entity getParent() const;
⋮----
/**
         * @brief Get the entity's children
         * @return Vector of child entities
         */
std::vector<Entity> getChildren() const;
⋮----
/**
         * @brief Set the entity's active state
         * @param active True to set active, false to set inactive
         */
void setActive(bool active);
⋮----
/**
         * @brief Check if the entity is active
         * @return True if the entity is active
         */
bool isActive() const;
⋮----
/**
         * @brief Get the registry the entity belongs to
         * @return Shared pointer to the registry
         */
std::shared_ptr<Registry> getRegistry() const;
⋮----
/**
         * @brief Get the entity's ID
         * @return The ID of the entity
         */
EntityID getID() const
⋮----
/**
         * @brief Equality comparison
         * @param other Entity to compare with
         * @return True if entities are equal
         */
⋮----
/**
         * @brief Inequality comparison
         * @param other Entity to compare with
         * @return True if entities are not equal
         */
⋮----
/**
         * @brief Check if the entity is null
         * @return True if this is a null entity
         */
bool isNull() const;
⋮----
/**
         * @brief Create a null entity
         * @return A null entity
         */
static Entity Null();
⋮----
EntityID m_id;                      ///< The entity's ID
std::weak_ptr<Registry> m_registry; ///< Weak reference to the registry
⋮----
// Template implementations
⋮----
T& Entity::addComponent(Args&&... args)
⋮----
} // namespace PixelCraft::ECS
⋮----
// Hash function for using Entity in unordered containers
⋮----
size_t operator()(const PixelCraft::ECS::Entity& entity) const
</file>

<file path="include/ECS/EntityMetadata.h">
// -------------------------------------------------------------------------
// EntityMetadata.h
⋮----
/**
     * @brief Container for entity metadata
     * 
     * Provides centralized storage for all entity-related data including:
     * - UUIDs
     * - Names
     * - Tags
     * - Parent-child relationships
     * - Active status
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Register a new entity
         * @param entity Entity ID to register
         * @param generateUUID Whether to generate a UUID for this entity
         * @thread_safety Thread-safe, acquires metadata lock
         */
void registerEntity(EntityID entity, bool generateUUID = false);
⋮----
/**
         * @brief Remove an entity and all its metadata
         * @param entity Entity ID to remove
         * @thread_safety Thread-safe, acquires metadata lock
         */
void removeEntity(EntityID entity);
⋮----
/**
         * @brief Clear all entity metadata
         * @thread_safety Thread-safe, acquires metadata lock
         */
void clear();
⋮----
/**
         * @brief Set the name of an entity
         * @param entity Entity ID to name
         * @param name Name to assign
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool setName(EntityID entity, const std::string& name);
⋮----
/**
         * @brief Get the name of an entity
         * @param entity Entity ID to get the name for
         * @return Result containing entity name or error
         * @thread_safety Thread-safe, acquires metadata lock
         */
⋮----
/**
         * @brief Set the UUID for an entity
         * @param entity Entity ID to set the UUID for
         * @param uuid UUID to assign
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool setUUID(EntityID entity, const UUID& uuid);
⋮----
/**
         * @brief Get the UUID for an entity
         * @param entity Entity ID to get the UUID for
         * @return Result containing UUID or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
UUID getUUID(EntityID entity) const;
⋮----
/**
         * @brief Get an entity by its UUID
         * @param uuid UUID to look up
         * @return Result containing entity ID or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
EntityID getEntityByUUID(const UUID& uuid) const;
⋮----
/**
         * @brief Find an entity by name
         * @param name Name to search for
         * @return Result containing entity ID or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
EntityID findEntityByName(const std::string& name) const;
⋮----
/**
         * @brief Add a tag to an entity
         * @param entity Entity ID to tag
         * @param tag Tag to add
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool addTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Remove a tag from an entity
         * @param entity Entity ID to untag
         * @param tag Tag to remove
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool removeTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Check if an entity has a tag
         * @param entity Entity ID to check
         * @param tag Tag to check for
         * @return Result containing boolean or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
bool hasTag(EntityID entity, const std::string& tag) const;
⋮----
/**
         * @brief Find entities by tag
         * @param tag Tag to search for
         * @return Vector of entity IDs with the tag
         */
⋮----
/**
         * @brief Get all tags for an entity
         * @param entity Entity ID to get tags for
         * @return Vector of tags assigned to the entity
         * @thread_safety Thread-safe, acquires shared mutex
         */
⋮----
/**
         * @brief Enable or disable UUID generation for an entity
         * @param entity Entity ID
         * @param needsUUID True to enable UUID generation
         */
void setEntityNeedsUUID(EntityID entity, bool needsUUID);
⋮----
/**
         * @brief Check if an entity has UUID generation enabled
         * @param entity Entity ID
         * @return True if UUID generation is enabled
         */
bool entityNeedsUUID(EntityID entity) const;
⋮----
/**
         * @brief Set an entity's parent
         * @param entity Entity ID
         * @param parent Parent entity ID
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool setParent(EntityID entity, EntityID parent);
⋮----
/**
         * @brief Get an entity's parent
         * @param entity Entity ID
         * @return Result containing parent entity ID or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
EntityID getParent(EntityID entity) const;
⋮----
/**
         * @brief Get an entity's children
         * @param entity Entity ID
         * @return Result containing vector of child entity IDs or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
⋮----
/**
         * @brief Set an entity's active state
         * @param entity Entity ID
         * @param active True to set active, false to set inactive
         * @return Result<void> indicating success or failure
         * @thread_safety Thread-safe, acquires metadata lock
         */
bool setActive(EntityID entity, bool active);
⋮----
/**
         * @brief Check if an entity is active
         * @param entity Entity ID
         * @return Result containing boolean or error
         * @thread_safety Thread-safe, acquires shared metadata lock
         */
bool isActive(EntityID entity) const;
⋮----
// Thread safety
⋮----
// Entity name storage
⋮----
// UUID management
⋮----
// Tag storage
⋮----
// Hierarchy storage
⋮----
// Active state storage
std::set<EntityID> m_inactiveEntities; // Entities not in this set are active
⋮----
/**
         * @brief Check if an entity exists
         * @param entity Entity ID to check
         * @return True if the entity exists in metadata
         * @thread_safety Assumes metadata mutex is already locked
         */
bool entityExists(EntityID entity) const;
⋮----
/**
         * @brief Generate a UUID for an entity
         * @param entity Entity ID to generate UUID for
         * @thread_safety Assumes metadata mutex is already locked
         */
void generateUUID(EntityID entity);
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/FlatBufferSerializer.h">
// -------------------------------------------------------------------------
// FlatBufferSerializer.h
⋮----
// Forward declarations
⋮----
//class NavigationAgentComponent;
//class AnimatorComponent;
⋮----
/**
     * @brief Zero-copy serialization using FlatBuffers for ECS components
     * 
     * FlatBufferSerializer provides an efficient serialization mechanism using FlatBuffers
     * library, enabling zero-copy deserialization for optimal performance. It manages
     * buffer creation, schema registration, and component type registration.
     */
⋮----
/**
         * @brief Constructor that initializes the serializer with default settings
         */
⋮----
/**
         * @brief Destructor that cleans up resources
         */
⋮----
/**
         * @brief Get a reference to the FlatBufferBuilder for creating new serialized data
         * @return Reference to the internal FlatBufferBuilder
         */
⋮----
/**
         * @brief Reset the FlatBufferBuilder to clear any existing data
         */
void resetBuilder();
⋮----
/**
         * @brief Finalize the buffer with the given file identifier
         * @param identifier 4-character identifier string for buffer verification
         * @return Serialized data as a byte vector
         */
⋮----
/**
         * @brief Verify a buffer's integrity and type
         * @param buffer Pointer to the buffer data
         * @param size Size of the buffer in bytes
         * @param expectedIdentifier Optional expected file identifier for type checking
         * @return True if the buffer is valid
         */
bool verifyBuffer(const uint8_t* buffer, size_t size, const std::string& expectedIdentifier = "");
⋮----
// Specialized serialization methods for each component type
⋮----
/**
         * @brief Specialized method to serialize a TransformComponent
         * @param component TransformComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize a CameraComponent
         * @param component CameraComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize a MeshRendererComponent
         * @param component MeshRendererComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize a LightComponent
         * @param component LightComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize a RigidBodyComponent
         * @param component RigidBodyComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize a ColliderComponent
         * @param component ColliderComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize an AudioSourceComponent
         * @param component AudioSourceComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize an ParticleSystemComponent
         * @param component ParticleSystemComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Specialized method to serialize an AnimatorComponent
         * @param component AnimatorComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
//flatbuffers::Offset<void> serializeAnimatorComponent(const AnimatorComponent& component);
⋮----
/**
         * @brief Specialized method to serialize a NavigationAgentComponent
         * @param component NavigationAgentComponent to serialize
         * @return Offset to the serialized data in the buffer
         */
//flatbuffers::Offset<void> serializeNavigationAgentComponent(const NavigationAgentComponent& component);
⋮----
// Specialized deserialization methods for each component type
/**
         * @brief Specialized method to deserialize a TransformComponent
         * @param bufferData Pointer to the serialized data
         * @param component TransformComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeTransformComponent(const void* bufferData, TransformComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a CameraComponent
         * @param bufferData Pointer to the serialized data
         * @param component CameraComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeCameraComponent(const void* bufferData, CameraComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a MeshRendererComponent
         * @param bufferData Pointer to the serialized data
         * @param component MeshRendererComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeMeshRendererComponent(const void* bufferData, MeshRendererComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a LightComponent
         * @param bufferData Pointer to the serialized data
         * @param component LightComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeLightComponent(const void* bufferData, LightComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a RigidBodyComponent
         * @param bufferData Pointer to the serialized data
         * @param component RigidBodyComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeRigidBodyComponent(const void* bufferData, RigidBodyComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a ColliderComponent
         * @param bufferData Pointer to the serialized data
         * @param component ColliderComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeColliderComponent(const void* bufferData, ColliderComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize an AudioSourceComponent
         * @param bufferData Pointer to the serialized data
         * @param component AudioSourceComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeAudioSourceComponent(const void* bufferData, AudioSourceComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize an ParticleSystemComponent
         * @param bufferData Pointer to the serialized data
         * @param component ParticleSystemComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
bool deserializeParticleSystemComponent(const void* bufferData, ParticleSystemComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize an AnimatorComponent
         * @param bufferData Pointer to the serialized data
         * @param component AnimatorComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
//bool deserializeAnimatorComponent(const void* bufferData, AnimatorComponent& component);
⋮----
/**
         * @brief Specialized method to deserialize a NavigationAgentComponent
         * @param bufferData Pointer to the serialized data
         * @param component NavigationAgentComponent to populate with deserialized data
         * @return True if deserialization was successful
         */
//bool deserializeNavigationAgentComponent(const void* bufferData, NavigationAgentComponent& component);
⋮----
// Generic template methods
/**
         * @brief Serialize a component to a FlatBuffer
         * @tparam T Component type to serialize
         * @param component Component instance to serialize
         * @return Offset to the serialized data in the buffer
         */
⋮----
/**
         * @brief Deserialize a component from a FlatBuffer
         * @tparam T Component type to deserialize
         * @param bufferData Pointer to the serialized data
         * @param component Component instance to populate with deserialized data
         * @return True if deserialization was successful
         */
⋮----
// Template method implementations must be in the header file
⋮----
// Verify the buffer first
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Registry.h">
// -------------------------------------------------------------------------
// Registry.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Thread safety documentation for Registry
     *
     * The Registry class is thread-safe for the following operations:
     * - Multiple readers can access entity metadata concurrently
     * - Multiple readers can access components concurrently
     * - Writers obtain exclusive access to the registry for entity creation/destruction
     * - Component access obtains locks on specific component pools
     *
     * Locking strategy uses shared_mutex for read-heavy operations and
     * regular mutex for entity creation/destruction.
     *
     * Thread safety guarantees:
     * - Entity creation/destruction is thread-safe
     * - Component addition/removal is thread-safe
     * - Entity metadata operations are thread-safe
     * - Component queries are thread-safe
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Create a new entity
         * @param generateUUID Whether to generate a UUID for this entity
         * @return The ID of the newly created entity
         * @thread_safety Thread-safe, acquires entity lock
         */
EntityID createEntity(bool generateUUID = false);
⋮----
/**
         * @brief Create a new entity with name
         * @param name The name of the entity
         * @param generateUUID Whether to generate a UUID for this entity
         * @return The ID of the newly created entity
         * @thread_safety Thread-safe, acquires entity lock
         */
EntityID createEntity(const std::string& name, bool generateUUID = true);
⋮----
/**
         * @brief Destroy an entity and all its components
         * @param entity The entity ID to destroy
         * @return True if the entity was successfully destroyed
         * @thread_safety Thread-safe, acquires entity and component locks
         */
bool destroyEntity(EntityID entity);
⋮----
/**
         * @brief Check if an entity is valid
         * @param entity The entity ID to check
         * @return True if the entity exists in the registry
         * @thread_safety Thread-safe, acquires shared entity lock
         */
bool isValid(EntityID entity) const;
⋮----
/**
         * @brief Add a component to an entity
         * @tparam T Component type to add
         * @tparam Args Constructor argument types
         * @param entity Entity ID to add the component to
         * @param args Constructor arguments for the component
         * @return Reference to the added component
         * @thread_safety Thread-safe, acquires component lock
         */
⋮----
/**
         * @brief Remove a component from an entity
         * @tparam T Component type to remove
         * @param entity Entity ID to remove the component from
         * @return True if the component was removed successfully
         * @thread_safety Thread-safe, acquires component lock
         */
⋮----
/**
         * @brief Get a component from an entity
         * @tparam T Component type to get
         * @param entity Entity ID to get the component from
         * @return Reference to the component
         * @thread_safety Thread-safe, acquires shared component lock
         * @throws std::out_of_range if the entity doesn't have this component
         */
⋮----
/**
         * @brief Get a const component from an entity
         * @tparam T Component type to get
         * @param entity Entity ID to get the component from
         * @return Const reference to the component
         * @thread_safety Thread-safe, acquires shared component lock
         * @throws std::out_of_range if the entity doesn't have this component
         */
⋮----
/**
         * @brief Check if an entity has a component
         * @tparam T Component type to check for
         * @param entity Entity ID to check
         * @return True if the entity has the component
         * @thread_safety Thread-safe, acquires shared component lock
         */
⋮----
/**
         * @brief Get a view of entities with the specified component types
         * @tparam Components Component types to include in the view
         * @return View of entities with the specified components
         * @thread_safety Thread-safe, acquires shared component lock
         */
⋮----
/**
         * @brief Serialize an entity to binary format
         * @param entity Entity ID to serialize
         * @param serializer Serializer to use
         * @thread_safety Thread-safe, acquires shared locks
         */
void serialize(EntityID entity, Serializer& serializer);
⋮----
/**
         * @brief Deserialize an entity from binary format
         * @param entity Entity ID to deserialize into
         * @param deserializer Deserializer to use
         * @thread_safety Thread-safe, acquires exclusive locks
         */
void deserialize(EntityID entity, Deserializer& deserializer);
⋮----
/**
         * @brief Serialize all entities to binary format
         * @param serializer Serializer to use
         * @thread_safety Thread-safe, acquires shared locks
         */
void serializeAll(Serializer& serializer);
⋮----
/**
         * @brief Deserialize all entities from binary format
         * @param deserializer Deserializer to use
         * @thread_safety Thread-safe, acquires exclusive locks
         */
void deserializeAll(Deserializer& deserializer);
⋮----
/**
         * @brief Get the UUID for an entity
         * @param entity Entity ID to get the UUID for
         * @return UUID of the entity
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
UUID getEntityUUID(EntityID entity) const;
⋮----
/**
         * @brief Set the UUID for an entity
         * @param entity Entity ID to set the UUID for
         * @param uuid UUID to assign
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
void setEntityUUID(EntityID entity, const UUID& uuid);
⋮----
/**
         * @brief Get an entity by its UUID
         * @param uuid UUID to look up
         * @return Entity ID, or 0 if not found
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
EntityID getEntityByUUID(const UUID& uuid) const;
⋮----
/**
         * @brief Set the name of an entity
         * @param entity Entity ID to name
         * @param name Name to assign
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
void setEntityName(EntityID entity, const std::string& name);
⋮----
/**
         * @brief Get the name of an entity
         * @param entity Entity ID to get the name for
         * @return Name of the entity, or empty string if not set
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
⋮----
/**
         * @brief Find an entity by name
         * @param name name to search for
         * @return Entity ID, or INVALID_ENTITY_ID if not found
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
EntityID findEntityByName(const std::string& name) const;
⋮----
/**
         * @brief Add a tag to an entity
         * @param entity Entity ID to tag
         * @param tag Tag to add
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
void addTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Remove a tag from an entity
         * @param entity Entity ID to untag
         * @param tag Tag to remove
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
void removeTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Check if an entity has a tag
         * @param entity Entity ID to check
         * @param tag Tag to check for
         * @return True if the entity has the tag
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
bool hasTag(EntityID entity, const std::string& tag) const;
⋮----
/**
         * @brief Find entities by tag
         * @param tag Tag to search for
         * @return Vector of entity IDs with the tag
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
⋮----
/**
         * @brief Enable or disable UUID generation for an entity
         * @param entity Entity ID
         * @param needsUUID Whether the entity needs a UUID
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
void setEntityNeedsUUID(EntityID entity, bool needsUUID);
⋮----
/**
         * @brief Check if an entity has UUID generation enabled
         * @param entity Entity ID
         * @return True if UUID generation is enabled
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
bool entityNeedsUUID(EntityID entity) const;
⋮----
/**
         * @brief Set an entity's parent
         * @param entity Entity ID
         * @param parent Parent entity ID
         * @return True if successful
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
bool setEntityParent(EntityID entity, EntityID parent);
⋮----
/**
         * @brief Get an entity's parent
         * @param entity Entity ID
         * @return Parent entity ID, or INVALID_ENTITY_ID if no parent
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
EntityID getEntityParent(EntityID entity) const;
⋮----
/**
         * @brief Get an entity's children
         * @param entity Entity ID
         * @return Vector of child entity IDs
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
⋮----
/**
         * @brief Set an entity's active state
         * @param entity Entity ID
         * @param active True to set active, false to set inactive
         * @return True if successful
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
bool setEntityActive(EntityID entity, bool active);
⋮----
/**
         * @brief Check if an entity is active
         * @param entity Entity ID
         * @return True if the entity is active
         * @thread_safety Thread-safe, delegates to EntityMetadata
         */
bool isEntityActive(EntityID entity) const;
⋮----
/**
         * @brief Get the entity metadata manager
         * @return Reference to the entity metadata manager
         * @thread_safety This method does not provide thread safety for the returned reference
         */
⋮----
/**
         * @brief Get the entity metadata manager (const version)
         * @return Const reference to the entity metadata manager
         * @thread_safety This method does not provide thread safety for the returned reference
         */
const EntityMetadata& getEntityMetadata() const;
⋮----
/**
         * @brief Get all entities
         * @return Const reference to the entity set
         * @thread_safety Thread-safe, acquires shared entity lock
         */
const std::vector<EntityID>& getEntities() const;
⋮----
/**
         * @brief Get the component mask for an entity
         * @param entity Entity ID
         * @return Component mask for the entity
         * @thread_safety Thread-safe, acquires shared component lock
         */
const ComponentMask& getEntityMask(EntityID entity) const;
⋮----
/**
         * @brief Get all component pools
         * @return Map of component type IDs to component pools
         * @thread_safety Thread-safe, acquires shared component lock
         */
const std::map<ComponentTypeID, std::shared_ptr<IComponentPool>>& getAllComponentPools() const;
⋮----
/**
         * @brief Get the number of entities in the registry
         * @return Entity count
         * @thread_safety Thread-safe, acquires shared entity lock
         */
size_t getEntityCount() const;
⋮----
/**
         * @brief Get raw component data for an entity
         * @param entity The entity ID to get the component for
         * @param typeID The component type ID
         * @return Pointer to component data or nullptr if not found
         * @thread_safety Thread-safe, acquires shared component lock
         */
void* getComponentRaw(EntityID entity, ComponentTypeID typeID);
⋮----
/**
         * @brief Remove all components from an entity
         * @param entity Entity ID
         * @thread_safety Thread-safe, acquires exclusive component lock
         */
void removeAllComponents(EntityID entity);
⋮----
// Mutex for entity operations
⋮----
// Mutex for component operations
⋮----
// Entity storage
⋮----
// Component storage
⋮----
// Entity metadata manager
⋮----
/**
         * @brief Get or create a component pool
         * @tparam T Component type
         * @return Shared pointer to the component pool
         * @thread_safety Assumes m_componentMutex is already locked
         */
⋮----
std::shared_ptr<ComponentPool<T>> getComponentPool();
⋮----
/**
         * @brief Register a component type
         * @tparam T Component type
         * @return Component type ID
         * @thread_safety Thread-safe, uses ComponentRegistry
         */
⋮----
static ComponentTypeID registerComponentType();
⋮----
// Template implementation for addComponent
⋮----
T& Registry::addComponent(EntityID entity, Args&&... args)
⋮----
// First validate entity with a shared lock
⋮----
// Register component type
⋮----
// Now acquire exclusive lock for component operations
⋮----
// Get or create the component pool
⋮----
// Create the component
⋮----
// Update the entity's component mask
⋮----
// Template implementation for removeComponent
⋮----
// Get the component type ID
⋮----
// Acquire exclusive lock for component operations
⋮----
// Get the component pool
⋮----
// Remove the component
⋮----
// Template implementation for getComponent
⋮----
// Acquire shared lock for component access
⋮----
// Template implementation for const getComponent
⋮----
// Need to cast away const here to use the pool
// This is safe because we return a const reference
⋮----
// Template implementation for hasComponent
⋮----
// Check if the entity's mask has the bit set
⋮----
// Template implementation for view
⋮----
// Template implementation for getComponentPool
⋮----
// Note: This assumes m_componentMutex is already locked
⋮----
// Check if pool exists
⋮----
// Create new pool
⋮----
// Template implementation for registerComponentType
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Scene.h">
// -------------------------------------------------------------------------
// Scene.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Scene class manages entity hierarchies and serialization in an ECS architecture
     *
     * The Scene is responsible for:
     * - Storing and managing a collection of entities
     * - Loading and saving scene data
     * - Handling prefab instantiation for entity templates
     * - Tracking important entities like the main camera
     * - Implementing chunk-based serialization for voxel worlds
     * - Supporting FlatBuffers for efficient binary serialization
     * - Enabling efficient tracking and saving of modified chunks
     */
⋮----
/**
         * @brief Constructor
         * @param name Optional name for the scene
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Load a scene from a file
         * @param path Path to the scene file
         * @return True if the scene was loaded successfully
         */
bool load(const std::string& path);
⋮----
/**
         * @brief Save a scene to a file
         * @param path Path where the scene will be saved
         * @return True if the scene was saved successfully
         */
bool save(const std::string& path);
⋮----
/**
         * @brief Instantiate a prefab as an entity in the scene
         * @param prefabPath Path to the prefab file
         * @return ID of the instantiated entity
         */
EntityID instantiate(const std::string& prefabPath);
⋮----
/**
         * @brief Find an entity by its name
         * @param name Name of the entity to find
         * @return ID of the found entity, or INVALID_ENTITY_ID if not found
         */
EntityID findEntityByName(const std::string& name);
⋮----
/**
         * @brief Find all entities with a specific tag
         * @param tag Tag to search for
         * @return Vector of entity IDs with the matching tag
         */
⋮----
/**
         * @brief Get the main camrea entity
         * @return ID of the main camera entity
         */
EntityID getMainCamera() const
⋮----
/**
         * @brief Set the main camera entity
         * @param cameraEntity ID of the entity to set as the main camera
         */
void setMainCamera(EntityID cameraEntity);
⋮----
/**
         * @brief Get the scene's name
         * @return The name of the scene
         */
const std::string& getName() const
⋮----
/**
         * @brief Set the scene's name
         * @param name The name to set
         */
void setName(const std::string& name)
⋮----
/**
         * @brief Get the scene's file path
         * @return The path of the scene file
         */
const std::string& getPath() const
⋮----
/**
         * @brief Set the scene's file path
         * @param path The path to set
         */
void setPath(const std::string& path)
⋮----
/**
         * @brief Serialize the scene to a FlatBuffer
         * @return Vector of bytes containing the serialized scene
         */
⋮----
/**
         * @brief Deserialize the scene from a FlatBuffer
         * @param data Pointer to the serialized data
         * @param size Size of the serialized data in bytes
         * @return True if deserialization was successful
         */
bool deserializeFromFlatBuffer(const uint8_t* data, size_t size);
⋮----
/**
         * @brief Serialize a specific entity to a FlatBuffer
         * @param entity Entity ID to serialize
         * @return Vector of bytes containing the serialized entity
         */
⋮----
/**
         * @brief Serialize a specific chunk
         * @param coord Coordinates of the chunk to serialize
         * @return True if the chunk was serialized successfully
         */
bool serializeChunk(const Voxel::ChunkCoord& coord);
⋮----
/**
         * @brief Deserialize a specific chunk
         * @param coord Coordinates of the chunk to deserialize
         * @return True if the chunk was deserialized successfully
         */
bool deserializeChunk(Voxel::ChunkCoord& coord);
⋮----
/**
         * @brief Mark a chunk as modified (dirty)
         * @param coord Coordinates of the chunk to mark
         */
void markChunkDirty(const Voxel::ChunkCoord& coord);
⋮----
/**
         * @brief Check if a chunk is marked as modified
         * @param coord Coordinates of the chunk to check
         * @return True if the chunk is marked as dirty
         */
bool isChunkDirty(const Voxel::ChunkCoord& coord) const;
⋮----
/**
         * @brief Save all modified chunks
         */
void saveModifiedChunks();
⋮----
/**
         * @brief Get the root entities (entities without parents)
         * @return Vector of root entity IDs
         */
const std::vector<EntityID>& getRootEntities() const
⋮----
/**
         * @brief Get the schema version used for serialization
         * @return The schema version number
         */
uint32_t getSchemaVersion() const
⋮----
/**
         * @brief Set the schema version for serialization
         * @param version The schema version number to set
         */
void setSchemaVersion(uint32_t version)
⋮----
/**
         * @brief Set the world reference for this scene
         * @param world Weak pointer to the world
         */
void setWorld(std::weak_ptr<World> world)
⋮----
/**
         * @brief Get the world this scene belongs to
         * @return Shared poitner to the world
         */
⋮----
/**
         * @brief Add an entity to the scene
         * @param entity Entity to add
         */
void addEntity(EntityID entity);
⋮----
/**
         * @brief Remove an entity from the scene
         * @param entity Entity to remove
         * @return True if the entity was removed
         */
bool removeEntity(EntityID entity);
⋮----
/**
         * @brief Get a chunk by its coordinates
         * @param coord Coordinates of the chunk
         * @param createIfMissing If true, create the chunk if it doesn't exist
         * @return Shared pointer to the chunk, or nullptr if not found
         */
⋮----
/**
         * @brief Add a tag to an entity
         * @param entity Entity to add the tag to
         * @param tag Tag to add
         */
void addTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Remove a tag from an entity
         * @param entity Entity to remove the tag from
         * @param tag Tag to remove
         */
void removeTag(EntityID entity, const std::string& tag);
⋮----
/**
         * @brief Check if an entity has a specific tag
         * @param entity Entity to check
         * @param tag Tag to look for
         * @return True if the entity has the tag
         */
bool hasTag(EntityID entity, const std::string& tag) const;
⋮----
// Scene data
std::string m_name;                                  ///< Scene name
std::string m_path;                                  ///< Scene file path
std::map<std::string, EntityID> m_entitiesByName;    ///< Mapping of entity names to IDs
std::map<std::string, std::vector<EntityID>> m_entitiesByTag; ///< Mapping of tags to entity IDs
EntityID m_mainCamera;                               ///< Main camera entity ID
std::vector<EntityID> m_rootEntities;                ///< Root-level entities (no parent)
⋮----
// Chunk data
std::unordered_map<Voxel::ChunkCoord, std::shared_ptr<Voxel::Chunk>> m_chunks; ///< Map of chunk coordinates to chunks
std::set<Voxel::ChunkCoord> m_dirtyChunks;                  ///< Set of dirty chunk coordinates
⋮----
// Version information
uint32_t m_schemaVersion;                            ///< Schema version for backward compatibility
⋮----
// World reference
std::weak_ptr<World> m_world;                        ///< Weak reference to the world this scene belongs to
⋮----
// Helper methods
/**
         * @brief Load entities from a file
         * @param path Path to the entities file
         * @return True if entities were loaded successfully
         */
bool loadEntities(const std::string& path);
⋮----
/**
         * @brief Save entities to a file
         * @param path Path to save the entities to
         * @return True if entities were saved successfully
         */
bool saveEntities(const std::string& path);
⋮----
/**
         * @brief Load chunks from a file or directory
         * @param path Path to the chunks file or directory
         * @return True if chunks were loaded successfully
         */
bool loadChunks(const std::string& path);
⋮----
/**
         * @brief Save chunks to files
         * @param path Path to save the chunks to
         * @return True if chunks were saved successfully
         */
bool saveChunks(const std::string& path);
⋮----
/**
         * @brief Get the file path for a specific chunk
         * @param coord Coordinates of the chunk
         * @return File path for the chunk
         */
⋮----
/**
         * @brief Serialize an entity to a serialize
         * @param entity Entity to serialize
         * @param serializer Serializer to use
         */
void serializeEntity(EntityID entity, Serializer& serializer);
⋮----
/**
         * @brief Deserialize an entity from a deserializer
         * @param deserializer Deserializer to use
         * @return ID of the deserialized entity
         */
EntityID deserializeEntity(Deserializer& deserializer);
⋮----
/**
         * @brief Add an entity to the entity name map
         * @param entity Entity ID
         * @param name Entity name
         */
void registerEntityName(EntityID entity, const std::string& name);
⋮----
/**
         * @brief Remove an entity from the entity name map
         * @param entity Entity ID
         * @param name Entity name
         */
void unregisterEntityName(EntityID entity, const std::string& name);
⋮----
/**
         * @brief Update chunk mesh and neighboring chunks
         * @param coord Coordinates of the chunk to update
         */
void updateChunkMesh(const Voxel::ChunkCoord& coord);
⋮----
/**
         * @brief Generate a scene directory path from the scene path
         * @return Directory path for scene data
         */
⋮----
/**
         * @brief Ensure the scene directory exists
         * @return True if directory exists or was created successfully
         */
bool ensureSceneDirectoryExists() const;
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Serializer.h">
// -------------------------------------------------------------------------
// Serializer.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Binary serialization with versioning and cross-platform support
     *
     * The Serializer class provides a robust way to serialize primitive types,
     * complex objects, and entity references to a binary stream. It handles
     * proper byte ordering, object nesting, and supports FlatBuffers integration.
     */
⋮----
/**
         * @brief Constructor
         * @param stream Output stream for serialization
         * @param byteOrder Byte order to use for serialization (default: native)
         */
⋮----
/**
         * @brief Destructor - ensures all objects are properly closed
         */
⋮----
/**
         * @brief Set the registry for entity reference handling
         * @param registry Weak pointer to entity registry
         */
void setRegistry(std::weak_ptr<Registry> registry);
⋮----
/**
         * @brief Write a primitive value to the stream with endianness handling
         * @tparam T Primitive type to serialize (must be arithmetic)
         * @param value Value to serialize
         */
⋮----
/**
         * @brief Write a boolean value to the stream
         * @param value Boolean value to serialize
         */
void writeBool(bool value);
⋮----
/**
         * @brief Write a 16-bit integer to the stream
         * @param value Integer value to serialize
         */
void writeInt16(int16_t value);
⋮----
/**
         * @brief Write an unsigned 16-bit integer to the stream
         * @param value Unsigned integer value to serialize
         */
void writeUInt16(uint16_t value);
⋮----
/**
         * @brief Write a 32-bit integer to the stream
         * @param value Integer value to serialize
         */
void writeInt32(int32_t value);
⋮----
/**
         * @brief Write an unsigned 32-bit integer to the stream
         * @param value Unsigned integer value to serialize
         */
void writeUInt32(uint32_t value);
⋮----
/**
         * @brief Write a 64-bit integer to the stream
         * @param value Integer value to serialize
         */
void writeInt64(int64_t value);
⋮----
/**
         * @brief Write an unsigned 64-bit integer to the stream
         * @param value Integer value to serialize
         */
void writeUInt64(uint64_t value);
⋮----
/**
         * @brief Write a float value to the stream
         * @param value Float value to serialize
         */
void writeFloat(float value);
⋮----
/**
         * @brief Write a double value to the stream
         * @param value Double value to serialize
         */
void writeDouble(double value);
⋮----
/**
         * @brief Write a string to the stream (length-prefixed)
         * @param value String to serialize
         */
void writeString(const std::string& value);
⋮----
/**
         * @brief Write raw bytes to the stream
         * @param data Pointer to data to serialize
         * @param size Size of data in bytes
         */
void writeBytes(const void* data, size_t size);
⋮----
/**
         * @brief Write an entity reference using UUID for persistence
         * @param entity Entity ID to serialize
         */
void writeEntityRef(EntityID entity);
⋮----
/**
         * @brief Write a 2D vector to the stream
         * @param value Vector to serialize
         */
void writeVec2(const glm::vec2& value);
⋮----
/**
         * @brief Write a 3D vector to the stream
         * @param value Vector to serialize
         */
void writeVec3(const glm::vec3& value);
⋮----
/**
         * @brief Write a 4D vector to the stream
         * @param value Vector to serialize
         */
void writeVec4(const glm::vec4& value);
⋮----
/**
         * @brief Write a quaternion to the stream
         * @param value Quaternion to serialize
         */
void writeQuat(const glm::quat& value);
⋮----
/**
         * @brief Write a 4x4 matrix to the stream
         * @param value Matrix to serialize
         */
void writeMat4(const glm::mat4& value);
⋮----
/**
         * @brief Begin an object section for nested serialization
         * @param name Name of the object for context
         */
void beginObject(const std::string& name);
⋮----
/**
         * @brief End an object section
         * @throws Logs an error if there is no matching beginObject call
         */
void endObject();
⋮----
/**
         * @brief Begin an array section for sequential data
         * @param name Name of the array for context
         * @param size Number of elements in the array
         */
void beginArray(const std::string& name, size_t size);
⋮----
/**
         * @brief End an array section
         * @throws Logs an error if there is no matching beginArray call
         */
void endArray();
⋮----
/**
         * @brief Write a FlatBuffer to the stream for efficient binary serialization
         * @param builder FlatBufferBuilder containing the buffer to write
         */
void writeFlatBuffer(const flatbuffers::FlatBufferBuilder& builder);
⋮----
/**
         * @brief Get the current position in the stream
         * @return Current position in bytes
         */
size_t getPosition() const;
⋮----
/**
         * @brief Align the stream to the specified boundary
         * @param alignment Alignment boundary in bytes
         */
void align(size_t alignment);
⋮----
/**
         * @brief Write a version number for backward compatibility
         * @param version Version number to serialize
         */
void writeVersion(uint32_t version);
⋮----
std::ostream& m_stream;                  ///< Output stream
std::weak_ptr<Registry> m_registry;      ///< Entity registry for reference handling
std::vector<std::string> m_objectStack;  ///< Stack for tracking nested objects
ByteOrder m_byteOrder;                   ///< Byte order for serialization
⋮----
/**
         * @brief Write raw data to the stream
         * @param data Pointer to data to write
         * @param size Size of data in bytes
         */
void writeRaw(const void* data, size_t size);
⋮----
/**
         * @brief Convert value endianness if needed based on target byte order
         * @tparam T Type of value to convert
         * @param value Value to potentially byte-swap
         */
⋮----
/**
         * @brief Check if byte swapping is needed for current platform
         * @return True if bytes need to be swapped
         */
bool needByteSwap() const;
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/System.h">
// -------------------------------------------------------------------------
// System.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Base class for all ECS systems
     * 
     * Systems contain that logic that operates on entities with specific component
     * combinations. They define behavior and update logic in the ECS architecture.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Virtual destructor
         */
virtual ~System() = default;
⋮----
/**
         * @brief Initialize the system
         * Called when the system is first registered with the world
         */
virtual bool initialize();
⋮----
/**
         * @brief Update the system
         * Called each frame to update system logic
         * @param deltaTime Time since last update in seconds
         */
virtual void update(float deltaTime);
⋮----
/**
         * @brief Render the system
         * Called during the render phase, if the system has visual output
         */
virtual void render();
⋮----
/**
         * @brief Configure the system
         * Called after initialization for additional setup
         */
virtual void configure();
⋮----
/**
         * @brief Get the component mask that defines which components this system requires
         * @return Component mask with bits set for required component types
         */
virtual ComponentMask getRequiredComponents() const = 0;
⋮----
/**
         * @brief Set the world reference
         * @param world Weak pointer to the world this system belongs to
         */
void setWorld(std::weak_ptr<World> world);
⋮----
/**
         * @brief Get the world reference
         * @return Weak pointer to the world
         */
⋮----
/**
         * @brief Get the list of system types this system depends on
         * @return Vector of system type names that this system depends on
         */
virtual std::vector<std::string> getDependencies() const
⋮----
/**
         * @brief Add a dependency to another system
         * @param systemTypeName The type name of the system this system depends on
         */
void addDependency(const std::string& systemTypeName)
⋮----
// Check if dependency already exists
⋮----
/**
         * @brief Process a system event
         * @param eventName Name of the event to process
         */
virtual void onEvent(const std::string& eventName)
⋮----
// Default implementation does nothing
// Derived systems should override this to handle specific events
⋮----
/**
         * @brief Hook called before the world is serialized
         * @param world Reference to the world being serialized
         * @param serializer Reference to the serializer
         */
⋮----
/**
         * @brief Hook called after the world is deserialized
         * @param world Reference to the world that was deserialized
         * @param deserializer Reference to the deserializer
         */
⋮----
/**
         * @brief Determine if this system should be serialized
         * @return True if the system should be serialized, false otherwise
         */
virtual bool shouldSerialize() const;
⋮----
/**
         * @brief Set the execution priority
         * Systems with higher priority are updated first
         * @param priority The priority value
         */
void setPriority(int priority);
⋮----
/**
         * @brief Get the execution priority
         * @return The priority value
         */
int getPriority() const
⋮----
/**
         * @brief Set the serialization priority
         * Systems with higher serialization priority are serialized first
         * @param priority The serialization priority value
         */
void setSerializationPriority(int priority);
⋮----
/**
         * @brief Get the serialization priority
         * @return The serialization priority value
         */
int getSerializationPriority() const
⋮----
/**
         * @brief Set the active state of the system
         * @param active True to activate the system, false to deactivate
         */
void setActive(bool active);
⋮----
/**
         * @brief Check if the system is active
         * @return True if the system is active, false otherwise
         */
bool isActive() const
⋮----
/**
         * @brief Get the type name of the system
         * @return String containing the type name
         */
virtual std::string getTypeName() const = 0;
⋮----
/**
         * @brief Get the type index of the system
         * @return std::type_index represeting the system type
         */
virtual std::type_index getTypeIndex() const = 0;
⋮----
/**
         * @brief Helper method to get a component mask for specific component types
         * @tparam Components Component types to include in the mask
         * @return ComponentMask with bits set for the specified component types
         */
⋮----
static ComponentMask getComponentMask();
⋮----
/**
         * @brief Iterate over entities that have all specified component types
         * @tparam Components Component types that entities must have
         * @param func Function to call for each matching entity and its components
         */
⋮----
/**
         * @brief Get all entities that have the components specified in the mask
         * @param mask Component mask to filter entities
         * @return Vector of entities that match the mask
         */
⋮----
/**
         * @brief Get an entity by ID
         * @param id The entity ID
         * @return Entity object representing the entity
         */
Entity getEntity(EntityID id);
⋮----
std::weak_ptr<World> m_world;   ///< Reference to the world this system belongs to
std::vector<std::string> m_dependencies; ///< List of system type names this system depends on
bool m_active;                  ///< System active state
int m_priority;                 ///< Execution priority
int m_serializationPriority;    ///< Serialization priority
ComponentMask m_componentMask;  ///< Component mask representing required components
⋮----
/**
     * @brief Macro to define system type information
     * @param TypeName The name of the system class
     */
⋮----
/**
     * @brief Factory for system registration and creation
     */
⋮----
/**
         * @brief Function type for creating system instances
         */
⋮----
/**
         * @brief Get the singleton factory instance
         * @return Reference to the system factory singleton
         */
static SystemFactory& getInstance();
⋮----
/**
         * @brief Register a system type
         * @tparam T The system type to register
         * @param name The name to register the system under
         * @return True if registration was successful, false otherwise
         */
⋮----
static bool registerSystem(const std::string& name);
⋮----
/**
         * @brief Create a system instance by name
         * @param name The registered name of the system
         * @return Shared pointer to the created system
         */
static std::shared_ptr<System> createSystem(const std::string& name);
⋮----
/**
         * @brief Create a system instance by type index
         * @param typeIndex The type index of the system
         * @return Shared pointer to the created system
         */
static std::shared_ptr<System> createSystem(const std::type_index& typeIndex);
⋮----
/**
         * @brief Get the registered name of a system type
         * @param typeIndex The type index of the system
         * @return The registered name
         */
static std::string getSystemName(const std::type_index& typeIndex);
⋮----
/**
         * @brief Get the type index for a registered system name
         * @param name The registered name of the system
         * @return The type index
         */
static std::type_index getSystemTypeIndex(const std::string& name);
⋮----
/**
         * @brief Private constructor for singleton pattern
         */
⋮----
/**
         * @brief Private destructor for singleton pattern
         */
⋮----
static std::unordered_map<std::string, std::type_index> s_systemTypeIndices;     ///< Map of system names to type indices
static std::unordered_map<std::type_index, std::string> s_systemNames;           ///< Map of type indices to system names
static std::unordered_map<std::type_index, CreateSystemFunc> s_systemFactories;  ///< Map of type indices to system factory functions
⋮----
// Use fold expression to set bits for each component type
⋮----
// Get mask for required components
⋮----
// Get matching entities
auto entities = getEntitiesWithComponents(mask);
⋮----
// Call function for each entity with its components
for (auto& entity : entities)
⋮----
if (entity.isValid())
⋮----
// Check if entity has all required components
if ((entity.getComponentMask() & mask) == mask)
⋮----
// Call the user function with the entity and its components
func(entity, entity.getComponent<Components>()...);
⋮----
// Check if already registered
⋮----
// Create factory function
⋮----
// Register system
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/Types.h">
// -------------------------------------------------------------------------
// ECSTypes.h
⋮----
// Basic type definitions
using EntityID = uint32_t;                  ///< Entity identifier type
using ComponentTypeID = uint32_t;           ///< Component type identifier
constexpr size_t MAX_COMPONENT_TYPES = 64;  ///< Maximum number of component types in the system
constexpr EntityID INVALID_ENTITY_ID = 0;   ///< Invalid entity ID constant
constexpr ComponentTypeID INVALID_COMPONENT_TYPE_ID = 0;  ///< Invalid component type ID constant
⋮----
using ComponentMask = std::bitset<MAX_COMPONENT_TYPES>;  ///< Component mask to identify which components a system requires
⋮----
/**
     * @brief Enumeration for byte order handling in serialization
     */
enum class ByteOrder
⋮----
LittleEndian, //!< Little endian byte order (x86, ARM)
BigEndian,    //!< Big endian byte order (PowerPC, SPARC)
Native        //!< Use the native byte order of the current platform
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/UUID.h">
// -------------------------------------------------------------------------
// UUID.h
⋮----
/**
     * @brief Universally unique identifier for entity persistence in ECS architecture
     *
     * The UUID class provides a standards-compliant implementation of RFC 4122 UUIDs
     * (Universally Unique Identifiers) for use within the PixelCraft ECS system.
     * UUIDs allow for consistent identification of entities across application sessions,
     * serialization/deserialization, and networked environments.
     *
     * This implementation supports:
     * - Random UUID generation (version 4)
     * - Name-based UUID generation (version 5)
     * - String conversion and parsing
     * - Comparison operations for container usage
     * - Serialization support
     * - Null UUID detection
     */
⋮----
/**
         * @brief Default constructor creates a random UUID (version 4)
         */
⋮----
/**
         * @brief Copy constructor
         * @param other UUID to copy
         */
⋮----
/**
         * @brief Move constructor
         * @param other UUID to move from
         */
⋮----
/**
         * @brief Construct from raw bytes
         * @param bytes Array of 16 bytes representing the UUID
         */
explicit UUID(const std::array<uint8_t, 16>& bytes);
⋮----
/**
         * @brief Copy assignment operator
         * @param other UUID to copy
         * @return Reference to this UUID
         */
⋮----
/**
         * @brief Move assignment operator
         * @param other UUID to move from
         * @return Reference to this UUID
         */
⋮----
/**
         * @brief Create a UUID from a string representation
         *
         * @param str String in standard UUID format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         * @return UUID parsed from the string, or null UUID if parsing fails
         */
static UUID fromString(const std::string& str);
⋮----
/**
         * @brief Convert UUID to string representation
         *
         * @return String in standard UUID format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         */
⋮----
/**
         * @brief Check if this UUID is null (all zeros)
         *
         * @return true if this is a null UUID
         * @return false otherwise
         */
bool isNull() const;
⋮----
/**
         * @brief Equality operator
         *
         * @param other UUID to compare with
         * @return true if UUIDs are equal
         * @return false otherwise
         */
⋮----
/**
         * @brief Inequality operator
         *
         * @param other UUID to compare with
         * @return true if UUIDs are not equal
         * @return false otherwise
         */
⋮----
/**
         * @brief Less than operator for ordered container support
         *
         * @param other UUID to compare with
         * @return true if this UUID is less than the other
         * @return false otherwise
         */
⋮----
/**
         * @brief Get raw UUID data
         *
         * @return Const reference to the 16-byte array
         */
const std::array<uint8_t, 16>& getData() const
⋮----
/**
         * @brief Serialize this UUID
         *
         * @param serializer Serializer to write to
         */
void serialize(Serializer& serializer);
⋮----
/**
         * @brief Deserialize this UUID
         *
         * @param deserializer Deserializer to read from
         */
void deserialize(Deserializer& deserializer);
⋮----
/**
         * @brief Create a random UUID (version 4)
         *
         * Generates a new UUID using a cryptographically secure
         * random number generator with proper thread safety.
         *
         * @return Randomly generated UUID
         */
static UUID createRandom();
⋮----
/**
         * @brief Create a deterministic UUID from a name (version 5)
         *
         * Generates a deterministic UUID based on the provided name.
         * The same name will always generate the same UUID.
         *
         * @param name String name to generate UUID from
         * @return Deterministically generated UUID
         */
static UUID createFromName(const std::string& name);
⋮----
/**
         * @brief Create a null UUID (all zeros)
         *
         * @return Null UUID
         */
static UUID createNull();
⋮----
/** Raw 16-byte storage for the UUID */
⋮----
/**
         * @brief Convert string representation to byte array
         *
         * @param str String in UUID format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         * @param bytes Array to store the result in
         */
static void stringToBytes(const std::string& str, std::array<uint8_t, 16>& bytes);
⋮----
/**
         * @brief Convert byte array to string representation
         *
         * @param bytes Byte array to convert
         * @return String in UUID format "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx"
         */
static std::string bytesToString(const std::array<uint8_t, 16>& bytes);
⋮----
} // namespace PixelCraft::ECS
⋮----
// Hash function for using UUID in unordered containers
⋮----
/**
         * @brief Hash function implementation for UUID
         *
         * @param uuid UUID to hash
         * @return size_t Hash value
         */
size_t operator()(const PixelCraft::ECS::UUID& uuid) const
</file>

<file path="include/ECS/View.h">
// -------------------------------------------------------------------------
// View.h
⋮----
// Forward declaration
⋮----
/**
     * @brief View class for efficient entity-component iteration
     *
     * Provides a way to iterate over all entities that have a specific
     * set of component types, with direct access to those components.
     *
     * @tparam Components Component types to include in the view
     */
⋮----
/**
         * @brief Constructor
         * @param registry Reference to the registry this view belongs to
         */
⋮----
// Create component mask for the requested component types
⋮----
/**
         * @brief Iterator class for efficient component iteration
         *
         * Provides iteration over entities with the required components,
         * automatically skipping entities that don't match the component mask.
         */
⋮----
/**
             * @brief Constructor
             * @param registry Reference to the registry
             * @param entityIt Current position in the entity set
             * @param entityEnd End position in the entity set
             * @param componentMask Mask of required components
             */
⋮----
// Find the first valid entity that matches the component mask
⋮----
/**
             * @brief Pre-increment operator
             * @return Reference to this iterator after increment
             */
⋮----
/**
             * @brief Inequality comparison operator
             * @param other Iterator to compare with
             * @return True if iterators are not equal
             */
⋮----
/**
             * @brief Dereference operator
             * @return Tuple containing entity ID and pointers to components
             */
⋮----
/**
             * @brief Find the next entity that matches the component mask
             *
             * Advances the entity iterator until finding an entity that has
             * all the required components, or reaching the end.
             */
⋮----
/**
         * @brief Get an iterator to the beginning of the view
         * @return Iterator pointing to the first matching entity
         */
Iterator begin()
⋮----
/**
         * @brief Get an iterator to the end of the view
         * @return Iterator pointing past the last entity
         */
Iterator end()
⋮----
/**
         * @brief Execute a function for each matching entity
         * @param func Function to execute for each entity
         *
         * The function should accept an entity ID followed by component pointers
         * matching the component types of the view.
         */
⋮----
for (auto it = begin(); it != end(); ++it)
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/ECS/World.h">
// -------------------------------------------------------------------------
// World.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Serialization task structure for background saving
     */
struct SerializationTask
⋮----
enum class Type
⋮----
/**
     * @brief Thread safety documentation for World
     *
     * The World class is thread-safe for the following operations:
     * - Multiple threads can read world state concurrently
     * - Entity creation/destruction is thread-safe
     * - System registration and execution has controlled concurrency
     * - Scene loading/saving is handled with proper synchronization
     *
     * Locking strategy:
     * - Shared mutex for world state access (highest level lock)
     * - System execution mutex for update/render cycles
     * - Task queue for background saving operations
     *
     * Thread safety guarantees:
     * - System update/render is never concurrent with system registration/removal
     * - Scene loading/unloading is never concurrent with world updates
     * - Entity operations delegate thread safety to Registry
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor, ensures proper cleanup of background threads
         */
⋮----
/**
         * @brief Initialize the World and its systems
         * @return True if initialization was successful
         * @thread_safety Thread-safe, acquires world lock
         */
bool initialize();
⋮----
/**
         * @brief Update all systems
         * @param deltaTime Time elapsed since last update
         * @thread_safety Thread-safe, acquires system execution lock
         */
void update(float deltaTime);
⋮----
/**
         * @brief Call render on all rendering-related systems
         * @thread_safety Thread-safe, acquires system execution lock
         */
void render();
⋮----
/**
         * @brief Create a new entity in the world
         * @param name Optional name for the entity
         * @return ID of the created entity
         * @thread_safety Thread-safe, delegates to Registry
         */
⋮----
/**
         * @brief Destroy an entity and all its components
         * @param entity ID of the entity to destroy
         * @return True if entity was successfully destroyed
         * @thread_safety Thread-safe, delegates to Registry
         */
bool destroyEntity(EntityID entity);
⋮----
/**
         * @brief Register a system with the world
         * @param system Shared pointer to the system to register
         * @thread_safety Thread-safe, acquires world lock
         */
void registerSystem(std::shared_ptr<System> system);
⋮----
/**
         * @brief Get a system by type
         * @tparam T Type of system to retrieve
         * @return Shared pointer to the system, or nullptr if not found
         * @thread_safety Thread-safe, acquires shared world lock
         */
⋮----
auto typeIndex = std::type_index(typeid(T));
⋮----
/**
         * @brief Get an entity by ID
         * @param id Entity ID to retrieve
         * @return Entity object for the specified ID
         * @thread_safety Thread-safe, delegates to Registry
         */
Entity getEntity(EntityID id);
⋮----
/**
         * @brief Load a scene from a file
         * @param path Path to the scene file
         * @return Shared pointer to the loaded scene, or nullptr on failure
         * @thread_safety Thread-safe, acquires world lock
         */
⋮----
/**
         * @brief Save the current scene to a file
         * @param path Path where the scene should be saved
         * @return True if saving was successful
         * @thread_safety Thread-safe, acquires shared world lock
         */
bool saveScene(const std::string& path);
⋮----
/**
         * @brief Serialize the world state to a serializer
         * @param serializer Serializer to use
         * @thread_safety Thread-safe, acquires shared world lock
         */
void serializeWorld(Serializer& serializer);
⋮----
/**
         * @brief Deserialize world state from a deserializer
         * @param deserializer Deserializer to use
         * @thread_safety Thread-safe, acquires world lock
         */
void deserializeWorld(Deserializer& deserializer);
⋮----
/**
         * @brief Get the registry that stores components
         * @return Shared pointer to the registry
         * @thread_safety Thread-safe, no locks needed (immutable after initialization)
         */
⋮----
/**
         * @brief Enable or disable background saving
         * @param enable True to enable background saving, false to disable
         * @thread_safety Thread-safe, atomic operation
         */
void enableBackgroundSaving(bool enable);
⋮----
/**
         * @brief Check if background saving is enabled
         * @return True if background saving is enabled
         * @thread_safety Thread-safe, atomic operation
         */
bool isBackgroundSavingEnabled() const
⋮----
/**
         * @brief Get the active scene
         * @return Shared pointer to the active scene
         * @thread_safety Thread-safe, acquires shared world lock
         */
⋮----
/**
         * @brief Pause world updates
         * @thread_safety Thread-safe, atomic operation
         */
void pause()
⋮----
/**
         * @brief Resume world updates
         * @thread_safety Thread-safe, atomic operation
         */
void resume()
⋮----
/**
         * @brief Check if the world is paused
         * @return True if the world is paused
         * @thread_safety Thread-safe, atomic operation
         */
bool isPaused() const
⋮----
// Core ECS data
std::shared_ptr<Registry> m_registry;                         ///< Registry for storing components
std::vector<std::shared_ptr<System>> m_systems;               ///< List of registered systems
std::map<std::type_index, std::weak_ptr<System>> m_systemsByType; ///< Map of systems by type
std::shared_ptr<Scene> m_activeScene;                         ///< Currently active scene
⋮----
// Background saving
bool m_savingEnabled{false};                                  ///< Flag for background saving
Utility::ThreadSafeQueue<SerializationTask> m_saveQueue;      ///< Queue for serialization tasks
std::thread m_saveThread;                                     ///< Background thread for saving
std::atomic<bool> m_threadRunning{false};                     ///< Flag for thread running state
⋮----
// Synchronization
mutable std::shared_mutex m_worldMutex;                       ///< Mutex for world state access
std::mutex m_systemExecutionMutex;                            ///< Mutex for system execution
std::atomic<bool> m_paused{false};                            ///< Flag for paused state
⋮----
/**
         * @brief Background thread function for processing save tasks
         */
void backgroundSaveThread();
⋮----
/**
         * @brief Sort systems based on dependencies and priorities
         * @thread_safety Assumes m_worldMutex is already locked
         */
void sortSystems();
⋮----
/**
         * @brief Check if the system dependencies contain cycles
         * @return True if cycles are detected
         * @thread_safety Assumes m_worldMutex is already locked
         */
bool hasCyclicDependencies();
⋮----
/**
         * @brief Notify all systems of an event
         * @param eventName Name of the event to broadcast
         * @thread_safety Thread-safe, acquires shared world lock
         */
void notifySystems(const std::string& eventName);
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="include/Voxel/BiomeManager.h">
// -------------------------------------------------------------------------
// BiomeManager.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Manages biome types and transitions
     * 
     * Handles biome definition, placement, and blending between different biome
     * types during procedural generation.
     */
⋮----
/**
         * @brief Structure representing biome parameters
         */
⋮----
glm::vec2 temperatureRange;  // Min/max temperature for this biome
glm::vec2 humidityRange;     // Min/max humidity for this biome
glm::vec2 elevationRange;    // Min/max elevation for this biome
std::unordered_map<std::string, float> voxelProbabilities;  // Voxel type to probability mapping
std::unordered_map<std::string, float> featureProbabilities; // Feature type to probability mapping
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~BiomeManager();
⋮----
/**
         * @brief Register a new biome type
         * @param name Unique name for the biome
         * @return Biome ID if successful, -1 if failed
         */
int registerBiome(const std::string& name);
⋮----
/**
         * @brief Remove a biome type
         * @param biomeId ID of the biome to remove
         * @return True if biome was found and removed
         */
bool removeBiome(int biomeId);
⋮----
/**
         * @brief Get biome information by ID
         * @param biomeId ID of the biome
         * @return Biome info, nullptr if not found
         */
const BiomeInfo* getBiomeInfo(int biomeId) const;
⋮----
/**
         * @brief Get biome information by name
         * @param name Name of the biome
         * @return Biome info, nullptr if not found
         */
const BiomeInfo* getBiomeInfo(const std::string& name) const;
⋮----
/**
         * @brief Get all registered biome IDs
         * @return Vector of biome IDs
         */
⋮----
/**
         * @brief Get all registered biome names
         * @return Vector of biome names
         */
⋮----
/**
         * @brief Set biome noise layer
         * @param biomeId ID of the biome
         * @param noiseLayerId ID of the noise layer
         * @param threshold Threshold value for biome boundary [0.0-1.0]
         * @return True if biome was found
         */
bool setBiomeNoise(int biomeId, const std::string& noiseLayerId, float threshold);
⋮----
/**
         * @brief Set temperature range for a biome
         * @param biomeId ID of the biome
         * @param minTemp Minimum temperature
         * @param maxTemp Maximum temperature
         * @return True if biome was found
         */
bool setBiomeTemperatureRange(int biomeId, float minTemp, float maxTemp);
⋮----
/**
         * @brief Set humidity range for a biome
         * @param biomeId ID of the biome
         * @param minHumidity Minimum humidity
         * @param maxHumidity Maximum humidity
         * @return True if biome was found
         */
bool setBiomeHumidityRange(int biomeId, float minHumidity, float maxHumidity);
⋮----
/**
         * @brief Set elevation range for a biome
         * @param biomeId ID of the biome
         * @param minElevation Minimum elevation
         * @param maxElevation Maximum elevation
         * @return True if biome was found
         */
bool setBiomeElevationRange(int biomeId, float minElevation, float maxElevation);
⋮----
/**
         * @brief Set probability for a voxel type in a biome
         * @param biomeId ID of the biome
         * @param voxelType Type of voxel
         * @param probability Probability [0.0-1.0]
         * @return True if biome was found
         */
bool setVoxelProbability(int biomeId, const std::string& voxelType, float probability);
⋮----
/**
         * @brief Get probability for a voxel type in a biome
         * @param biomeId ID of the biome
         * @param voxelType Type of voxel
         * @return Probability value, 0 if not found
         */
float getVoxelProbability(int biomeId, const std::string& voxelType) const;
⋮----
/**
         * @brief Set probability for a feature type in a biome
         * @param biomeId ID of the biome
         * @param featureType Type of feature
         * @param probability Probability [0.0-1.0]
         * @return True if biome was found
         */
bool setFeatureProbability(int biomeId, const std::string& featureType, float probability);
⋮----
/**
         * @brief Get probability for a feature type in a biome
         * @param biomeId ID of the biome
         * @param featureType Type of feature
         * @return Probability value, 0 if not found
         */
float getFeatureProbability(int biomeId, const std::string& featureType) const;
⋮----
/**
         * @brief Set biome weight (importance during blending)
         * @param biomeId ID of the biome
         * @param weight Weight value [0.0-1.0]
         * @return True if biome was found
         */
bool setBiomeWeight(int biomeId, float weight);
⋮----
/**
         * @brief Get biome weight
         * @param biomeId ID of the biome
         * @return Weight value, 0 if not found
         */
float getBiomeWeight(int biomeId) const;
⋮----
/**
         * @brief Enable or disable a biome
         * @param biomeId ID of the biome
         * @param enabled True to enable, false to disable
         * @return True if biome was found
         */
bool setBiomeEnabled(int biomeId, bool enabled);
⋮----
/**
         * @brief Check if a biome is enabled
         * @param biomeId ID of the biome
         * @return True if biome is enabled
         */
bool isBiomeEnabled(int biomeId) const;
⋮----
/**
         * @brief Get biome at a position
         * @param position World position to check
         * @param context Generation context
         * @return Biome ID, -1 if no biome found
         */
int getBiomeAt(const glm::vec3& position, const GenerationContext& context) const;
⋮----
/**
         * @brief Get biome influence at a position
         * @param position World position to check
         * @param context Generation context
         * @return Map of biome IDs to influence values [0.0-1.0]
         */
⋮----
/**
         * @brief Set biome blend distance
         * @param distance Blend distance in world units
         */
void setBlendDistance(float distance);
⋮----
/**
         * @brief Get biomes blend distance
         * @return The blend distance
         */
float getBlendDistance() const;
⋮----
/**
         * @brief Generate biome data for a chunk
         * @param chunkCoord Coordinate of the chunk
         * @param context Generation context
         * @param chunk Reference to the chunk for modification
         * @return True if generation was successful
         */
bool generateBiomeData(const ChunkCoord& chunkCoord, const GenerationContext& context, Chunk& chunk);
⋮----
/**
         * @brief Set a temperature noise layer
         * @param noiseLayerId ID of the noise layer
         */
void setTemperatureNoiseLayer(const std::string& noiseLayerId);
⋮----
/**
         * @brief Get the temperature noise layer ID
         * @return The temperature noise layer ID
         */
⋮----
/**
         * @brief Set a humidity noise layer
         * @param noiseLayerId ID of the noise layer
         */
void setHumidityNoiseLayer(const std::string& noiseLayerId);
⋮----
/**
         * @brief Get the humidity noise layer ID
         * @return The humidity noise layer ID
         */
⋮----
/**
         * @brief Apply a preset biome configuration
         * @param presetName Name of the preset
         * @return True if preset was found and applied
         */
bool applyPreset(const std::string& presetName);
⋮----
/**
         * @brief Serialize the biome configuration
         * @param serializer Serializer to serialize with
         */
void serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the biome configuration
         * @param deserializer Deserializer to deserialize with
         */
void deserialize(ECS::Deserializer& deserializer);
⋮----
/**
         * @brief Retrieve the next available biome ID
         */
⋮----
/**
         * @brief Calculate the biome influence in a particular position
         * @param biomeId ID of the biome to evaluate
         * @param position Position to check biome influence
         * @param temperature Biome temperature
         * @param humidity Biome humidity
         * @param elevation Biome elevation
         * @param context Reference to generation context
         */
float calculateBiomeInfluence(int biomeId, const glm::vec3& position,
⋮----
// Member variables
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/Chunk.h">
// -------------------------------------------------------------------------
// Chunk.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Chunk representing a fixed-size volume of voxels
     *
     * A Chunk is a 3D grid of voxels with fixed dimensions that forms
     * the basic unit of the voxel world. Chunks are loaded, unloaded,
     * and streamed based on player position and gameplay needs.
     */
⋮----
/**
         * @brief Default constructor
         */
⋮----
/**
         * @brief Constructor with explicit coordinate
         * @param coord Chunk coordinate
         */
explicit Chunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the chunk data structures
         * @param chunkSize Size of the chunk in each dimension (typically 16 or 32)
         * @return True if initialization was successful
         */
bool initialize(int chunkSize = 16);
⋮----
/**
         * @brief Get the chunk coordinate
         * @return Chunk coordinate
         */
const ChunkCoord& getCoord() const
⋮----
/**
         * @brief Set the chunk coordinate
         * @param coord New chunk coordinate
         */
void setCoord(const ChunkCoord& coord)
⋮----
/**
         * @brief Get size of the chunk in voxels
         * @return Chunk size
         */
int getSize() const
⋮----
/**
         * @brief Get voxel at the specified local position
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @return Reference to the voxel at the position
         */
const Voxel& getVoxel(int x, int y, int z) const;
⋮----
/**
         * @brief Set voxel at the specified local position
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @param voxel Voxel to set
         * @return True if the voxel was changed
         */
bool setVoxel(int x, int y, int z, const Voxel& voxel);
⋮----
/**
         * @brief Get voxel at the specified local position with bounds checking
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @param defaultVoxel Default voxel to return if position is out of bounds
         * @return Voxel at the position or default voxel
         */
const Voxel& getVoxelSafe(int x, int y, int z, const Voxel& defaultVoxel) const;
⋮----
/**
         * @brief Check if a local position is valid
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @return True if the position is within chunk bounds
         */
bool isValidPosition(int x, int y, int z) const;
⋮----
/**
         * @brief Fill the entire chunk with a specific voxel
         * @param voxel Voxel to fill with
         */
void fill(const Voxel& voxel);
⋮----
/**
         * @brief Generate mesh for the chunk
         * @param forceRegenerate Force mesh regeneration even if not dirty
         * @return True if mesh generation was successful
         */
bool generateMesh(bool forceRegenerate = false);
⋮----
/**
         * @brief Get the chunk mesh
         * @return Shared pointer to the chunk mesh
         */
⋮----
/**
         * @brief Get the chunk's bounding box in world space
         * @return Axis-aligned bounding box
         */
const Utility::AABB& getBounds() const
⋮----
/**
         * @brief Check if the chunk is dirty (needs saving)
         * @return True if the chunk has been modified since last save
         */
bool isDirty() const
⋮----
/**
         * @brief Mark the chunk as dirty
         */
void markDirty()
⋮----
/**
         * @brief Clear the dirty flag
         */
void clearDirty()
⋮----
/**
         * @brief Check if the chunk has a generated mesh
         * @return True if the chunk has a valid mesh
         */
bool hasMesh() const
⋮----
/**
         * @brief Check if the chunk is completely empty
         * @return True if the chunk contains only empty voxels
         */
bool isEmpty() const
⋮----
/**
         * @brief Serialize the chunk data
         * @param serializer Serializer to serialize to
         * @return True if serialization was successful
         */
bool serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the chunk data
         * @param deserializer Deserializer to deserialize to
         * @return True if deserialization was successful
         */
bool deserialize(ECS::Deserializer& deserializer);
⋮----
/**
         * @brief Get the memory usage of this chunk
         * @return Memory usage in bytes
         */
size_t getMemoryUsage() const;
⋮----
/**
         * @brief Set a neighbor chunk
         * @param direction Direction index (0-5 for -x, +x, -y, +y, -z, +z)
         * @param chunk Neighbor chunk
         */
void setNeighbor(int direction, std::weak_ptr<Chunk> chunk);
⋮----
/**
         * @brief Get a neighbor chunk
         * @param direction Direction index (0-5 for -x, +x, -y, +y, -z, +z)
         * @return Weak pointer to the neighbor chunk
         */
⋮----
/**
         * @brief Notify neighbors that this chunk has changed
         */
void notifyNeighbors();
⋮----
/**
         * @brief Set the visibility distance for LOD calculation
         * @param distance Distance from viewer
         */
void setVisibilityDistance(float distance)
⋮----
/**
         * @brief Get the visibility distance
         * @return Current visibility distance
         */
float getVisibilityDistance() const
⋮----
/**
         * @brief Check if the chunk needs to be re-meshed
         * @return True if mesh needs to be regenerated
         */
bool needsRemesh() const
⋮----
/**
         * @brief Mark the mesh as dirty, requiring regeneration
         */
void markMeshDirty()
⋮----
/**
         * @brief Cancel current mesh generation if in progress
         */
void cancelMeshGeneration();
⋮----
/**
         * @brief Update ambient occlusion and lighting
         */
void updateLighting();
⋮----
/**
         * @brief Calculate index for voxel at position
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @return Array index for the voxel
         */
inline size_t voxelIndex(int x, int y, int z) const
⋮----
/**
         * @brief Update the empty flag based on voxel content
         */
void updateEmptyState();
⋮----
/**
         * @brief Update the world-space bounding box
         */
void updateBounds();
⋮----
/**
         * @brief Check if a voxel is exposed (visible from outside)
         * @param x Local X coordinate
         * @param y Local Y coordinate
         * @param z Local Z coordinate
         * @return True if the voxel is visible from at least one side
         */
bool isVoxelExposed(int x, int y, int z) const;
⋮----
// Basic properties
ChunkCoord m_coord;       ///< Position in chunk grid
int m_size;               ///< Size in each dimension
Utility::AABB m_bounds;   ///< World-space bounding box
⋮----
// Voxel data
std::unique_ptr<Voxel[]> m_voxels;  ///< Voxel data array
⋮----
// Mesh and rendering
std::shared_ptr<ChunkMesh> m_mesh;  ///< Generated mesh for rendering
float m_visibilityDistance;         ///< Distance from viewer for LOD
⋮----
// Neighbors for meshing and physics
std::array<std::weak_ptr<Chunk>, 6> m_neighbors;  ///< Adjacent chunks
⋮----
// State flags
bool m_initialized;    ///< Whether chunk is initialized
bool m_empty;          ///< Whether chunk contains only empty voxels
bool m_dirty;          ///< Whether chunk needs saving
bool m_meshDirty;      ///< Whether mesh needs regeneration
bool m_meshGenerated;  ///< Whether mesh is generated
⋮----
// Threading support
std::atomic<bool> m_meshGenerationCanceled;  ///< Flag to cancel mesh generation
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/ChunkCoord.h">
// -------------------------------------------------------------------------
// ChunkCoord.h
⋮----
/**
     * @brief 3D chunk coordinate in the voxel grid
     */
struct ChunkCoord
⋮----
int x;  ///< X coordinate
int y;  ///< Y coordinate
int z;  ///< Z coordinate
⋮----
/**
         * @brief Default constructor initializes to (0,0,0)
         */
⋮----
/**
         * @brief Constructor with explicit coordinates
         * @param _x X coordinate
         * @param _y Y coordinate
         * @param _z Z coordinate
         */
⋮----
/**
         * @brief Equality operation
         * @param other Coordinate to compare with
         * @return True if coordinates are equal
         */
⋮----
/**
         * @brief Inequality operator
         * @param other Coordinate to compare with
         * @return True if coordinates are not equal
         */
⋮----
/**
         * @brief Addition operator
         * @param other Coordinate to add
         * @return New coordinate with added values
         */
⋮----
/**
         * @brief Subtraction operator
         * @param other Coordinate to subtract
         * @return New coordinate with subtracted values
         */
⋮----
/**
         * @brief Converts world position to chunk coordinate
         * @param worldPos World position
         * @param chunkSize Size of a chunk
         * @return Chunk coordinate containing the world position
         */
static ChunkCoord fromWorldPosition(const glm::vec3& worldPos, int chunkSize)
⋮----
/**
         * @brief Get the center position of this chunk in world space
         * @param chunkSize Size of a chunk
         * @return Center world position
         */
⋮----
/**
         * @brief String representation of the coordinate
         * @return Formatted string with coordinates
         */
⋮----
/**
         * @brief Manhattan distance from the origin
         * @return Sum of absolute coordinate values
         */
int manhattanDistance() const
⋮----
/**
         * @brief Manhattan distance between two chunk coordinates
         * @param other Other coordinate
         * @return Manhattan distance value
         */
int manhattanDistance(const ChunkCoord& other) const
⋮----
} // namespace PixelCraft::Voxel
⋮----
// Hash function for ChunkCoord to use in unordered_map/set
⋮----
size_t operator()(const PixelCraft::Voxel::ChunkCoord& coord) const
⋮----
// Simple hash combining the three coordinates
</file>

<file path="include/Voxel/ChunkManager.h">
// -------------------------------------------------------------------------
// ChunkManager.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Manages voxel chunks with efficient serialization
     *
     * ChunkManager handles the lifecycle of chunks in the voxel world, including
     * loading, unloading, storage, and coordination with the streaming system.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~ChunkManager();
⋮----
/**
         * @brief Initialize the chunk management system
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the chunk system
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Render debug visualization (if applicable)
         */
void render() override;
⋮----
/**
         * @brief Shut down the chunk system and release resources
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the subsystem dependencies
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Load a chunk from storage or create it if not found
         * @param coord Chunk coordinate
         * @return Shared pointer to the loaded chunk
         */
std::shared_ptr<Chunk> loadChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Unload a chunk from memory
         * @param coord Chunk coordinate
         * @return True if the chunk was unloaded
         */
bool unloadChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Create a new chunk at the specified coordinate
         * @param coord Chunk coordinate
         * @return Shared pointer to the created chunk
         */
std::shared_ptr<Chunk> createChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Get a loaded chunk
         * @param coord Chunk coordinate
         * @return Shared pointer to the chunk, or nullptr if not loaded
         */
std::shared_ptr<Chunk> getChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Check if a chunk is loaded
         * @param coord Chunk coordinate
         * @return True if the chunk is loaded
         */
bool isChunkLoaded(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Serialize a chunk to storage
         * @param chunk Chunk to serialize
         * @return True if serialization was successful
         */
bool serializeChunk(const Chunk& chunk);
⋮----
/**
         * @brief Deserialize a chunk from storage
         * @param chunk Chunk to deserialize
         * @return True if deserialization was successful
         */
bool deserializeChunk(Chunk& chunk);
⋮----
/**
         * @brief Save all modified chunks
         */
void saveModifiedChunks();
⋮----
/**
         * @brief Background thread for saving chunks
         */
void backgroundSaveThread();
⋮----
/**
         * @brief Get chunks around a point within a radius
         * @param position World position
         * @param radius Distance radius
         * @return Vector of chunks within the radius
         */
std::vector<std::shared_ptr<Chunk>> getChunksAroundPoint(const glm::vec3& position, float radius);
⋮----
/**
         * @brief Get map of all loaded chunks
         * @return Map of chunk coordinates to chunk pointers
         */
const std::unordered_map<ChunkCoord, std::shared_ptr<Chunk>>& getLoadedChunks() const
⋮----
/**
         * @brief Get the chunk storage
         * @return Pointer to chunk storage
         */
std::shared_ptr<ChunkStorage> getChunkStorage() const
⋮----
/**
         * @brief Set the world path for chunk storage
         * @param path Path to world directory
         * @return True if world was set successfully
         */
bool setWorldPath(const std::string& path);
⋮----
/**
         * @brief Get the world path
         * @return Path to world directory
         */
const std::string& getWorldPath() const;
⋮----
/**
         * @brief Set chunk size
         * @param size Size of each chunk (typically 16 or 32)
         */
void setChunkSize(int size);
⋮----
/**
         * @brief Get chunk size
         * @return Size of each chunk
         */
int getChunkSize() const
⋮----
/**
         * @brief Update neighbor pointers for a chunk
         * @param chunk Chunk to update neighbors for
         */
void updateChunkNeighbors(std::shared_ptr<Chunk> chunk);
⋮----
/**
         * @brief Generate mesh for a chunk
         * @param coord Chunk coordinate
         * @param forceRegenerate Force mesh regeneration even if not dirty
         * @return True if mesh generation was successful
         */
bool generateChunkMesh(const ChunkCoord& coord, bool forceRegenerate = false);
⋮----
// Chunk storage
⋮----
// Chunk properties
⋮----
// Saving thread
⋮----
// Thread safety
⋮----
// Streaming integration
⋮----
// Status
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/ChunkMesh.h">
// -------------------------------------------------------------------------
// ChunkMesh.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Mesh generation and storage for voxel chunks
     * 
     * ChunkMesh handles generating optimized meshes for rendering voxel chunks,
     * including greedy meshing optimization and efficient GPU storage;
     */
⋮----
/**
         * @brief Constructor
         * @param coord Chunk coordinate
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Generate mesh for a chunk with full neighboring chunks
         * @param chunk Chunk to generate mesh for
         * @param neighbors Array of 6 neighbor chunks for seamless meshing
         * @param cancelCheck Optional function to check if generation should be canceled
         * @return True if generation was successful
         */
bool generate(const Chunk& chunk,
⋮----
/**
         * @brief Generate mesh without requiring all neighbors
         * @param chunk Chunk to generate mesh for
         * @param cancelCheck Optional function to check if generation should be canceled
         * @return True if generation was successful
         */
bool generateSimple(const Chunk& chunk, std::function<bool()> cancelCheck = nullptr);
⋮----
/**
         * @brief Get the render mesh
         * @return Shared pointer to the render mesh
         */
⋮----
/**
         * @brief Get the chunk coordinate
         * @return Chunk coordinate
         */
const ChunkCoord& getCoord() const
⋮----
/**
         * @brief Get the memory usage of this mesh
         * @return Memory usage in bytes
         */
size_t getMemoryUsage() const;
⋮----
/**
         * @brief Get the vertex count of the mesh
         * @return Number of vertices
         */
size_t getVertexCount() const;
⋮----
/**
         * @brief Get the index count of the mesh
         * @return Number of indices
         */
size_t getIndexCount() const;
⋮----
/**
         * @brief Update the bounds based on chunk coordinates
         */
void updateBounds();
⋮----
/**
         * @brief Get the bounding box of the mesh
         * @return Axis-aligned bounding box
         */
const Utility::AABB& getBounds() const
⋮----
/**
         * @brief Update the level of detail based on distance
         * @param distance Distance from viewer
         * @return True if the LOD was updated
         */
bool updateLOD(float distance);
⋮----
/**
         * @brief Create all LOD levels for this mesh
         * @return True if LOD creation was successful
         */
bool createLODs();
⋮----
/**
         * @brief Get the current LOD level
         * @return Current LOD level (0 = full detail)
         */
int getLODLevel()
⋮----
/**
         * @brief Vertex data structure for the chunk mesh
         */
⋮----
glm::vec3 position;     ///< Vertex position
glm::vec3 normal;       ///< Normal vector
glm::vec2 texCoord;     ///< Texture coordinates
uint32_t color;         ///< Vertex color (RGBA)
uint16_t material;      ///< Material ID
uint16_t occlusion;     ///< Ambient occlusion value
⋮----
/**
         * @brief Clear mesh data
         */
void clear();
⋮----
/**
         * @brief Helper for voxel ray casting
         * @param chunk Chunk the ray is cast to
         * @param neighbors Neighbors of the chunk
         * @param origin Origin ray is cast from
         * @param direction Direction ray is cast toward
         * @param maxDistance Maximum distance ray is cast
         * @param hitDistance [out] Distance ray hits voxel
         * @return True if voxel is hit, false otherwise
         */
bool raycastVoxel(const Chunk& chunk,
⋮----
/**
         * @brief Generate hemisphere ray directions
         * @param normal Normal of hemisphere
         * @param sampleCount Count of sample rays to cast
         * @return Vector of rays cast from hemisphere
         */
⋮----
/**
         * @brief Update the rendering mesh from internal data
         * @return True if the update was successful
         */
bool updateRenderMesh();
⋮----
/**
         * @brief Generate mesh using greedy meshing algorithm
         * @param chunk Chunk to generate mesh for
         * @param neighbors Array of neighbor chunks
         * @param cancelCheck Function to check for cancellation
         * @return True if generation was successful
         */
bool generateGreedyMesh(const Chunk& chunk,
⋮----
/**
         * @brief Generate meh using simple cubes for each voxel
         * @param chunk Chunk to generate mesh for
         * @param cancelCheck Function to check for cancellation
         * @return True if generation was successful
         */
bool generateCubeMesh(const Chunk& chunk, std::function<bool()> cancelCheck);
⋮----
/**
         * @brief Simplifies a mesh using quadric error metrics
         * @param vertices Original mesh vertices
         * @param indices Original mesh indicies
         * @param outVertices [out] Simplified vertices
         * @param outIndices [out] Simplified indices
         * @param targetRatio Ratio of vertices to remove
         */
void simplifyMesh(const std::vector<Vertex>& vertices,
⋮----
/**
         * @brief Calculate ambient occlusion for vertices
         * @param chunk Chunk to calculate occlusion for
         * @param neighbors Array of neighbor chunks
         */
void calculateAmbientOcclusion(const Chunk& chunk,
⋮----
// Mesh data
std::vector<Vertex> m_vertices;       ///< Vertex data
std::vector<uint32_t> m_indices;      ///< Index data
⋮----
// Render mesh
std::shared_ptr<Rendering::Mesh> m_renderMesh;  ///< Render mesh
⋮----
// LOD support
int m_currentLOD;                     ///< Current level of detail
std::vector<std::shared_ptr<Rendering::Mesh>> m_lodMeshes;  ///< LOD meshes
⋮----
// Properties
ChunkCoord m_coord;                   ///< Chunk coordinate
Utility::AABB m_bounds;               ///< Bounding box
bool m_dirty;                         ///< Whether mesh needs update
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/ChunkStorage.h">
// -------------------------------------------------------------------------
// ChunkStorage.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Persistent storage system for voxel chunks
     *
     * ChunkStorage manages saving and loading chunks from disk, with
     * support for region-based file organization, caching, and compression.
     */
⋮----
/**
         * @brief Storage format options
         */
⋮----
Binary,         ///< Raw binary format
Compressed,     ///< Compressed binary format
FlatBuffer,     ///< FlatBuffers serialization
⋮----
/**
         * @brief Constructor
         * @param worldPath Path to the world directory
         * @param format Storage format to use
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the storage system
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Save a chunk to disk
         * @param chunk Chunk to save
         * @return True if saving was successful
         */
bool saveChunk(const Chunk& chunk);
⋮----
/**
         * @brief Load a chunk from disk
         * @param coord Chunk coordinate
         * @param chunk Chunk to populate
         * @return True if loading was successful
         */
bool loadChunk(const ChunkCoord& coord, Chunk& chunk);
⋮----
/**
         * @brief Check if a chunk exists on disk
         * @param coord Chunk coordinate
         * @return True if the chunk exists
         */
bool chunkExists(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Delete a chunk from disk
         * @param coord Chunk coordinate
         * @return True if deletion was successful
         */
bool deleteChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Get the path to the world directory
         * @return World directory path
         */
const std::string& getWorldPath() const
⋮----
/**
         * @brief Get the storage format being used
         * @return Storage format
         */
Format getFormat() const
⋮----
/**
         * @brief Set the maximum size of the metadata cache
         * @param size Cache size in number of entries
         */
void setMetadataCacheSize(size_t size);
⋮----
/**
         * @brief Flush all pending writes to disk
         */
void flush();
⋮----
/**
         * @brief Get a list of all chunk coordinates present in storage
         * @return Vector of chunk coordinates
         */
⋮----
/**
         * @brief Get chunk metadata without loading the full chunk
         * @param coord Chunk coordinate
         * @param lastModified Output parameter for last modification time
         * @param size Output parameter for chunk file size
         * @return True if metadata was retrieved successfully
         */
bool getChunkMetadata(const ChunkCoord& coord, int64_t& lastModified, size_t& size) const;
⋮----
/**
         * @brief Set compression level for compressed storage format
         * @param level Compression level (0-9, where 0 is no compression and 9 is maximum)
         */
void setCompressionLevel(int level);
⋮----
/**
         * @brief Get the total size of all stored chunks
         * @return Total size in bytes
         */
size_t getTotalStorageSize() const;
⋮----
/**
         * @brief Repair corrupted chunks if possible
         * @param coord Chunk coordinate
         * @return True if repair was successful or not needed
         */
bool repairChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Iterate through all chunks in a region
         * @param minCoord Minimum corner of the region
         * @param maxCoord Maximum corner of the region
         * @param callback Function to call for each existing chunk
         */
void forEachChunkInRegion(const ChunkCoord& minCoord, const ChunkCoord& maxCoord,
⋮----
/**
         * @brief Get the file path for a chunk
         * @param coord Chunk coordinate
         * @return Path to the chunk file
         */
⋮----
/**
         * @brief Get the region file path for a coordinate
         * @param coord Chunk coordinate
         * @return Path to the region file
         */
⋮----
/**
         * @brief Create directory structure for world if it doesn't exist
         * @return True if directories exist or were created successfully
         */
bool ensureDirectoriesExist() const;
⋮----
/**
         * @brief Check if a chunk file is valid
         * @param filepath Path to the chunk file
         * @return True if the file exists and has valid format
         */
bool isValidChunkFile(const std::string& filepath) const;
⋮----
/**
         * @brief Cache chunk metadata
         * @param coord Chunk coordinate
         * @param lastModified Last modification time
         * @param size File size
         */
void cacheMetadata(const ChunkCoord& coord, int64_t lastModified, size_t size) const;
⋮----
// World path and format
⋮----
// Compression settings
⋮----
// Pending writes tracking
⋮----
// Metadata cache
struct ChunkMetadata
⋮----
// Region file cache
struct RegionData
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/DistributionControl.h">
// -------------------------------------------------------------------------
// DistributionControl.h
⋮----
/**
     * @brief Controls feature distribution and density
     * 
     * Manages density maps, clustering, and spatial distribution of features
     * within the procedurally generated world.
     */
⋮----
/**
         * @brief Distribution pattern type
         */
⋮----
Uniform,        // Uniformly distributed
Clustered,      // Clustered around points
Gradient,       // Following a gradient
Stratified,     // Stratified random distribution
Voronoi,        // Voronoi-based distribution
BlueNoise,      // Blue noise distribution (visually pleasing)
Fibonacci,      // Fibonacci spiral distribution
Custom          // Custom distribution pattern
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~DistributionControl();
⋮----
/**
         * @brief Set the distribution pattern
         * @param pattern The distribution pattern to use
         */
void setPattern(PatternType pattern);
⋮----
/**
         * @brief Get the current distribution pattern
         * @return The current pattern
         */
PatternType getPattern() const;
⋮----
/**
         * @brief Set the global density factor
         * @param density Density factor [0.0-1.0]
         */
void setGlobalDensity(float density);
⋮----
/**
         * @brief Get the global density factor
         * @return The global density factor
         */
float getGlobalDensity() const;
⋮----
/**
         * @brief Set density for a specific feature type
         * @param featureType Type name of the feature
         * @param density Density factor [0.0-1.0]
         */
void setFeatureDensity(const std::string& featureType, float density);
⋮----
/**
         * @brief Get density for a feature type
         * @param featureType Type name of the feature
         * @return The density factor, returns global density if not set
         */
float getFeatureDensity(const std::string& featureType) const;
⋮----
/**
         * @brief Set the radius of influence for density
         * @param radius Influence radius in world units
         */
void setInfluenceRadius(float radius);
⋮----
/**
         * @brief Get the influence radius
         * @return The influence radius
         */
float getInfluenceRadius() const;
⋮----
/**
         * @brief Set the cluster size (when using clustered pattern)
         * @param size Size factor for clusters [0.1-10.0]
         */
void setClusterSize(float size);
⋮----
/**
         * @brief Get the cluster size
         * @return The cluster size factor
         */
float getClusterSize() const;
⋮----
/**
         * @brief Set the cluster spacing (when using clustered pattern)
         * @param spacing Spacing between clusters in world units
         */
void setClusterSpacing(float spacing);
⋮----
/**
         * @brief Get the cluster spacing
         * @return The cluster spacing
         */
float getClusterSpacing() const;
⋮----
/**
         * @brief Set cluster falloff factor (edge fading)
         * @param falloff Falloff factor [0.0-1.0]
         */
void setClusterFalloff(float falloff);
⋮----
/**
         * @brief Get the cluster fallof factor
         * @return The cluster falloff factor
         */
float getClusterFalloff() const;
⋮----
/**
         * @brief Set the seed for distribution patterns
         * @param seed Seed value
         */
void setSeed(uint32_t seed);
⋮----
/**
         * @brief Get the current seed
         * @return The current seed value
         */
uint32_t getSeed() const;
⋮----
/**
         * @brief Calculate density at a world position
         * @param position World position to check
         * @param featureType Type of feature (optional, uses global density if empty)
         * @return Density value [0.0-1.0]
         */
float getDensityAt(const glm::vec3& position, const std::string& featureType = "") const;
⋮----
/**
         * @brief Add a density modifier region
         * @param centerPosition Center of the region
         * @param radius Radius of the region
         * @param multiplier Density multiplier [0.0-10.0]
         * @param featureType Type of feature affected (empty for all)
         * @return ID of the created region for later reference
         */
int addDensityRegion(const glm::vec3& centerPosition, float radius, float multiplier,
⋮----
/**
         * @brief Remove a density modifier region
         * @param regionId ID of the region to remove
         * @return True if region was found and removed
         */
bool removeDensityRegion(int regionId);
⋮----
/**
         * @brief Add a cluster center
         * @param position Center position of the cluster
         * @param strength Strength of the cluster [0.0-1.0]
         * @param featureType Type of feature affected (empty for all)
         * @return ID of the created cluster for later reference
         */
int addCluster(const glm::vec3& position, float strength, const std::string& featureType = "");
⋮----
/**
         * @brief Remove a cluster
         * @param clusterId ID of the cluster to remove
         * @return True if cluster was found and removed
         */
bool removeCluster(int clusterId);
⋮----
/**
         * @brief Clear all clusters
         */
void clearClusters();
⋮----
/**
         * @brief Set density threshold for feature placement
         * @param threshold Minimum density required [0.0-1.0]
         * @param featureType Type of feature (empty for all)
         */
void setDensityThreshold(float threshold, const std::string& featureType = "");
⋮----
/**
         * @brief Get density threshold for a feature type
         * @param featureType Type of feature
         * @return Threshold value, 0 if not set
         */
float getDensityThreshold(const std::string& featureType) const;
⋮----
/**
         * @brief Generate sample points in a chunk based on distribution
         * @param chunkCoord Coordinate of the chunk
         * @param maxPoints Maximum number of points to generate
         * @param featureType Type of feature (for density calculation)
         * @return Vector of world positions for potential feature placement
         */
std::vector<glm::vec3> generateDistributionPoints(const ChunkCoord& chunkCoord,
⋮----
/**
         * @brief Set noise-based distribution map
         * @param noiseLayerId ID of the noise layer to use
         * @param threshold Threshold value for density [0.0-1.0]
         * @param featureType Type of feature (empty for all)
         */
void setNoiseDistribution(const std::string& noiseLayerId, float threshold,
⋮----
/**
         * @brief Get noise layer ID for distribution
         * @param featureType Type of feature
         * @return Noise layer ID, empty if not set
         */
std::string getNoiseDistribution(const std::string& featureType) const;
⋮----
/**
         * @brief Get noise threshold for distribution
         * @param featureType Type of feature
         * @return Threshold value, 0 if not set
         */
float getNoiseThreshold(const std::string& featureType) const;
⋮----
/**
         * @brief Set a density gradient
         * @param startPosition Start position of the gradient
         * @param endPosition End position of the gradient
         * @param startDensity Density at start [0.0-1.0]
         * @param endDensity Density at end [0.0-1.0]
         * @param featureType Type of feature (empty for all)
         * @return ID of the created gradient for later reference
         */
int setGradient(const glm::vec3& startPosition, const glm::vec3& endPosition,
⋮----
/**
         * @brief Remove a gradient
         * @param gradientId ID of the gradient to remove
         * @return True if gradient was found and removed
         */
bool removeGradient(int gradientId);
⋮----
/**
         * @brief Register a custom distribution function
         * @param name Unique name for the function
         * @param distributionFunc Function that takes a position and returns a density [0.0-1.0]
         * @return True if successfully registered
         */
bool registerCustomDistribution(const std::string& name,
⋮----
/**
         * @brief Set the active custom distribution
         * @param name Name of the registered custom distribution
         * @return True if distribution was found and set as active
         */
bool setActiveCustomDistribution(const std::string& name);
⋮----
/**
         * @brief Get the name of the active custom distribution
         * @returns Name of the active custom distribution, empty if none
         */
std::string getActiveCustomDistribution() const;
⋮----
/**
         * @brief Serialize the distribution configuration
         * @param serializer Serializer to serialize with
         */
void serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the distribution configuration
         * @param deserializer Deserializer to deserialize with
         */
void deserialize(ECS::Deserializer& deserializer);
⋮----
// Internal structures
struct DensityRegion
⋮----
struct Cluster
⋮----
struct Gradient
⋮----
struct NoiseDistribution
⋮----
// Private helper methods
float calculateBaseDensity(const glm::vec3& position, const std::string& featureType) const;
float applyRegionModifiers(const glm::vec3& position, float baseDensity, const std::string& featureType) const;
float applyClusterEffect(const glm::vec3& position, float density, const std::string& featureType) const;
float applyGradientEffect(const glm::vec3& position, float density, const std::string& featureType) const;
std::vector<glm::vec3> generatePointsUniform(const ChunkCoord& chunkCoord, int count) const;
std::vector<glm::vec3> generatePointsClustered(const ChunkCoord& chunkCoord, int count) const;
std::vector<glm::vec3> generatePointsStratified(const ChunkCoord& chunkCoord, int count) const;
std::vector<glm::vec3> generatePointsVoronoi(const ChunkCoord& chunkCoord, int count) const;
std::vector<glm::vec3> generatePointsBlueNoise(const ChunkCoord& chunkCoord, int count) const;
std::vector<glm::vec3> generatePointsFibonacci(const ChunkCoord& chunkCoord, int count) const;
⋮----
// Private member variables
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/FeaturePlacement.h">
// -------------------------------------------------------------------------
// FeaturePlacement.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Constraint-based feature placement system
     * 
     * Manages the placement of features (structures, objects, etc.) in a voxel world
     * with support for constraints, patterns, and distribution control.
     */
⋮----
/**
         * @brief Feature constraint type
         */
⋮----
None,               // No constraint
Elevation,          // Based on elevation (height)
Distance,           // Based on distance from a point
BiomeType,          // Based on biome
SlopeAngle,         // Based on terrain slope
NearWater,          // Near water bodies
FarFromWater,       // Away from water bodies
NearFeature,        // Near another feature
FarFromFeature,     // Away from another feature
NoiseThreshold,     // Based on noise value threshold
Density,            // Based on feature density in area
Custom              // Custom constraint
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~FeaturePlacement();
⋮----
/**
         * @brief Check if a feature can be placed at a position
         * @param position World position to check
         * @param featureType Type of the feature to place
         * @param context Generation context
         * @param grid Reference to the grid for queries
         * @return True if placement is allowed
         */
bool canPlaceFeature(const glm::vec3& position, const std::string& featureType,
⋮----
/**
         * @brief Place a feature at a position
         * @param position World position for placement
         * @param featureType Type of the feature to place
         * @param context Generation context
         * @param chunk Reference to the chunk for modification
         * @return True if placement was successful
         */
bool placeFeature(const glm::vec3& position, const std::string& featureType,
⋮----
/**
         * @brief Find valid feature placements in a chunk
         * @param chunkCoord Coordinate of the chunk
         * @param featureType Type of the feature to place
         * @param maxCount Maximum number of placements to find
         * @param context Generation context
         * @param grid Reference to the grid for queries
         * @return Vector of valid world positions for feature placement
         */
⋮----
/**
         * @brief Register a feature type
         * @param featureType Unique name for the feature type
         * @param generator Function to generate the feature
         * @return True if successfully registered
         */
bool registerFeatureType(const std::string& featureType,
⋮----
/**
         * @brief Check if a feature type is registered
         * @param featureType Name of the feature type
         * @return True if feature type is registered
         */
bool hasFeatureType(const std::string& featureType) const;
⋮----
/**
         * @brief Get all registered feature types
         * @return Vector of feature type names
         */
⋮----
/**
         * @brief Add a constraint for a feature type
         * @param featureType Name of the feature type
         * @param constraint Type of constraint to add
         * @param params Parameters for the constraint (depends on type)
         * @return True if successful
         */
bool addConstraint(const std::string& featureType, ConstraintType constraint, const std::vector<float>& params = {});
⋮----
/**
         * @brief Remove a constraint from a feature type
         * @param featureType Name of the feature type
         * @param constraint Type of constraint to remove
         * @return True if constraint was found and removed
         */
bool removeConstraint(const std::string& featureType, ConstraintType constraint);
⋮----
/**
         * @brief Clear all constraints for a feature type
         * @param featureType Name of the feature type
         * @return True if feature type was found
         */
bool clearConstraints(const std::string& featureType);
⋮----
/**
         * @brief Get constraints for a feature type
         * @param featureType Name of the feature type
         * @return Vector of constraint types
         */
⋮----
/**
         * @brief Get parameters for a specific constraint
         * @param featureType Name of the feature type
         * @param constraint Type of constraint
         * @return Vector of parameter values, empty if not found
         */
⋮----
/**
         * @brief Add a custom constraint
         * @param featureType Name of the feature type
         * @param name Unique name for the constraint
         * @param constraint Function implementing the constraint
         * @return True if successfully added
         */
bool addCustomConstraint(const std::string& featureType, const std::string& name,
⋮----
/**
         * @brief Remove a custom constraint
         * @param featureType Name of the feature type
         * @param name Name of the custom constraint
         * @return True if constraint was found and removed
         */
bool removeCustomConstraint(const std::string& featureType, const std::string& name);
⋮----
/**
         * @brief Register a point of interest (landmark)
         * @param position World position of the point of interest
         * @param type Type of the point of interest
         * @param radius Influence radius
         * @return True if successfully registered
         */
bool registerPointOfInterest(const glm::vec3& position, const std::string& type, float radius);
⋮----
/**
         * @brief Remove a point of interest
         * @param position World position of the point of interest
         * @param type Type of the point of interest
         * @return True if point was found and removed
         */
bool removePointOfInterest(const glm::vec3& position, const std::string& type);
⋮----
/**
         * @brief Find nearby points of interest
         * @param position World position to search from
         * @param maxDistance Maximum search distance
         * @param type Type of the point of interest to find, empty for any
         * @return Vector of positions of matching points of interest
         */
⋮----
/**
         * @brief Clear all registered points of interest
         */
void clearPointsOfInterest();
⋮----
/**
         * @brief Set minimum spacing between features of the same type
         * @param featureType Name of the feature type
         * @param spacing Minimum spacing in world units
         */
void setFeatureSpacing(const std::string& featureType, float spacing);
⋮----
/**
         * @brief Get minimum spacing for a feature type
         * @param featureType Name of the feature type
         * @return Minimum spacing, 0 if not found
         */
float getFeatureSpacing(const std::string& featureType) const;
⋮----
/**
         * @brief Set the feature placement seed
         * @param seed Seed value for random placement
         */
void setSeed(uint32_t seed);
⋮----
/**
         * @brief Get the current seed
         * @return The current seed value
         */
uint32_t getSeed() const;
⋮----
/**
         * @brief Serialize the placement configuration
         * @param serialier Serializer to serialize with
         */
void serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the placement configuration
         * @param deserializer Deserializer to deserialize with
         */
void deserialize(ECS::Deserializer& deserializer);
⋮----
// Internal structures
⋮----
struct CustomConstraintFunc
⋮----
struct PointOfInterest
⋮----
struct FeatureTypeInfo
⋮----
/**
         * @brief Check a constraint to evaludate validity of a position
         * @param constraint Constraint to check
         * @param position Position to evaluate constraint at
         * @param context Generation context for reference
         * @param grid Reference to grid for queries
         * @return True if constraint is valid
         */
bool checkConstraint(const FeatureConstraint& constraint, const glm::vec3& position,
⋮----
/**
         * @brief Generate potential positions within a chunk
         * @param chunkCoord Chunk destination to generate positions in
         * @param count Amount of positions to generate
         * @param context Generation context for reference
         * @return Vector of positions within the chunk
         */
⋮----
/**
         * @brief Check if a position is near an existing feature
         * @param position Position to evaluate
         * @param featureType Feature type to check for nearby
         * @param spacing Spacing from position to check for features
         * @return True if position is near an existing feature
         */
bool isNearExistingFeature(const glm::vec3& position, const std::string& featureType, float spacing) const;
⋮----
// Private member variables
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/FileChunkStorage.h">
// -------------------------------------------------------------------------
// FileChunkStorage.h
⋮----
// Forward declarations
⋮----
/**
     * @brief File-based implementation of ChunkStorage for persisting chunks
     *
     * FileChunkStorage saves chunks as individual files in a specified directory
     * with subdirectories organized by region for improved file system performance.
     */
⋮----
/**
         * @brief Constructor
         * @param basePath Base directory path where chunk files will be stored
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Save a chunk to a file
         * @param chunk The chunk to save
         * @return True if the save was successful
         */
bool saveChunk(const Chunk& chunk) override;
⋮----
/**
         * @brief Load a chunk from a file
         * @param chunk The chunk to load data into (must have valid coordinates)
         * @return True if the load was successful
         */
bool loadChunk(Chunk& chunk) override;
⋮----
/**
         * @brief Check if a chunk file exists
         * @param coord Coordinates of the chunk to check
         * @return True if the chunk file exists
         */
bool chunkExists(const ChunkCoord& coord) override;
⋮----
/**
         * @brief Delete a chunk file
         * @param coord Coordinates of the chunk to delete
         * @return True if the deletion was successful or file didn't exist
         */
bool deleteChunk(const ChunkCoord& coord) override;
⋮----
// Base path for chunk storage
⋮----
/**
         * @brief Get the file path for a chunk
         * @param coord Coordinates of the chunk
         * @return Full path to the chunk file
         */
⋮----
/**
         * @brief Ensure the directory structure exists for a chunk path
         * @param path Path to check/create
         * @return True if the directory exists or was created successfully
         */
bool ensureDirectoryExists(const std::string& path) const;
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/GenerationParameters.h">
// -------------------------------------------------------------------------
// GenerationParameters.h
⋮----
/**
     * @brief Configuration parameters for procedural generation
     * 
     * Holds all configuration parameters for procedural generation, allowing for
     * serialization and reuse of generation settings.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~GenerationParameters();
⋮----
/**
         * @brief Terrain generation mode
         */
enum class TerrainMode
⋮----
Flat,           // Flat terrain at fixed height
HeightMap,      // Height map based terrain
Volumetric,     // Full 3D volumetric terrain with caves
Islands,        // Floating islands
Mountains,      // Mountainous terrain
Desert,         // Desert with dunes
Custom          // Custom generation mode
⋮----
/**
         * @brief Feature placement pattern
         */
enum class PlacementPattern
⋮----
Random,         // Random distribution
Grid,           // Regular grid
Clustered,      // Clustering of features
Biome,          // Biome-based distribution
Landmark,       // Near landmarks
EdgeClustered,  // Clustered near edges
Custom          // Custom placement pattern
⋮----
/**
         * @brief Set the terrain generation mode
         * @param mode The terrain mode to use
         */
void setTerrainMode(TerrainMode mode);
⋮----
/**
         * @brief Get the current terrain mode
         * @return The current terrain mode
         */
TerrainMode getTerrainMode() const;
⋮----
/**
         * @brief Set the height range for terrain
         * @param min Minimum height
         * @param max Maximum height
         */
void setHeightRange(float min, float max);
⋮----
/**
         * @brief Get the minimum terrain height
         * @return The minimum height
         */
float getMinHeight() const;
⋮----
/**
         * @brief Get the maximum terrain height
         * @return The maximum height
         */
float getMaxHeight() const;
⋮----
/**
         * @brief Set water level
         * @param level The water level height
         */
void setWaterLevel(float level);
⋮----
/**
         * @brief Get the water level
         * @return The water level height
         */
float getWaterLevel() const;
⋮----
/**
         * @brief Enable or disable water
         * @param enable True to enable water, false to disable
         */
void enableWater(bool enable);
⋮----
/**
         * @brief Check if water is enabled
         * @return True if water is enabled
         */
bool isWaterEnabled() const;
⋮----
/**
         * @brief Enable or disable caves
         * @param enable True to enable caves, false to disable
         */
void enableCaves(bool enable);
⋮----
/**
         * @brief Check if caves are enabled
         * @return True if caves are enabled
         */
bool areCavesEnabled() const;
⋮----
/**
         * @brief Set the cave density factor
         * @param density Density factor [0.0-1.0]
         */
void setCaveDensity(float density);
⋮----
/**
         * @brief Get the cave density factor
         * @return The cave density factor
         */
float getCaveDensity() const;
⋮----
/**
         * @brief Set the cave size
         * @param size Size factor for caves [0.1-10.0]
         */
void setCaveSize(float size);
⋮----
/**
         * @brief Get the cave size
         * @return The cave size factor
         */
float getCaveSize() const;
⋮----
/**
         * @brief Set the noise layer to use for terrain height
         * @param layerId ID of the noise layer
         */
void setTerrainNoiseLayer(const std::string& layerId);
⋮----
/**
         * @brief Get the terrain noise layer ID
         * @return The terrain noise layer ID
         */
std::string getTerrainNoiseLayer() const;
⋮----
/**
         * @brief Set the noise layer to use for cave generation
         * @param layerId ID of the noise layer
         */
void setCaveNoiseLayer(const std::string& layerId);
⋮----
/**
         * @brief Get the cave noise layer ID
         * @return The cave noise layer ID
         */
std::string getCaveNoiseLayer() const;
⋮----
/**
         * @brief Set the noise layer to use for feature placement
         * @param layerId ID of the noise layer
         */
void setFeatureNoiseLayer(const std::string& layerId);
⋮----
/**
         * @brief Get the feature noise layer ID
         * @return The feature noise layer ID
         */
std::string getFeatureNoiseLayer() const;
⋮----
/**
         * @brief Set the noise layer to use for biome distribution
         * @param layerId ID of the noise layer
         */
void setBiomeNoiseLayer(const std::string& layerId);
⋮----
/**
         * @brief Get the biome noise layer ID
         * @return The biome noise layer ID
         */
std::string getBiomeNoiseLayer() const;
⋮----
/**
         * @brief Set the terrain roughness
         * @param roughness Roughness factor [0.0-1.0]
         */
void setTerrainRoughness(float roughness);
⋮----
/**
         * @brief Get the terrain roughness
         * @return The terrain roughness factor
         */
float getTerrainRoughness() const;
⋮----
/**
         * @brief Set the terrain erosion factor
         * @param erosion Erosion factor [0.0-1.0]
         */
void setTerrainErosion(float erosion);
⋮----
/**
         * @brief Get the terrain erosion factor
         * @return The terrain erosion factor
         */
float getTerrainErosion() const;
⋮----
/**
         * @brief Set the feature placement pattern
         * @param pattern The placement pattern to use
         */
void setFeaturePlacementPattern(PlacementPattern pattern);
⋮----
/**
         * @brief Get the feature placement pattern
         * @return The feature placement pattern
         */
PlacementPattern getFeaturePlacementPattern() const;
⋮----
/**
         * @brief Set the feature density
         * @param density Density factor [0.0-1.0]
         */
void setFeatureDensity(float density);
⋮----
/**
         * @brief Get the feature density
         * @return The feature density factor
         */
float getFeatureDensity() const;
⋮----
/**
         * @brief Set the biome blend distance
         * @param distance Blend distance in world units
         */
void setBiomeBlendDistance(float distance);
⋮----
/**
         * @brief Get the biome blend distance
         * @return The biome blend distance
         */
float getBiomeBlendDistance() const;
⋮----
/**
         * @brief Set the feature placement control to use
         * @param controlId ID of the feature placement control
         */
void setFeaturePlacementControl(const std::string& controlId);
⋮----
/**
         * @brief Get the feature placement control ID
         * @return The feature placement control ID
         */
std::string getFeaturePlacementControl() const;
⋮----
/**
         * @brief Set the distribution control to use
         * @param controlId ID of the distribution control
         */
void setDistributionControl(const std::string& controlId);
⋮----
/**
         * @brief Get the distribution control ID
         * @return The distribution control ID
         */
std::string getDistributionControl() const;
⋮----
/**
         * @brief Enable or disable a specific feature type
         * @param featureType Type name of the feature
         * @param enable True to enable, false to disable
         */
void enableFeatureType(const std::string& featureType, bool enable);
⋮----
/**
         * @brief Check if a feature type is enabled
         * @param featureType Type name of the feature
         * @return True if the feature type is enabled
         */
bool isFeatureTypeEnabled(const std::string& featureType) const;
⋮----
/**
         * @brief Set the density for a specific feature type
         * @param featureType Type name of the feature
         * @param density Density factor [0.0-1.0]
         */
void setFeatureTypeDensity(const std::string& featureType, float density);
⋮----
/**
         * @brief Get the density for a feature type
         * @param featureType Type name of the feature
         * @param defaultValue Default value if not found
         * @return The feature type density
         */
float getFeatureTypeDensity(const std::string& featureType, float defaultValue = 0.5f) const;
⋮----
/**
         * @brief Set a float parameter
         * @param name name of the parameter
         * @param value Value to set
         */
void setFloatParam(const std::string& name, float value);
⋮----
/**
         * @brief Get a float parameter
         * @param name Name of the parameter
         * @param defaultValue Default value if not found
         * @return The parameter value
         */
float getFloatParam(const std::string& name, float defaultValue = 0.0f) const;
⋮----
/**
         * @brief Set an integer parameter
         * @param name Name of the parameter
         * @param value Value to set
         */
void setIntParam(const std::string& name, int value);
⋮----
/**
         * @brief Get an integer parameter
         * @param name Name of the parameter
         * @param defaultValue Default value if not found
         * @return The parameter value
         */
int getIntParam(const std::string& name, int defaultValue = 0) const;
⋮----
/**
         * @brief Set a boolean parameter
         * @param name Name of the parameter
         * @param value Value to set
         */
void setBoolParam(const std::string& name, bool value);
⋮----
/**
         * @brief Get a boolean parameter
         * @param name Name of the parameter
         * @param defaultValue Default value if not found
         * @return The parameter value
         */
bool getBoolParam(const std::string& name, bool defaultValue = false) const;
⋮----
/**
         * @brief Set a string parameter
         * @param name Name of the parameter
         * @param value Value to set
         */
void setStringParam(const std::string& name, const std::string& value);
⋮----
/**
         * @brief Get a string parameter
         * @param name Name of the parameter
         * @param defaultValue Default value if not found
         * @return The parameter value
         */
std::string getStringParam(const std::string& name, const std::string& defaultValue = "") const;
⋮----
/**
         * @brief Set a vector parameter
         * @param name Name of the parameter
         * @param value Value to set
         */
void setVec3Param(const std::string& name, const glm::vec3& value);
⋮----
/**
         * @brief Get a vector parameter
         * @param name Name of the parameter
         * @param defaultValue Default value if not found
         * @return The parameter value
         */
glm::vec3 getVec3Param(const std::string& name, const glm::vec3& defaultValue = glm::vec3(0.0f)) const;
⋮----
/**
         * @brief Apply preset parameters for a specific terrain type
         * @param presetName Name of the preset
         * @return True if preset was applied successfully
         */
bool applyPreset(const std::string& presetName);
⋮----
/**
         * @brief Serialize the parameters
         * @param serializer Serializer to serialize with
         */
void serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the parameters
         * @param deserializer Deserializer to deserialize with
         */
void deserialize(ECS::Deserializer& deserializer);
⋮----
/**
         * @brief Initializes default values
         */
void initializeDefaults();
⋮----
// Member variables
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/Grid.h">
// -------------------------------------------------------------------------
// Grid.h
⋮----
/**
     * @brief 3D voxel grid with chunking and serialization
     * 
     * Grid provides a high-level interface to voxel data, abstracting away the
     * chunk-based management and providing world-space coordinate access.
     */
⋮----
/**
         * @brief Constructor
         * @param chunkSize Size of each chunk in voxels (typically 16 or 32)
         */
⋮----
/**
         * @brief Destructor
         */
⋮----
/**
         * @brief Initialize the grid
         * @return True if initialization was successful
         */
bool initialize();
⋮----
/**
         * @brief Shut down the grid and release resources
         */
void shutdown();
⋮----
/**
         * @brief Get voxel at world position
         * @param worldPosition Position in world space
         * @return Voxel at the position or default voxel if none exists
         */
Voxel getVoxel(const glm::vec3& worldPosition) const;
⋮----
/**
         * @brief Get voxel at grid coordinates
         * @param x X coordinate in grid space
         * @param y Y coordinate in grid space
         * @param z Z coordinate in grid space
         * @return Voxel at the position or default voxel if none exists
         */
Voxel getVoxel(int x, int y, int z) const;
⋮----
/**
         * @brief Set voxel at world position
         * @param worldPosition Position in world space
         * @param voxel Voxel to set
         * @return True if the voxel was set successfully
         */
bool setVoxel(const glm::vec3& worldPosition, const Voxel& voxel);
⋮----
/**
         * @brief Set voxel at grid coordinates
         * @param x X coordinate in grid space
         * @param y Y coordinate in grid space
         * @param z Z coordinate in grid space
         * @param voxel Voxel to set
         * @return True if the voxel was set successfully
         */
bool setVoxel(int x, int y, int z, const Voxel& voxel);
⋮----
/**
         * @brief Get chunk at specified coordinates
         * @param coord Chunk coordinates
         * @return Shared pointer to the chunk or nullptr if not loaded
         */
⋮----
/**
         * @brief Get chunk at specified world position
         * @param worldPosition Position in world space
         * @return Shared pointer to the chunk or nullptr if not loaded
         */
⋮----
/**
         * @brief Create a chunk at specified coordinates
         * @param coord Chunk coordinates
         * @return Shared pointer to the created chunk
         */
⋮----
/**
         * @brief Unload a chunk
         * @param coord Chunk coordinates
         * @return True if the chunk was unloaded
         */
bool unloadChunk(const ChunkCoord& coord);
⋮----
/**
         * @brief Get the bounding box of the grid
         * @return Axis-aligned bounding box
         */
const Utility::AABB& getBounds() const
⋮----
/**
         * @brief Set the bounding box of the grid
         * @param bounds New bounding box
         */
void setBounds(const Utility::AABB& bounds)
⋮----
/**
         * @brief Get the chunk size
         * @return Size of each chunk in voxels
         */
int getChunkSize() const
⋮----
/**
         * @brief Perform a raycast through the voxel grid
         * @param origin Ray origin
         * @param direction Ray direction (normalized)
         * @param maxDistance Maximum ray distance
         * @param hitPosition Output parameter for hit position
         * @param hitNormal Output parameter for hit normal
         * @param hitVoxel Output parameter for hit voxel data
         * @return True if the ray hit a voxel
         */
bool raycast(const glm::vec3& origin, const glm::vec3& direction, float maxDistance,
⋮----
/**
         * @brief Serialize the grid
         * @param serializer Serializer to write to
         * @return True if serialization was successful
         */
bool serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the grid
         * @param deserializer Deserializer to read from
         * @return True if deserialization was successful
         */
bool deserialize(ECS::Deserializer& deserializer);
⋮----
/**
         * @brief Get a list of all loaded chunk coordinates
         * @return Vector of loaded chunk coordinates
         */
⋮----
/**
         * @brief Get the number of loaded chunks
         * @return Number of loaded chunks
         */
size_t getLoadedChunkCount() const;
⋮----
/**
         * @brief Set the default voxel for empty space
         * @param voxel Default voxel
         */
void getDefaultVoxel(const Voxel& voxel)
⋮----
/**
         * @brief Get the default voxel
         * @return Default voxel
         */
const Voxel& getDefaultVoxel() const
⋮----
/**
         * @brief Get all chunks within a radius of a world position
         * @param worldPosition Center position
         * @param radius Radius to search
         * @return Vector of chunks
         */
std::vector<std::shared_ptr<Chunk>> getChunksInRadius(const glm::vec3& worldPosition, float radius);
⋮----
/**
         * @brief Convert world position to grid coordinates
         * @param worldPos World position
         * @param gridX Output X coordinate
         * @param gridY Output Y coordinate
         * @param gridZ Output Z coordinate
         */
void worldToGrid(const glm::vec3& worldPos, int& gridX, int& gridY, int& gridZ) const;
⋮----
/**
         * @brief Convert grid coordinates to chunk coordinates and local position
         * @param gridX Grid X coordinate
         * @param gridY Grid Y coordinate
         * @param gridZ Grid Z coordinate
         * @param chunkCoord Output chunk coordinates
         * @param localX Output local X coordinate within chunk
         * @param localY Output local Y coordinate within chunk
         * @param localZ Output local Z coordinate within chunk
         */
void gridToChunkAndLocal(int gridX, int gridY, int gridZ, ChunkCoord& chunkCoord,
⋮----
/**
         * @brief Convert world position directly to chunk coordinates and local position
         * @param worldPos World position
         * @param chunkCoord Output chunk coordinates
         * @param localX Output local X coordinate within chunk
         * @param localY Output local Y coordinate within chunk
         * @param localZ Output local Z coordinate within chunk
         */
void worldToChunkAndLocal(const glm::vec3& worldPos, ChunkCoord& chunkCoord,
⋮----
// Chunk management
⋮----
// Grid bounds
⋮----
// Default voxel for empty space
⋮----
// State
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/NoiseGenerator.h">
// -------------------------------------------------------------------------
// NoiseGenerator.h
⋮----
/**
     * @brief Advanced noise generation for procedural content
     * 
     * Provides multiple noise algorithms, layering capabilities, and transformation
     * options for generating complex terrain and other procedural elements.
     */
⋮----
/**
         * @brief Types of noise algorithms
         */
⋮----
/**
         * @brief Fractal types for noise detail
         */
enum class FractalType
⋮----
FBM,         // Fractal Brownian Motion
Rigid,       // Rigid multi-fractal
Billow,      // Billowy noise
MultiFractal,// Multi-fractal
HybridMulti, // Hybrid multi-fractal
DeCarpentier // De Carpentier's voxel terrain formula
⋮----
/**
         * @brief Interpolation methods for noise
         */
enum class InterpolationType
⋮----
/**
         * @brief Domain warp method
         */
enum class WarpType
⋮----
/**
         * @brief Noise layer combining operations
         */
enum class CombineOperation
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~NoiseGenerator();
⋮----
/**
         * @brief Generate a noise value at specified coordinates
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @return The generated noise value [-1,1]
         */
float generate(float x, float y, float z) const;
⋮----
/**
         * @brief Generate a noise value at specified coordinates
         * @parma position 3D position vector
         * @return The generated noise value [-1,1]
         */
float generate(const glm::vec3& position) const;
⋮----
/**
         * @brief Generate a 2D noise value at specified coordinates
         * @param x X coordinate
         * @param y Y coordinate
         * @return The generated noise value [-1,1]
         */
float generate2D(float x, float y) const;
⋮----
/**
         * @brief Set the seed for noise generation
         * @param seed The new seed value
         */
void setSeed(uint32_t seed);
⋮----
/**
         * @brief Get the current seed
         * @return The current seed value
         */
uint32_t getSeed() const;
⋮----
/**
         * @brief Set the noise type
         * @param type The noise algorithm type to use
         */
void setNoiseType(NoiseType type);
⋮----
/**
         * @brief Get the current noise type
         * @return The current noise algorithm type
         */
NoiseType getNoiseType() const;
⋮----
/**
         * @brief Set the fractal type
         * @param type The fractal algorithm to use
         */
void setFractalType(FractalType type);
⋮----
/**
         * @brief Get the current fractal type
         * @return The current fractal type
         */
FractalType getFractalType() const;
⋮----
/**
         * @brief Set the number of octaves for fractal noise
         * @param octaves Number of octaves [1-10]
         */
void setOctaves(int octaves);
⋮----
/**
         * @brief Get the current number of octaves
         * @return The current octave count
         */
int getOctaves() const;
⋮----
/**
         * @brief Set the lacunarity (frequency multiplier between octaves)
         * @param lacunarity The lacunarity value [1.0-4.0]
         */
void setLacunarity(float lacunarity);
⋮----
/**
         * @brief Get the current lacunarity
         * @return The current lacunarity value
         */
float getLacunarity() const;
⋮----
/**
         * @brief Set the persistence (amplitude multiplier between octaves)
         * @param persistence The persistence value [0.0-1.0]
         */
void setPersistence(float persistence);
⋮----
/**
         * @brief Get the current persistence
         * @return The current persistence value
         */
float getPersistence() const;
⋮----
/**
         * @brief Set the frequency of the noise
         * @param frequency The frequency value
         */
void setFrequency(float frequency);
⋮----
/**
         * @brief Get the current frequency
         * @return The current frequency value
         */
float getFrequency() const;
⋮----
/**
         * @brief Set the amplitude of the noise
         * @param amplitude The amplitude value
         */
void setAmplitude(float amplitude);
⋮----
/**
         * @brief Get the current amplitude
         * @return The current amplitude value
         */
float getAmplitude() const;
⋮----
/**
         * @brief Set a scale factor for the coordinates
         * @param scale The scale vector (separate scale for each axis)
         */
void setScale(const glm::vec3& scale);
⋮----
/**
         * @brief Get the current scale factor
         * @return The current scale vector
         */
glm::vec3 getScale() const;
⋮----
/**
         * @brief Set an offset for the coordinates
         * @param offset The offset vector
         */
void setOffset(const glm::vec3& offset);
⋮----
/**
         * @brief Get the current offset
         * @return The current offset vector
         */
glm::vec3 getOffset() const;
⋮----
/**
         * @brief Enable or disable domain warping
         * @param enable True to enable, false to disable
         */
void enableWarp(bool enable);
⋮----
/**
         * @brief Check if warping is enabled
         * @return True if enabled
         */
bool isWarpEnabled() const;
⋮----
/**
         * @brief Set the domain warp type
         * @param type The warp type to use
         */
void setWarpType(WarpType type);
⋮----
/**
         * @brief Get the current warp type
         * @return The current warp type
         */
WarpType getWarpType() const;
⋮----
/**
         * @brief Set the warp amplitude
         * @param amplitude The warp amplitude
         */
void setWarpAmplitude(float amplitude);
⋮----
/**
         * @brief Get the current warp amplitude
         * @return The current warp amplitude
         */
float getWarpAmplitude() const;
⋮----
/**
         * @brief Set the warp frequency
         * @param frequency The warp frequency
         */
void setWarpFrequency(float frequency);
⋮----
/**
         * @brief Get the current warp frequency
         * @return The current warp frequency
         */
float getWarpFrequency() const;
⋮----
/**
         * @brief Set the interpolation method
         * @param interp The interpolation type
         */
void setInterpolation(InterpolationType interp);
⋮----
/**
         * @brief Get the current interpolation method
         * @return The current interpolation type
         */
InterpolationType getInterpolation() const;
⋮----
/**
         * @brief Create a new noise layer
         * @param name Unique name for the layer
         * @return True if layer was created successfully
         */
bool createLayer(const std::string& name);
⋮----
/**
         * @brief Remove a noise layer
         * @param name Name of the layer to remove
         * @return True if layer was found and removed
         */
bool removeLayer(const std::string& name);
⋮----
/**
         * @brief Set a layer's enabled state
         * @param name Name of the layer
         * @param enabled True to enable, false to disable
         * @return True if layer was found
         */
bool setLayerEnabled(const std::string& name, bool enabled);
⋮----
/**
         * @brief Check if a layer is enabled
         * @param name Name of the layer
         * @return True if layer exists and is enabled
         */
bool isLayerEnabled(const std::string& name) const;
⋮----
/**
         * @brief Set a layer's noise type
         * @param name Name of the layer
         * @param type The noise type to use
         * @return True if layer was found
         */
bool setLayerNoiseType(const std::string& name, NoiseType type);
⋮----
/**
         * @brief Set a layer's fractal type
         * @param name Name of the layer
         * @param type The fractal type to use
         * @return True if layer was found
         */
bool setLayerFractalType(const std::string& name, FractalType type);
⋮----
/**
         * @brief Set a layer's frequency
         * @param name Name of the layer
         * @param frequency The frequency value
         * @return True if layer was found
         */
bool setLayerFrequency(const std::string& name, float frequency);
⋮----
/**
         * @brief Set a layer's amplitude
         * @param name Name of the layer
         * @param amplitude The amplitude value
         * @return True if layer was found
         */
bool setLayerAmplitude(const std::string& name, float amplitude);
⋮----
/**
         * @brief Set a layer's octaves
         * @param name Name of the layer
         * @param octaves The octave count
         * @return True if layer was found
         */
bool setLayerOctaves(const std::string& name, int octaves);
⋮----
/**
         * @brief Set a layer's persistence
         * @param name Name of the layer
         * @param persistence The persistence value
         * @return True if layer was found
         */
bool setLayerPersistence(const std::string& name, float persistence);
⋮----
/**
         * @brief Set a layer's lacunarity
         * @param name Name of the layer
         * @param lacunarity The lacunarity value
         * @return True if layer was found
         */
bool setLayerLacunarity(const std::string& name, float lacunarity);
⋮----
/**
         * @brief Set a layer's offset
         * @param name Name of the layer
         * @param offset The offset vector
         * @return True if layer was found
         */
bool setLayerOffset(const std::string& name, const glm::vec3& offset);
⋮----
/**
         * @brief Set a layer's scale
         * @param name Name of the layer
         * @param scale The scale vector
         * @return True if layer was found
         */
bool setLayerScale(const std::string& name, const glm::vec3& scale);
⋮----
/**
         * @brief Set a layer's weight in the final result
         * @param name Name of the layer
         * @param weight The weight value [0.0-1.0]
         * @return True if layer was found
         */
bool setLayerWeight(const std::string& name, float weight);
⋮----
/**
         * @brief Get a layer's weight
         * @param name Name of the layer
         * @param weight Output parameter for the weight value
         * @return True if layer was found
         */
bool getLayerWeight(const std::string& name, float& weight) const;
⋮----
/**
         * @brief Set the operation used to combine this layer with previous layers
         * @param name Name of the layer
         * @param operation The combine operation
         * @return True if layer was found
         */
bool setLayerCombineOperation(const std::string& name, CombineOperation operation);
⋮----
/**
         * @brief Get a layer's combine operation
         * @param name Name of the layer
         * @param operation Output parameter for the operation
         * @return True if layer was found
         */
bool getLayerCombineOperation(const std::string& name, CombineOperation& operation) const;
⋮----
/**
         * @brief Get the names of all layers
         * @return Vector of layer names
         */
std::vector<std::string> getLayerNames() const;
⋮----
/**
         * @brief Get the number of layers
         * @return The layer count
         */
size_t getLayerCount() const;
⋮----
/**
         * @brief Set a custom modifier function to apply after noise generation
         * @param modifier Function that takes a noise value and returns a modified value
         */
void setModifier(std::function<float(float)> modifier);
⋮----
/**
         * @brief Clear the custom modifier function
         */
void clearModifier();
⋮----
/**
         * @brief Preset for terrain height map
         * @param mountainous If true, more dramatic elevation changes
         * @return True if preset was applied successfully
         */
bool presetTerrain(bool mountainous = false);
⋮----
/**
         * @brief Preset for cave generation
         * @return True if preset was applied successfully
         */
bool presetCaves();
⋮----
/**
         * @brief Preset for ore/resource distribution
         * @return True if preset was applied successfully
         */
bool presetOreDistribution();
⋮----
/**
         * @brief Preset for biome blending
         * @return True if preset was applied successfully
         */
bool presetBiomeBlend();
⋮----
/**
         * @brief Preset for detailed texture variation
         * @return True if preset was applied successfully
         */
bool presetDetailTexture();
⋮----
/**
         * @brief Serialize the generator configuration
         * @param serializer The serializer to serialize with
         */
void serialize(ECS::Serializer& serializer) const;
⋮----
/**
         * @brief Deserialize the generator configuration
         * @param deserializer The deserializer to deserialize with
         */
void deserialize(ECS::Deserializer& deserializer);
⋮----
// Internal structure for a noise layer
struct NoiseLayer
⋮----
// Private helper methods
/**
         * @brief Generate for a single coordinate
         * @param type Noise type to utilize
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @returns idk a float I guess
         */
float generateSingle(NoiseType type, float x, float y, float z) const;
⋮----
/**
         * @brief Generate for a single coordinate with fractal
         * @param noiseType Noise type to utilize
         * @param fractalType Fractal type to utilize
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @param octaves The amount of octaves to utilize in fractal
         * @param persistence The persistence of the fractal
         * @param lacunarity The lacunarity of the fractal
         * @returns idk a float I guess
         */
float generateFractal(NoiseType noiseType, FractalType fractalType, float x, float y, float z,
⋮----
/**
         * @brief Computes the warp for a single coordinate
         * @param type Warp type to compute for
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @param amplitude Amplitude of the warp to calculate with
         * @param frequency Frequency of the warp to calculate with
         * @returns idk a float I guess
         */
float computeWarp(WarpType type, float x, float y, float z, float amplitude, float frequency) const;
⋮----
/**
         * @brief Interpolate between values by interpolation type
         * @param InterpolationType Interpolation type to utilize
         * @param a Starting value
         * @param b End value
         * @param t Time to step by
         * @returns Next interpolated value
         */
float interpolate(InterpolationType type, float a, float b, float t) const;
⋮----
/**
         * @brief Combine two values together using a combine operation by weight
         * @param a First value
         * @param b Second value
         * @param op Combine operation to use
         * @param weight Weight to combine by
         */
float combineValues(float a, float b, CombineOperation op, float weight) const;
⋮----
/**
         * @brief Apply scale and offset to particular point
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @param scale Vector scale to apply
         * @param offset Vector offset to apply
         * @returns Vector point with applied offset and scale
         */
glm::vec3 applyScaleAndOffset(float x, float y, float z, const glm::vec3& scale, const glm::vec3& offset) const;
⋮----
/**
         * @brief Validate the parameters of the generator
         */
void validateParameters();
⋮----
/**
         * @brief Helper function for value noise
         * @param x X coordinate
         * @param y Y coordinate
         * @param z Z coordinate
         * @return Calculated value noise
         */
float valueNoise(int x, int y, int z) const;
⋮----
// Private member variables
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/ProceduralGenerationSystem.h">
// -------------------------------------------------------------------------
// ProceduralGenerationSystem.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Procedural Generation System for voxel-based world creation
     * 
     * This subsystem manages the procedural generation process for voxel worlds,
     * including terrain formation, biome distribution, and feature placement.
     * It supports both runtime generation and offline pre-generation.
     */
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~ProceduralGenerationSystem();
⋮----
/**
         * @brief Initialize the subsystem
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the subsystem
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Render debug visualization (if applicable)
         */
void render() override;
⋮----
/**
         * @brief Shut down the subsystem and release resources
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the module's dependencies
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Generate a single chunk
         * @param coord The chunk coordinate
         * @param chunk Reference to the chunk to populate
         * @param parametersId ID of the generation parameters to use (defaults to active)
         * @return True if generation was successful
         */
bool generateChunk(const ChunkCoord& coord, Chunk& chunk, const std::string& parametersId = "");
⋮----
/**
         * @brief Generate multiple chunks within a region
         * @param min Minimum chunk coordinate
         * @param max Maximum chunk coordinate
         * @param grid Reference to the grid to populate
         * @param parametersId ID of the generation parameters to use (defaults to active)
         * @return Number of chunks successfully generated
         */
int generateRegion(const ChunkCoord& min, const ChunkCoord& max, Grid& grid, const std::string& parametersId = "");
⋮----
/**
         * @brief Generate chunks around a point within a radius
         * @param center World-space center point
         * @param radius Radius in world units
         * @param grid Reference to the grid to populate
         * @param parametersId ID of the generation parameters to use (defaults to active)
         * @return Number of chunks successfully generated
         */
int generateAroundPoint(const glm::vec3& center, float radius, Grid& grid, const std::string& parametersId = "");
⋮----
/**
         * @brief Create new generation parameters
         * @param id Unique identifier for the parameters
         * @return Shared pointer to the created parameters, nullptr if already exists
         */
std::shared_ptr<GenerationParameters> createParameters(const std::string& id);
⋮----
/**
         * @brief Get generation parameters by ID
         * @param id Identifier of the parameters
         * @return Shared pointer to the parameters, nullptr if not found
         */
std::shared_ptr<GenerationParameters> getParameters(const std::string& id) const;
⋮----
/**
         * @brief Set the active generation parameters
         * @param id Identifier of the parameters to set as active
         * @return True if parameters were found and set as active
         */
bool setActiveParameters(const std::string& id);
⋮----
/**
         * @brief Get the active generation parameters
         * @return Shared pointer to the active parameters, nullptr if none
         */
std::shared_ptr<GenerationParameters> getActiveParameters() const;
⋮----
/**
         * @brief Create a noise generator
         * @param id Unique identifier for the generator
         * @return Shared pointer to the created generator, nullptr if already exists
         */
std::shared_ptr<NoiseGenerator> createNoiseGenerator(const std::string& id);
⋮----
/**
         * @brief Get a noise generator by ID
         * @param id Identifier of the generator
         * @return Shared pointer to the generator, nullptr if not found
         */
std::shared_ptr<NoiseGenerator> getNoiseGenerator(const std::string& id) const;
⋮----
/**
         * @brief Create a feature placement controller
         * @param id Unique identifier for the placement controller
         * @return Shared pointer to the created placement controller, nullptr if already exists
         */
std::shared_ptr<FeaturePlacement> createFeaturePlacement(const std::string& id);
⋮----
/**
         * @brief Get a feature placement controller by ID
         * @param id Identifier of the placement controller
         * @return Shared pointer to the placement controller, nullptr if not found
         */
std::shared_ptr<FeaturePlacement> getFeaturePlacement(const std::string& id) const;
⋮----
/**
         * @brief Create a distribution control system
         * @param id Unique identifier for the distribution control
         * @return Shared pointer to the created distribution control, nullptr if already exists
         */
std::shared_ptr<DistributionControl> createDistributionControl(const std::string& id);
⋮----
/**
         * @brief Get a distribution control system by ID
         * @param id Identifier of the distribution control
         * @return Shared pointer to the distribution control, nullptr if not found
         */
std::shared_ptr<DistributionControl> getDistributionControl(const std::string& id) const;
⋮----
/**
         * @brief Load generation parameters from file
         * @param path Path to the parameters file
         * @param id Identifier to assign to the loaded parameters
         * @return Shared pointer to the loaded parameters, nullptr on failure
         */
std::shared_ptr<GenerationParameters> loadParameters(const std::string& path, const std::string& id);
⋮----
/**
         * @brief Save generation parameters to file
         * @param id Identifier of the parameters to save
         * @param path Path to save the parameters to
         * @return True if successfully saved
         */
bool saveParameters(const std::string& id, const std::string& path);
⋮----
/**
         * @brief Get the biome manager
         * @return Shared pointer to the biome manager
         */
std::shared_ptr<BiomeManager> getBiomeManager() const;
⋮----
/**
         * @brief Get the generation seed
         * @return The current generation seed
         */
uint32_t getSeed() const;
⋮----
/**
         * @brief Set the generation seed
         * @param seed The new seed value
         */
void setSeed(uint32_t seed);
⋮----
/**
         * @brief Register a custom feature generator
         * @param name Unique name for the feature
         * @param generator Function to generate the feature
         * @return True if successfully registered
         */
bool registerFeatureGenerator(const std::string& name,
⋮----
/**
         * @brief Get a registered feature generator
         * @param name Name of the feature generator
         * @return The generator function, nullptr if not found
         */
std::function<bool(const GenerationContext&, Chunk&)> getFeatureGenerator(const std::string& name) const;
⋮----
/**
         * @brief Pre-generate and cache chunks in a separate thread
         * @param min Minimum chunk coordinate
         * @param max Maximum chunk coordinate
         * @param priority Generation priority (higher values = higher priority)
         * @return ID of the generation task for tracking
         */
int preGenerateChunks(const ChunkCoord& min, const ChunkCoord& max, int priority = 0);
⋮----
/**
         * @brief Check if a pre-generation task is complete
         * @param taskId ID of the task to check
         * @return True if the task is complete
         */
bool isPreGenerationComplete(int taskId);
⋮----
/**
         * @brief Cancel a pre-generation task
         * @param taskId ID of the task to cancel
         * @return True if the task was found and canceled
         */
bool cancelPreGeneration(int taskId);
⋮----
/**
         * @brief Set whether generation is paused
         * @param paused True to pause generation, false to resume
         */
void setPaused(bool paused);
⋮----
/**
         * @brief Check if generation is paused
         * @return True if generation is paused
         */
bool isPaused() const;
⋮----
/**
         * @brief Create a generation context for a given chunk
         * @param coord The chunk coordinate
         * @param parametersId ID of the generation parameters to use
         * @return The generation context
         */
⋮----
/**
         * @brief Generate terrain for the chunk
         * @param context Generation context for terrain
         * @param chunk Chunk to generate terrain in
         * @return True if generated successfully
         */
⋮----
/**
         * @brief Generate features for the chunk
         * @param context Generation context for features
         * @param chunk Chunk to generate features in
         * @return True if generated successfully
         */
⋮----
/**
         * @brief Generate biomes for the chunk
         * @param context Generation context for biomes
         * @param chunk Chunk to generate biomes in
         * @return True if generated successfully
         */
⋮----
/**
         * @brief Process the generation queue
         */
void processGenerationQueue();
⋮----
/**
         * @brief Update the neighboring chunks
         * @param coord Chunk to update neighbors of
         * @param grid Grid that chunk exists in
         */
void updateNeighborChunks(const ChunkCoord& coord, Grid& grid);
⋮----
// Member variables
⋮----
// Pre-generation task tracking
struct GenerationTask
⋮----
/**
     * @brief Context for chunk generation
     * 
     * Contains all necessary information for generating a chunk, including
     * coordinate, parameters, and references to related systems.
     */
struct GenerationContext
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/StreamingManager.h">
// -------------------------------------------------------------------------
// StreamingManager.h
⋮----
// Forward declarations
⋮----
/**
     * @brief Priority-based streaming system for dynamic chunk loading
     * 
     * StreamingManager handles intelligent loading, unloading, and saving of voxel chunks
     * based on player position, memory constraints, and gameplay importance. It implements
     * a priority-based queue system with support for background processing and memory budgeting
     */
⋮----
/**
         * @brief Defines operations that can be performed on chunks
         */
⋮----
Load,       ///< Load a chunk from storage
Generate,   ///< Generate a new chunk
Mesh,       ///< Generate mesh for a chunk
Save,       ///< Save a chunk to storage
Unload      ///< Unload a chunk from memory
⋮----
/**
         * @brief Priority levels for chunk operations
         */
enum class Priority
⋮----
Critical = 0,   ///< Highest priority (camera position)
High = 1,       ///< Important chunks (near player, gameplay)
Medium = 2,     ///< Standard priority chunks
Low = 3,        ///< Background loading with no urgency
VeryLow = 4     ///< Only process when idle
⋮----
/**
         * @brief Streaming task definition
         */
struct StreamingTask
⋮----
ChunkCoord coord;             ///< Coordinate of the chunk
ChunkOperation operation;     ///< Operation to perform
Priority priority;            ///< Task priority
uint64_t timestamp;           ///< When the task was created
size_t estimatedMemory;       ///< Estimated memory usage
std::atomic<bool> canceled;   ///< Whether the task is canceled
⋮----
/**
             * @brief Default constructor
             */
⋮----
/**
             * @brief Copy constructor
             */
⋮----
, canceled(other.canceled.load())
⋮----
/**
             * @brief Assignment operator
             */
⋮----
/**
             * @brief Comparison operator for priority queue
             */
⋮----
/**
         * @brief Memory budget constraints
         */
struct MemoryBudget
⋮----
size_t maxChunkMemory;      ///< Maximum memory for chunks
size_t maxMeshMemory;       ///< Maximum memory for chunk meshes
size_t reserveMemory;       ///< Reserved memory for critical operations
⋮----
size_t currentChunkMemory;  ///< Current chunk memory usage
size_t currentMeshMemory;   ///< Current mesh memory usage
⋮----
/**
         * @brief Constructor
         */
⋮----
/**
         * @brief Destructor
         */
virtual ~StreamingManager();
⋮----
/**
         * @brief Initialize the streaming system
         * @return True if initialization was successful
         */
bool initialize() override;
⋮----
/**
         * @brief Update the streaming system based on player position and priorities
         * @param deltaTime Time since last update
         */
void update(float deltaTime) override;
⋮----
/**
         * @brief Render debug visualization (if applicable)
         */
void render() override;
⋮----
/**
         * @brief Shut down the streaming system and release resources
         */
void shutdown() override;
⋮----
/**
         * @brief Get the name of the subsystem
         * @return The subsystem name
         */
std::string getName() const override
⋮----
/**
         * @brief Get the subsystem dependencies
         * @return Vector of dependency subsystem names
         */
std::vector<std::string> getDependencies() const override;
⋮----
/**
         * @brief Request a chunk to be loaded or generated with specified priority
         * @param coord Chunk coordinate
         * @param priority Operation priority
         * @return True if the request was accepted
         */
⋮----
/**
         * @brief Request chunk mesh generation with specified priority
         * @param coord Chunk coordinate
         * @param priority Operation priority
         * @return True if the request was accepted
         */
bool requestChunkMesh(const ChunkCoord& coord, Priority priority = Priority::Medium);
⋮----
/**
         * @brief Request a chunk to be saved
         * @param coord Chunk coordinate
         * @param priority Operation priority
         * @return True if the request was accepted
         */
bool requestChunkSave(const ChunkCoord& coord, Priority priority = Priority::Low);
⋮----
/**
         * @brief Request a chunk to be unloaded
         * @param coord Chunk coordinate
         * @param priority Operation priority
         * @return True if the request was accepted
         */
bool requestChunkUnload(const ChunkCoord& coord, Priority priority = Priority::Low);
⋮----
/**
         * @brief Cancel all pending tasks for a specific chunk
         * @param coord Chunk coordinate
         * @return Number of tasks canceled
         */
int cancelChunkTasks(const ChunkCoord& coord);
⋮----
/**
         * @brief Set the focus point for streaming operations (usually player position)
         * @param position World position to focus on
         * @param radius Primary streaming radius
         */
void setFocusPoint(const glm::vec3& position, float radius);
⋮----
/**
         * @brief Add a secondary focus point (important gameplay area)
         * @param position World position of secondary focus
         * @param radius Streaming radius for this point
         * @param priority Priority for this region
         * @return ID of the focus point for later removal
         */
int addFocusPoint(const glm::vec3& position, float radius, Priority priority = Priority::High);
⋮----
/**
         * @brief Remove a secondary focus point
         * @param id ID of the focus point to remove
         * @return True if the focus point was removed
         */
bool removeFocusPoint(int focusPointId);
⋮----
/**
         * @brief Set memory budget constraints
         * @param chunkMemory Maximum memory for chunks (in bytes)
         * @param meshMemory Maximum memory for chunk meshes (in bytes)
         * @param reserveMemory Memory reserved for critical operations (in bytes)
         */
void setMemoryBudget(size_t chunkMemory, size_t meshMemory, size_t reserveMemory);
⋮----
/**
         * @brief Get current memory usage statistics
         * @return Current memory budget state
         */
const MemoryBudget& getMemoryUsage() const;
⋮----
/**
         * @brief Set the number of worker threads for background operations
         * @param numThreads Number of threads to use
         */
void setWorkerThreadCount(int numThreads);
⋮----
/**
         * @brief Get the number of pending tasks
         * @return Total pending task count
         */
size_t getPendingTaskCount() const;
⋮----
/**
         * @brief Get the number of active tasks
         * @return Currently executing task count
         */
size_t getActiveTaskCount() const;
⋮----
/**
         * @brief Check if a chunk is being processed
         * @param coord Chunk coordinate
         * @return True if any task for this chunk is pending or active
         */
bool isChunkProcessing(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Secondary focus point definition
         */
struct FocusPoint
⋮----
int id;                   ///< Unique identifier
glm::vec3 position;       ///< World position
float radius;             ///< Influence radius
Priority priority;        ///< Priority level
⋮----
/**
         * @brief Worker thread function for processing tasks
         * @param threadIndex Index of this worker thread
         */
void workerThread(int threadIndex);
⋮----
/**
         * @brief Evaluate chunks around focus points for loading/unloading
         */
void updateChunkRequests();
⋮----
/**
         * @brief Process a single streaming task
         * @param task Task to process
         * @return True if the task was processed successfully
         */
bool processTask(StreamingTask& task);
⋮----
/**
         * @brief Generate a new chunk
         * @param coord Chunk coordinate
         * @param task Task reference for cancellation check
         * @return True if generation was successful
         */
bool generateChunk(const ChunkCoord& coord, StreamingTask& task);
⋮----
/**
         * @brief Load a chunk from storage
         * @param coord Chunk coordinate
         * @param task Task reference for cancellation check
         * @return True if loading was successful
         */
bool loadChunk(const ChunkCoord& coord, StreamingTask& task);
⋮----
/**
         * @brief Generate mesh for a chunk
         * @param coord Chunk coordinate
         * @param task Task reference for cancellation check
         * @return True if mesh generation was successful
         */
bool generateChunkMesh(const ChunkCoord& coord, StreamingTask& task);
⋮----
/**
         * @brief Save a chunk to storage
         * @param coord Chunk coordinate
         * @param task Task reference for cancellation check
         * @return True if saving was successful
         */
bool saveChunk(const ChunkCoord& coord, StreamingTask& task);
⋮----
/**
         * @brief Unload a chunk from memory
         * @param coord Chunk coordinate
         * @param task Task reference for cancellation check
         * @return True if unloading was successful
         */
bool unloadChunk(const ChunkCoord& coord, StreamingTask& task);
⋮----
/**
         * @brief Calculate priority based on distance to focus points
         * @param coord Chunk coordinate
         * @return Calculated priority level
         */
Priority calculatePriority(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Check if there is enough budget for a new resource
         * @param chunkMemory Required chunk memory (bytes)
         * @param meshMemory Required mesh memory (bytes)
         * @param isHighPriority Whether this is a high priority operation
         * @return True if budget allows the operation
         */
bool checkMemoryBudget(size_t chunkMemory, size_t meshMemory, bool isHighPriority);
⋮----
/**
         * @brief Update memory usage statistics
         * @param chunkDelta Change in chunk memory (bytes, can be negative)
         * @param meshDelta Change in mesh memory (bytes, can be negative)
         */
void updateMemoryUsage(int64_t chunkDelta, int64_t meshDelta);
⋮----
/**
         * @brief Calculate distance from chunk to nearest focus point
         * @param coord Chunk coordinate
         * @return Distance to nearest focus point
         */
float calculateDistanceToFocus(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Estimate memory requirements for a chunk
         * @param coord Chunk coordinate
         * @return Estimated memory size in bytes
         */
size_t estimatedChunkMemory(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Estimate memory requirements for a chunk mesh
         * @param coord Chunk coordinate
         * @return Estimated memory size in bytes
         */
size_t estimateChunkMeshMemory(const ChunkCoord& coord) const;
⋮----
/**
         * @brief Add a task to the priority queue
         * @param coord Chunk coordinate
         * @param operation Operation type
         * @param priority Priority level
         * @return True if task was added successfully
         */
bool addTask(const ChunkCoord& coord, ChunkOperation operation, Priority priority);
⋮----
/**
         * @brief Start worker threads
         * @param numThreads Number of threads to start
         */
void startWorkerThreads(int numThreads);
⋮----
/**
         * @brief Stop all worker threads
         */
void stopWorkerThreads();
⋮----
// Primary focus point
⋮----
// Secondary focus points
⋮----
// Task management
⋮----
// Memory budget
⋮----
// Worker threads
⋮----
// Dependencies
⋮----
// Statistics
⋮----
// Configuration
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="include/Voxel/Voxel.h">
// -------------------------------------------------------------------------
// Voxel.h
⋮----
/**
     * @brief Basic voxel data structure
     * 
     * Compact representation of a single voxel in the world, containing
     * type information and additional data alues
     */
struct Voxel
⋮----
uint16_t type;     ///< Voxel type (0 = empty/air)
uint16_t data;     ///< Additional data (material ID, rotation, etc.)
⋮----
/**
         * @brief Default constructor (creates empty voxel)
         */
⋮----
/**
         * @brief Constructor with type and data
         * @param _type Voxel type
         * @param _data Additional data
         */
Voxel(uint16_t _type, uint16_t _data) : type(_type), data(_data)
⋮----
/**
         * @brief Check if voxel is empty (air)
         * @return True if voxel is empty
         */
bool isEmpty() const
⋮----
/**
         * @brief Equality comparison operator
         * @param other Voxel to compare with
         * @return True if voxels are identical
         */
⋮----
/**
         * @brief Inequality comparison operator
         * @param other Voxel to compare with
         * @return True if voxels are different
         */
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/ECS/Component.cpp">
// -------------------------------------------------------------------------
// Component.cpp
⋮----
// Component implementation
Component::Component()
⋮----
// Default constructor - initializes with no owner and version 1
⋮----
void Component::initialize()
⋮----
// Base implementation does nothing
// Derived classes should override for specific initialization
⋮----
void Component::serialize(Serializer& serializer)
⋮----
void Component::deserialize(Deserializer& deserializer)
⋮----
// Stub implementation for the base class
std::unique_ptr<FlatBuffers::Schema> Component::getSchema()
⋮----
// Base implementation returns a null schema
// Derived classes should override this with their specific schema
⋮----
void Component::setOwner(EntityID owner)
⋮----
void Component::setEnabled(bool enabled)
⋮----
bool Component::isEnabled() const
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/ComponentRegistry.cpp">
// -------------------------------------------------------------------------
// ComponentRegistry.cpp
⋮----
// Initialize static members
ComponentTypeID ComponentRegistry::s_nextComponentTypeID = 1; // Reserve 0 as invalid ID
⋮----
ComponentRegistry& ComponentRegistry::getInstance()
⋮----
std::string ComponentRegistry::getComponentName(ComponentTypeID typeID)
⋮----
std::lock_guard<std::mutex> lock(s_registryMutex);
⋮----
return ""; // Empty string if not found
⋮----
ComponentTypeID ComponentRegistry::getComponentTypeID(const std::string& name)
⋮----
return INVALID_COMPONENT_TYPE_ID; // Invalid ID if not found
⋮----
std::unique_ptr<Component> ComponentRegistry::createComponent(ComponentTypeID typeID)
⋮----
std::unique_ptr<Component> ComponentRegistry::createComponent(const std::string& name)
⋮----
bool ComponentRegistry::isSerializable(ComponentTypeID typeID)
⋮----
return false; // Default to false if not explicitly set
⋮----
void ComponentRegistry::setSerializable(ComponentTypeID typeID, bool serializable)
⋮----
// Verify the component type exists
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Deserializer.cpp">
// -------------------------------------------------------------------------
// Deserializer.cpp
⋮----
Deserializer::Deserializer(std::istream& stream, ByteOrder byteOrder)
⋮----
// Determine if we need to check the platform's endianness
⋮----
// Detect native byte order
⋮----
// If first byte is 1, we're big endian
// If first byte is 2, we're little endian
⋮----
// Nothing to clean up
⋮----
void Deserializer::setRegistry(std::weak_ptr<Registry> registry)
⋮----
void Deserializer::readBool(bool& value)
⋮----
void Deserializer::readInt16(int16_t& value)
⋮----
void Deserializer::readUInt16(uint16_t& value)
⋮----
void Deserializer::readInt32(int32_t& value)
⋮----
void Deserializer::readUInt32(uint32_t& value)
⋮----
void Deserializer::readInt64(int64_t& value)
⋮----
void Deserializer::readUInt64(uint64_t& value)
⋮----
void Deserializer::readFloat(float& value)
⋮----
void Deserializer::readDouble(double& value)
⋮----
void Deserializer::readString(std::string& value)
⋮----
// Read string length
⋮----
// Allocate buffer and read the string data
⋮----
void Deserializer::readBytes(void* data, size_t size)
⋮----
EntityID Deserializer::readEntityRef()
⋮----
// Read the UUID
⋮----
// Get appropriate size based on UUID implementation
uint8_t uuidData[16]; // Assuming 128-bit UUID (16 bytes)
⋮----
// Construct UUID from the raw data
⋮----
// If UUID is null (all zeros), return invalid entity
⋮----
// Resolve the entity through registry
⋮----
void Deserializer::readVec2(glm::vec2& value)
⋮----
void Deserializer::readVec3(glm::vec3& value)
⋮----
void Deserializer::readVec4(glm::vec4& value)
⋮----
void Deserializer::readQuat(glm::quat& value)
⋮----
void Deserializer::readMat4(glm::mat4& value)
⋮----
// Read matrix in column-major order (same as glm)
⋮----
bool Deserializer::beginObject(const std::string& name)
⋮----
// Read object marker
⋮----
// Check if this is actually an object
⋮----
{ // '{' character in ASCII
// Not an object, put the marker back
⋮----
// Read object name
⋮----
// Check if the name matches
⋮----
// Push object name onto stack for context tracking
⋮----
void Deserializer::endObject()
⋮----
// Read object end marker
⋮----
// Check if this is a valid object end marker
⋮----
{ // '}' character in ASCII
⋮----
// Pop object from stack
⋮----
bool Deserializer::beginArray(const std::string& name, size_t& size)
⋮----
// Read array marker
⋮----
// Check if this is actually an array
⋮----
{ // '[' character in ASCII
// Not an array, put the marker back
⋮----
// Read array name
⋮----
// Read array size
⋮----
// Push array name onto stack for context tracking
⋮----
void Deserializer::endArray()
⋮----
// Read array end marker
⋮----
// Check if this is a valid array end marker
⋮----
{ // ']' character in ASCII
⋮----
// Pop array from stack
⋮----
const uint8_t* Deserializer::readFlatBuffer(size_t& size)
⋮----
// Read the buffer size
⋮----
// Resize the internal buffer to hold the data
⋮----
// Read the buffer data
⋮----
size_t Deserializer::getPosition() const
⋮----
void Deserializer::align(size_t alignment)
⋮----
// Calculate padding needed to reach alignment
⋮----
// Skip padding bytes
⋮----
bool Deserializer::isEndOfStream() const
⋮----
uint32_t Deserializer::readVersion()
⋮----
// Read version marker
⋮----
// Check if this is a version marker
⋮----
{ // 'V' character in ASCII
// Not a version marker, put it back
⋮----
// Read version number
⋮----
bool Deserializer::hasError() const
⋮----
std::string Deserializer::getErrorMessage() const
⋮----
void Deserializer::readRaw(void* data, size_t size)
⋮----
// Read the data from the stream
⋮----
// Check if we read the expected amount
⋮----
bool Deserializer::needByteSwap() const
⋮----
// If the current byte order is the same as the stream's, no swap is needed
⋮----
// Runtime detection - we already determined our byte order constructor
⋮----
void Deserializer::setError(const std::string& message)
⋮----
// Add context information based on object stack
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Entity.cpp">
// -------------------------------------------------------------------------
// Entity.cpp
⋮----
Entity::Entity() : m_id(INVALID_ENTITY_ID)
⋮----
// Default constructor creates a null entity
⋮----
Entity::Entity(EntityID id, std::weak_ptr<Registry> registry)
⋮----
// Constructor with ID and registry reference
⋮----
bool Entity::isValid() const
⋮----
void Entity::destroy()
⋮----
const ComponentMask& Entity::getComponentMask() const
⋮----
void Entity::serialize(Serializer& serializer)
⋮----
void Entity::deserialize(Deserializer& deserializer)
⋮----
UUID Entity::getUUID() const
⋮----
void Entity::setUUID(const UUID& uuid)
⋮----
void Entity::setNeedsUUID(bool needsUUID)
⋮----
bool Entity::needsUUID() const
⋮----
void Entity::setName(const std::string& name)
⋮----
std::string Entity::getName() const
⋮----
void Entity::addTag(const std::string& tag)
⋮----
void Entity::removeTag(const std::string& tag)
⋮----
bool Entity::hasTag(const std::string& tag) const
⋮----
void Entity::setParent(Entity parent)
⋮----
Entity Entity::getParent() const
⋮----
std::vector<Entity> Entity::getChildren() const
⋮----
void Entity::setActive(bool active)
⋮----
bool Entity::isActive() const
⋮----
std::shared_ptr<Registry> Entity::getRegistry() const
⋮----
bool Entity::isNull() const
⋮----
Entity Entity::Null()
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/EntityMetadata.cpp">
// -------------------------------------------------------------------------
// EntityMetadata.cpp
⋮----
void EntityMetadata::registerEntity(EntityID entity, bool generateUUID)
⋮----
std::unique_lock lock(m_metadataMutex);
⋮----
// Add entity to metadata storage
m_entityNames[entity] = ""; // Empty name by default
⋮----
// Generate UUID if requested
⋮----
// Just mark that this entity should have a UUID generated when needed
⋮----
void EntityMetadata::removeEntity(EntityID entity)
⋮----
// Remove from name storage
⋮----
// Remove from UUID storage
⋮----
// Remove from tag storage
⋮----
// Remove from hierarchy storage
⋮----
// Remove from active state storage
⋮----
void EntityMetadata::clear()
⋮----
bool EntityMetadata::setName(EntityID entity, const std::string& name)
⋮----
// Check if name is already in use by another entity
⋮----
// Remove old name mapping if present
⋮----
// Set new name
⋮----
std::string EntityMetadata::getName(EntityID entity) const
⋮----
std::shared_lock lock(m_metadataMutex);
⋮----
bool EntityMetadata::setUUID(EntityID entity, const UUID& uuid)
⋮----
// Check if UUID is already in use by another entity
⋮----
// Remove old UUID mapping if present
⋮----
// Remove entity needing UUID if present
⋮----
// Add new UUID
⋮----
UUID EntityMetadata::getUUID(EntityID entity) const
⋮----
EntityID EntityMetadata::getEntityByUUID(const UUID& uuid) const
⋮----
EntityID EntityMetadata::findEntityByName(const std::string& name) const
⋮----
bool EntityMetadata::addTag(EntityID entity, const std::string& tag)
⋮----
// Add tag to entity
⋮----
// Add entity to tag
⋮----
bool EntityMetadata::removeTag(EntityID entity, const std::string& tag)
⋮----
// Remove tag from entity
⋮----
// Remove entity from tag
⋮----
bool EntityMetadata::hasTag(EntityID entity, const std::string& tag) const
⋮----
std::vector<EntityID> EntityMetadata::findEntitiesByTag(const std::string& tag) const
⋮----
std::vector<std::string> EntityMetadata::getAllTagsForEntity(EntityID entity) const
⋮----
void EntityMetadata::setEntityNeedsUUID(EntityID entity, bool needsUUID)
⋮----
// Generate UUID if not already present
⋮----
bool EntityMetadata::entityNeedsUUID(EntityID entity) const
⋮----
bool EntityMetadata::setParent(EntityID entity, EntityID parent)
⋮----
// Prevent circular hierarchies
⋮----
// Remove from old parent
⋮----
// Set new parent
⋮----
EntityID EntityMetadata::getParent(EntityID entity) const
⋮----
std::vector<EntityID> EntityMetadata::getChildren(EntityID entity) const
⋮----
bool EntityMetadata::setActive(EntityID entity, bool active)
⋮----
bool EntityMetadata::isActive(EntityID entity) const
⋮----
bool EntityMetadata::entityExists(EntityID entity) const
⋮----
// Assumes metadata mutex is already locked
⋮----
void EntityMetadata::generateUUID(EntityID entity)
⋮----
// Generate a random UUID
⋮----
// Ensure it's unique
⋮----
// Store the UUID
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Error.cpp">
//// -------------------------------------------------------------------------
//// Error.cpp
⋮----
//#include "ECS/Error.h"
//
//#include <sstream>
//#include <iomanip>
⋮----
//namespace PixelCraft::ECS
//{
//    ErrorContext::ErrorContext(const std::source_location& loc)
//        : file(loc.file_name())
//        , line(loc.line())
//        , function(loc.function_name())
//    {
//        // In a real implementation, we'd capture stack trace here
//        // This would typically use platform-specific APIs:
//        // - Windows: CaptureStackBackTrace + SymFromAddr
//        // - POSIX: backtrace + backtrace_symbols
⋮----
//#ifdef PIXELCRAFT_DEBUG
//// Simplified pseudo-implementation for stack trace:
//// stackTrace = captureStackTrace();
//#endif
//    }
⋮----
//    Error::Error(ErrorCode code, const std::string& message)
//        : m_code(code)
//        , m_message(message)
//        , m_context(std::nullopt)
//        , m_innerError(nullptr)
⋮----
//    Error::Error(ErrorCode code, const std::string& message, const std::source_location& loc)
⋮----
//        , m_context(ErrorContext(loc))
⋮----
//    Error::Error(ErrorCode code, const std::string& message, std::shared_ptr<Error> inner)
⋮----
//        , m_innerError(inner)
⋮----
//    ErrorCategory Error::category() const
⋮----
//        // Determine category based on error code range
//        int codeValue = static_cast<int>(m_code);
⋮----
//        if (m_code == ErrorCode::None)
//        {
//            return ErrorCategory::None;
//        }
//        else if (codeValue >= 100 && codeValue < 200)
⋮----
//            return ErrorCategory::Entity;
⋮----
//        else if (codeValue >= 200 && codeValue < 300)
⋮----
//            return ErrorCategory::Component;
⋮----
//        else if (codeValue >= 300 && codeValue < 400)
⋮----
//            return ErrorCategory::System;
⋮----
//        else if (codeValue >= 400 && codeValue < 500)
⋮----
//            return ErrorCategory::Serialization;
⋮----
//        else if (codeValue >= 500 && codeValue < 600)
⋮----
//            return ErrorCategory::IO;
⋮----
//        else if (codeValue >= 600 && codeValue < 700)
⋮----
//            return ErrorCategory::Memory;
⋮----
//        else if (codeValue >= 700 && codeValue < 800)
⋮----
//            return ErrorCategory::Threading;
⋮----
//        else if (codeValue >= 800 && codeValue < 900)
⋮----
//            return ErrorCategory::Validation;
⋮----
//        return ErrorCategory::Unknown;
⋮----
//    std::string Error::toString() const
⋮----
//        if (isNone())
⋮----
//            return "No error";
⋮----
//        std::stringstream ss;
⋮----
//        // Format: [Category.ErrorCode] Message
//        ss << "[" << static_cast<int>(category()) << "."
//            << static_cast<int>(m_code) << "] " << m_message;
⋮----
//        // Add inner error reference if present
//        if (m_innerError)
⋮----
//            ss << " (Caused by: " << m_innerError->toString() << ")";
⋮----
//        return ss.str();
⋮----
//    std::string Error::toDetailedString() const
⋮----
//        // Basic error information
//        ss << "Error Code: " << static_cast<int>(m_code) << std::endl;
//        ss << "Category: " << static_cast<int>(category()) << std::endl;
//        ss << "Message: " << m_message << std::endl;
⋮----
//        // Add context information if available
//        if (m_context)
⋮----
//            ss << "Location: " << m_context->file << ":" << m_context->line
//                << " in " << m_context->function << std::endl;
⋮----
//            // Add stack trace if available
//            if (!m_context->stackTrace.empty())
//            {
//                ss << "Stack Trace:" << std::endl;
//                for (size_t i = 0; i < m_context->stackTrace.size(); i++)
//                {
//                    ss << "  " << std::setw(2) << i << ": "
//                        << m_context->stackTrace[i] << std::endl;
//                }
//            }
⋮----
//        // Add inner error details if present
⋮----
//            ss << "Caused by:" << std::endl;
//            ss << "-------------------" << std::endl;
//            ss << m_innerError->toDetailedString();
⋮----
//} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/FlatBufferSerializer.cpp">
// -------------------------------------------------------------------------
// FlatBufferSerializer.cpp
⋮----
// Include component headers
⋮----
// Include generated FlatBuffer headers
⋮----
FlatBufferSerializer::FlatBufferSerializer() : m_builder(1024)
⋮----
// Smart pointers handle cleanup
⋮----
flatbuffers::FlatBufferBuilder& FlatBufferSerializer::createBuilder()
⋮----
void FlatBufferSerializer::resetBuilder()
⋮----
std::vector<uint8_t> FlatBufferSerializer::finishBuffer(const std::string& identifier)
⋮----
// Ensure identifier is exactly 4 characters (FlatBuffer requirement)
⋮----
fileId.resize(4, ' '); // Pad with spaces or truncating
⋮----
bool FlatBufferSerializer::verifyBuffer(const uint8_t* buffer, size_t size, const std::string& expectedIdentifier)
⋮----
// Create a FlatBuffers verifier
flatbuffers::Verifier verifier(buffer, size);
⋮----
// If we have an expected identifier, verify it
⋮----
// Verify minimum size for a buffer with identifier
⋮----
// Check file identifier using FlatBuffers API
⋮----
flatbuffers::Offset<void> FlatBufferSerializer::serializeTransformComponent(const TransformComponent& component)
⋮----
// Create the position, rotation, and scale structures
⋮----
// Get children and convert to a vector of uint32_t
⋮----
// Create the vector of children
⋮----
// Create the TransformComponent
⋮----
bool FlatBufferSerializer::deserializeTransformComponent(const void* bufferData, TransformComponent& component)
⋮----
// Extract the data and update the component
⋮----
// Set parent
⋮----
// Clear existing children and add new ones
⋮----
flatbuffers::Offset<void> FlatBufferSerializer::serializeCameraComponent(const CameraComponent& component)
⋮----
bool FlatBufferSerializer::deserializeCameraComponent(const void* bufferData, CameraComponent& component)
⋮----
/*flatbuffers::Offset<void> FlatBufferSerializer::serializeMeshRendererComponent(const MeshRendererComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing MeshRendererComponent");

        auto meshPath = m_builder.CreateString(component.getMeshPath());
        auto materialPath = m_builder.CreateString(component.getMaterialPath());

        auto meshRendererComponent = CreateMeshRendererComponentData(
            m_builder,
            meshPath,
            materialPath,
            component.getCastShadows(),
            component.getReceiveShadows(),
            component.isEnabled()
        );

        return meshRendererComponent.Union();
    }

    bool FlatBufferSerializer::deserializeMeshRendererComponent(const void* bufferData, MeshRendererComponent& component)
    {
        auto meshRendererData = GetMeshRendererComponentData(bufferData);
        if (!meshRendererData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for MeshRendererComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing MeshRendererComponent");

        if (meshRendererData->mesh_path())
        {
            component.setMeshPath(meshRendererData->mesh_path()->str());
        }

        if (meshRendererData->material_path())
        {
            component.setMaterialPath(meshRendererData->material_path()->str());
        }

        component.setCastShadows(meshRendererData->cast_shadows());
        component.setReceiveShadows(meshRendererData->receive_shadows());
        component.setEnabled(meshRendererData->enabled());

        return true;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeLightComponent(const LightComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing LightComponent");

        auto color = Vec3(
            component.getColor().x,
            component.getColor().y,
            component.getColor().z
        );

        auto lightComponent = CreateLightComponentData(
            m_builder,
            static_cast<LightType>(component.getLightType()),
            &color,
            component.getIntensity(),
            component.getRange(),
            component.getInnerAngle(),
            component.getOuterAngle(),
            component.getCastShadows(),
            component.getShadowBias(),
            component.getShadowResolution()
        );

        return lightComponent.Union();
    }

    bool FlatBufferSerializer::deserializeLightComponent(const void* bufferData, LightComponent& component)
    {
        auto lightData = GetLightComponentData(bufferData);
        if (!lightData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for LightComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing LightComponent");

        component.setLightType(static_cast<LightComponent::LightType>(lightData->light_type()));

        if (auto color = lightData->color())
        {
            component.setColor(glm::vec3(color->x(), color->y(), color->z()));
        }

        component.setIntensity(lightData->intensity());
        component.setRange(lightData->range());
        component.setInnerAngle(lightData->inner_angle());
        component.setOuterAngle(lightData->outer_angle());
        component.setCastShadows(lightData->cast_shadows());
        component.setShadowBias(lightData->shadow_bias());
        component.setShadowResolution(lightData->shadow_resolution());

        return true;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeRigidBodyComponent(const RigidBodyComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing RigidBodyComponent");

        auto linearVelocity = Vec3(
            component.getLinearVelocity().x,
            component.getLinearVelocity().y,
            component.getLinearVelocity().z
        );

        auto angularVelocity = Vec3(
            component.getAngularVelocity().x,
            component.getAngularVelocity().y,
            component.getAngularVelocity().z
        );

        auto rigidBodyComponent = CreateRigidBodyComponentData(
            m_builder,
            static_cast<BodyType>(component.getBodyType()),
            component.getMass(),
            component.getDrag(),
            component.getAngularDrag(),
            component.getUseGravity(),
            component.isKinematic(),
            &linearVelocity,
            &angularVelocity
        );

        return rigidBodyComponent.Union();
    }

    bool FlatBufferSerializer::deserializeRigidBodyComponent(const void* bufferData, RigidBodyComponent& component)
    {
        auto rigidBodyData = GetRigidBodyComponentData(bufferData);
        if (!rigidBodyData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for RigidBodyComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing RigidBodyComponent");

        component.setBodyType(static_cast<RigidBodyComponent::BodyType>(rigidBodyData->body_type()));
        component.setMass(rigidBodyData->mass());
        component.setDrag(rigidBodyData->drag());
        component.setAngularDrag(rigidBodyData->angular_drag());
        component.setUseGravity(rigidBodyData->use_gravity());
        component.setKinematic(rigidBodyData->is_kinematic());

        if (auto linVel = rigidBodyData->linear_velocity())
        {
            component.setLinearVelocity(glm::vec3(linVel->x(), linVel->y(), linVel->z()));
        }

        if (auto angVel = rigidBodyData->angular_velocity())
        {
            component.setAngularVelocity(glm::vec3(angVel->x(), angVel->y(), angVel->z()));
        }

        return true;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeColliderComponent(const ColliderComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing ColliderComponent");

        auto size = Vec3(
            component.getSize().x,
            component.getSize().y,
            component.getSize().z
        );

        auto materialName = m_builder.CreateString(component.getMaterialName());
        auto meshPath = m_builder.CreateString(component.getMeshPath());

        auto colliderComponent = CreateColliderComponentData(
            m_builder,
            static_cast<ColliderType>(component.getColliderType()),
            component.isTrigger(),
            &size,
            component.getRadius(),
            component.getHeight(),
            materialName,
            meshPath
        );

        return colliderComponent.Union();
    }

    bool FlatBufferSerializer::deserializeColliderComponent(const void* bufferData, ColliderComponent& component)
    {
        auto colliderData = GetColliderComponentData(bufferData);
        if (!colliderData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for ColliderComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing ColliderComponent");

        component.setColliderType(static_cast<ColliderComponent::ColliderType>(colliderData->collider_type()));
        component.setTrigger(colliderData->is_trigger());

        if (auto size = colliderData->size())
        {
            component.setSize(glm::vec3(size->x(), size->y(), size->z()));
        }

        component.setRadius(colliderData->radius());
        component.setHeight(colliderData->height());

        if (colliderData->material_name())
        {
            component.setMaterialName(colliderData->material_name()->str());
        }

        if (colliderData->mesh_path())
        {
            component.setMeshPath(colliderData->mesh_path()->str());
        }

        return true;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeAudioSourceComponent(const AudioSourceComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing AudioSourceComponent");

        auto audioClipPath = m_builder.CreateString(component.getAudioClipPath());

        auto audioSourceComponent = CreateAudioSourceComponentData(
            m_builder,
            audioClipPath,
            component.getVolume(),
            component.getPitch(),
            component.isLooping(),
            component.getSpatialBlend(),
            component.getMinDistance(),
            component.getMaxDistance(),
            component.isPlaying()
        );

        return audioSourceComponent.Union();
    }

    bool FlatBufferSerializer::deserializeAudioSourceComponent(const void* bufferData, AudioSourceComponent& component)
    {
        auto audioData = GetAudioSourceComponentData(bufferData);
        if (!audioData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for AudioSourceComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing AudioSourceComponent");

        if (audioData->audio_clip_path())
        {
            component.setAudioClipPath(audioData->audio_clip_path()->str());
        }

        component.setVolume(audioData->volume());
        component.setPitch(audioData->pitch());
        component.setLoop(audioData->loop());
        component.setSpatialBlend(audioData->spatial_blend());
        component.setMinDistance(audioData->min_distance());
        component.setMaxDistance(audioData->max_distance());

        if (audioData->playing())
        {
            component.play();
        }
        else
        {
            component.stop();
        }

        return true;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeParticleSystemComponent(const ParticleSystemComponent& component)
    {
        Log::debug("FlatBufferSerialize: Serializing ParticleSystemComponent");

        auto startColor = Vec3(
            component.getStartColor().x,
            component.getStartColor().y,
            component.getStartColor().z
        );

        auto texturePath = m_builder.CreateString(component.getTexturePath());

        auto particleSystemComponent = CreateParticleSystemComponentData(
            m_builder,
            component.getMaxParticles(),
            component.getEmissionRate(),
            component.getLifetime(),
            component.getStartSpeed(),
            component.getStartSize(),
            &startColor,
            component.getGravityModifier(),
            component.getSimulationSpace() == ParticleSystemComponent::SimulationSpace::World,
            texturePath
        );

        return particleSystemComponent.Union();
    }

    bool FlatBufferSerializer::deserializeParticleSystemComponent(const void* bufferData, ParticleSystemComponent& component)
    {
        auto particleData = GetParticleSystemComponentData(bufferData);
        if (!particleData)
        {
            Log::error("FlatBufferSerializer: Null buffer data for ParticleSystemComponent deserialization");
            return false;
        }

        Log::debug("FlatBufferSerializer: Deserializing ParticleSystemComponent");

        component.setMaxParticles(particleData->max_particles());
        component.setEmissionRate(particleData->emission_rate());
        component.setLifetime(particleData->lifetime());
        component.setStartSpeed(particleData->start_speed());
        component.setStartSize(particleData->start_size());

        if (auto color = particleData->start_color())
        {
            component.setStartColor(glm::vec3(color->x(), color->y(), color->z()));
        }

        component.setGravityModifier(particleData->gravity_modifier());
        component.setSimulationSpace(particleData->simulation_space() ?
                                     ParticleSystemComponent::SimulationSpace::World :
                                     ParticleSystemComponent::SimulationSpace::Local);

        if (particleData->texture_path())
        {
            component.setTexturePath(particleData->texture_path()->str());
        }

        return true;
    }*/
⋮----
/*flatbuffers::Offset<void> FlatBufferSerializer::serializeNavigationAgentComponent(const NavigationAgentComponent& component)
    {
        return flatbuffers::Offset<void>();
    }

    bool FlatBufferSerializer::deserializeNavigationAgentComponent(const void* bufferData, NavigationAgentComponent& component)
    {
        return false;
    }

    flatbuffers::Offset<void> FlatBufferSerializer::serializeAnimatorComponent(const AnimatorComponent& component)
    {
        return flatbuffers::Offset<void>();
    }

    bool FlatBufferSerializer::deserializeAnimatorComponent(const void* bufferData, AnimatorComponent& component)
    {
        return false;
    }*/
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Registry.cpp">
// -------------------------------------------------------------------------
// Registry.cpp
⋮----
Registry::Registry() : m_nextEntityID(1)
⋮----
// Constructor constructor
⋮----
// Acquire exclusive locks for cleanup
std::unique_lock entityLock(m_entityMutex);
std::unique_lock componentLock(m_componentMutex);
⋮----
// Clean up all entities and components
⋮----
// No need to call removeAllComponents since we're cleaning up everything
⋮----
EntityID Registry::createEntity(bool generateUUID)
⋮----
// Add to entity list
⋮----
// Initialize component mask
⋮----
// Register in entity metadata
⋮----
EntityID Registry::createEntity(const std::string& name, bool generateUUID)
⋮----
// First create the entity
⋮----
// Set entity name if provided
⋮----
bool Registry::destroyEntity(EntityID entity)
⋮----
// First validate entity
⋮----
std::shared_lock entityLock(m_entityMutex);
⋮----
// First remove all components
⋮----
// Then remove from entity collections
⋮----
// Remove entity from the registry
⋮----
// Remove from entity metadata
⋮----
bool Registry::isValid(EntityID entity) const
⋮----
void Registry::serialize(EntityID entity, Serializer& serializer)
⋮----
// Ensure entity has UUID for serialization
⋮----
// Begin entity object
⋮----
// Write entity ID
⋮----
// Write entity UUID
⋮----
// Write entity name
⋮----
// Begin components array
⋮----
std::shared_lock componentLock(m_componentMutex);
⋮----
// Serialize each component
⋮----
// Temporarily release lock during component serialization
⋮----
// Begin component object
⋮----
// Write component type ID
⋮----
// Write component name
⋮----
// Serialize component data
⋮----
// End component object
⋮----
// Reacquire lock
⋮----
// End components array
⋮----
// Write tags
⋮----
// Serialize tags array
⋮----
// Write parent entity reference
⋮----
// End entity object
⋮----
void Registry::deserialize(EntityID entity, Deserializer& deserializer)
⋮----
// Read entity ID (and verify it matches)
⋮----
// Read entity UUID
⋮----
// Read entity name
⋮----
// Deserialize each component
⋮----
// Read component type ID
⋮----
// Read component name
⋮----
// Find or create component pool
⋮----
// Try to create component by name
⋮----
// Add component to entity
⋮----
// Get component pool
⋮----
// Deserialize component if pool exists
⋮----
// Update entity mask
⋮----
// Deserialize tags
⋮----
// Read parent entity reference
⋮----
void Registry::serializeAll(Serializer& serializer)
⋮----
// Begin registry object
⋮----
// Write entity count and get a copy of entities
⋮----
// Begin entities array
⋮----
// Serialize each entity
⋮----
// End entities array
⋮----
// Write next entity ID
⋮----
// End registry object
⋮----
void Registry::deserializeAll(Deserializer& deserializer)
⋮----
// Acquire exclusive locks for clearing data
⋮----
// Clear entity metadata
⋮----
// Read entity count
⋮----
// Verify array size
⋮----
// Deserialize each entity
⋮----
// Read entity ID from serialized data
⋮----
// Peek the entity ID from the entity object
⋮----
// Rewind to beginning of entity
⋮----
// Create a new entity with this ID if possible
⋮----
// Create entity with next available ID
⋮----
// Note: In a real implementation, you would need to handle ID collisions
⋮----
// Use normal entity creation
⋮----
// Deserialize entity data
⋮----
// Read next entity ID
⋮----
UUID Registry::getEntityUUID(EntityID entity) const
⋮----
void Registry::setEntityUUID(EntityID entity, const UUID& uuid)
⋮----
EntityID Registry::getEntityByUUID(const UUID& uuid) const
⋮----
void Registry::setEntityName(EntityID entity, const std::string& name)
⋮----
std::string Registry::getEntityName(EntityID entity) const
⋮----
EntityID Registry::findEntityByName(const std::string& name) const
⋮----
void Registry::addTag(EntityID entity, const std::string& tag)
⋮----
void Registry::removeTag(EntityID entity, const std::string& tag)
⋮----
bool Registry::hasTag(EntityID entity, const std::string& tag) const
⋮----
std::vector<EntityID> Registry::findEntitiesByTag(const std::string& tag) const
⋮----
void Registry::setEntityNeedsUUID(EntityID entity, bool needsUUID)
⋮----
bool Registry::entityNeedsUUID(EntityID entity) const
⋮----
bool Registry::setEntityParent(EntityID entity, EntityID parent)
⋮----
EntityID Registry::getEntityParent(EntityID entity) const
⋮----
std::vector<EntityID> Registry::getEntityChildren(EntityID entity) const
⋮----
bool Registry::setEntityActive(EntityID entity, bool active)
⋮----
bool Registry::isEntityActive(EntityID entity) const
⋮----
EntityMetadata& Registry::getEntityMetadata()
⋮----
const EntityMetadata& Registry::getEntityMetadata() const
⋮----
const std::vector<EntityID>& Registry::getEntities() const
⋮----
const ComponentMask& Registry::getEntityMask(EntityID entity) const
⋮----
const std::map<ComponentTypeID, std::shared_ptr<IComponentPool>>& Registry::getAllComponentPools() const
⋮----
size_t Registry::getEntityCount() const
⋮----
void* Registry::getComponentRaw(EntityID entity, ComponentTypeID typeID)
⋮----
void Registry::removeAllComponents(EntityID entity)
⋮----
// Acquire exclusive lock for component operations
⋮----
// Get the entity's component mask
⋮----
// Iterate through all component types
⋮----
// Get the component pool
⋮----
// Remove the component
⋮----
// Clear the component mask
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Scene.cpp">
// -------------------------------------------------------------------------
// Scene.cpp
⋮----
// Components
⋮----
// Schemas
⋮----
Scene::Scene(const std::string& name)
⋮----
, m_schemaVersion(1) // Start with version 1
⋮----
// Save any unsaved data if we have a valid path
⋮----
bool Scene::load(const std::string& path)
⋮----
// Check if the file exists
⋮----
// Clear any existing data
⋮----
// Load entities and chunks
⋮----
// Return success if at least one of them succeeded
⋮----
bool Scene::save(const std::string& path)
⋮----
// Make sure the directory exists
⋮----
// Save entities and chunks
⋮----
// Save modified chunks individually
⋮----
EntityID Scene::instantiate(const std::string& prefabPath)
⋮----
// Check if we have a valid world
⋮----
// Check if the prefab file exists
⋮----
// Load the prefab file
⋮----
// Create a new entity
⋮----
// Deserialize the prefab data into the entity
⋮----
Deserializer deserializer(dataStream);
⋮----
// Add the entity to the scene
⋮----
EntityID Scene::findEntityByName(const std::string& name)
⋮----
std::vector<EntityID> Scene::findEntitiesByTag(const std::string& tag)
⋮----
void Scene::setMainCamera(EntityID cameraEntity)
⋮----
// Check if the entity exists in our world
⋮----
std::vector<uint8_t> Scene::serializeToFlatBuffer()
⋮----
// Use FlatBufferSerializer for efficient zero-copy serialization
⋮----
// Convert root entity vector
⋮----
// Create entity name map entries
⋮----
// Create entity tag map entries
⋮----
// Create dirty chunk coordinates
⋮----
// Create name and path strings
⋮----
// Create the scene FlatBuffer
⋮----
// Finish the buffer with the "SCNE" identifier
⋮----
// Get the serialized buffer
⋮----
bool Scene::deserializeFromFlatBuffer(const uint8_t* data, size_t size)
⋮----
// Validate input parameters
⋮----
// Check for a valid world
⋮----
// Use custom verification for the buffer
flatbuffers::Verifier verifier(data, size);
⋮----
// Get the root scene object from the buffer
⋮----
// Extract basic scene information
⋮----
// Clear existing data
⋮----
// Create entity lookup map for any previously existing entities
⋮----
// Get the registry for component operations
⋮----
// Load entity data
⋮----
// Try to find this entity in the scene storage
// In a real implementation, we would have a separate array with entity data in the FlatBuffer
⋮----
// Load entity from file
⋮----
// Verify this is entity data
⋮----
// Create a new entity with the same ID if possible
⋮----
Entity newEntity(newId, registry);
⋮----
// Deserialize the entity data
⋮----
// Use the entity's FlatBuffer deserialization
⋮----
// Set entity name
⋮----
// Create and add components
⋮----
// Get component type and data
⋮----
// Create and deserialize component based on type
⋮----
// Create TransformComponent
⋮----
// Use FlatBufferSerializer to deserialize
⋮----
// Create CameraComponent
⋮----
// Add cases for other component types as needed
⋮----
// Add entity tags
⋮----
// Add to root entities
⋮----
// Store the entity
⋮----
// Register the entity name
⋮----
// Entity data not found, create a new placeholder entity
⋮----
// register the entity name
⋮----
// Deserialize entity name map
⋮----
// Find the corresponding new entity ID
⋮----
// Deserialize entity tag map
⋮----
// find the corresponding new entity ID
⋮----
// Update main camera reference if needed
⋮----
// Process parent-child relationships for transforms
⋮----
// Get the parent ID
⋮----
// Find the new parent ID
⋮----
// Set the new parent
⋮----
// Deserialize dirty chunks
⋮----
std::vector<uint8_t> Scene::serializeEntityToFlatBuffer(EntityID entity)
⋮----
// Use FlatBufferSerializer for zero-copy serialization
⋮----
// Create name string
⋮----
// Create UUID string
⋮----
// Collect entity tags
⋮----
// Create tags vector
⋮----
// Collect and serialize components
⋮----
// Check for TransformComponent
⋮----
// Check for CameraComponent
⋮----
// Add other component types here as needed
// Example:
// if (e.hasComponent<MeshRendererComponent>()) {
//     auto& meshRenderer = e.getComponent<MeshRendererComponent>();
//     auto meshRendererOffset = serializer.serializeMeshRendererComponent(meshRenderer);
//     componentEntries.push_back(CreateComponentEntry(builder, ComponentType_MeshRenderer, meshRendererOffset));
// }
⋮----
// Create the entity FlatBuffer
⋮----
entity,                 // id
nameOffset,             // name
uuidOffset,             // uuid
componentsOffset,       // components
tagsOffset              // tags
⋮----
// Finish the buffer with the "ENTY" identifier
⋮----
// Return the serialized data
⋮----
bool Scene::serializeChunk(const Voxel::ChunkCoord& coord)
⋮----
// Ensure the scene directory exists
⋮----
// Get the path for this chunk
⋮----
// Open the file
std::ofstream file(chunkPath, std::ios::binary);
⋮----
// Create a serializer
Serializer serializer(file);
⋮----
// Serialize the chunk
⋮----
// Remove from dirty chunks if successful
⋮----
bool Scene::deserializeChunk(Voxel::ChunkCoord& coord)
⋮----
// Ensure we have a world reference
⋮----
// Create or get the chunk
⋮----
std::ifstream file(chunkPath, std::ios::binary);
⋮----
// Create a deserializer
Deserializer deserializer(file);
⋮----
// Deserialize the chunk
⋮----
// Remove from dirty chunks
⋮----
void Scene::markChunkDirty(const Voxel::ChunkCoord& coord)
⋮----
// Also mark the chunk as dirty internally
⋮----
bool Scene::isChunkDirty(const Voxel::ChunkCoord& coord) const
⋮----
void Scene::saveModifiedChunks()
⋮----
// Copy dirty chunks to avoid iterator invalidation
⋮----
void Scene::addEntity(EntityID entity)
⋮----
// Add to root entities (unless it has a parent, which would be handled by the parent)
⋮----
bool Scene::removeEntity(EntityID entity)
⋮----
// Unregister the entity name
⋮----
// Remove from root entities
⋮----
// If this was the main camera, clear it
⋮----
// Remove any tags
⋮----
std::shared_ptr<Voxel::Chunk> Scene::getChunk(const Voxel::ChunkCoord& coord, bool createIfMissing)
⋮----
// Create a new chunk
⋮----
// Mark as dirty since it's new
⋮----
void Scene::addTag(EntityID entity, const std::string& tag)
⋮----
void Scene::removeTag(EntityID entity, const std::string& tag)
⋮----
// Remove the tag entry is no entities have this tag
⋮----
bool Scene::hasTag(EntityID entity, const std::string& tag) const
⋮----
bool Scene::loadEntities(const std::string& path)
⋮----
// Determine the entity file path
⋮----
// Check if the entity file exists
⋮----
// Read the file
⋮----
std::istringstream stream(dataStr);
Deserializer deserializer(stream);
⋮----
// Deserialize root entities
⋮----
// Deserialize camera reference
⋮----
bool Scene::saveEntities(const std::string& path)
⋮----
std::ofstream file(entityPath, std::ios::binary);
⋮----
// Serialize root entities
⋮----
// Serialize camera reference
⋮----
bool Scene::loadChunks(const std::string& path)
⋮----
// Determine the chunks directory
⋮----
// Check if the chunks directory exists
⋮----
// List all chunk files in the directory
⋮----
// Load each chunk
⋮----
// Parse coordinates from filename
⋮----
Voxel::ChunkCoord coord(x, y, z);
⋮----
bool Scene::saveChunks(const std::string& path)
⋮----
// Just save all modified chunks
⋮----
std::string Scene::getChunkPath(const Voxel::ChunkCoord& coord) const
⋮----
// Create the chunk filename
⋮----
// Return the full path
⋮----
void Scene::serializeEntity(EntityID entity, Serializer& serializer)
⋮----
// Begin entity object
⋮----
// Write entity ID
⋮----
// Write entity name
⋮----
// Write UUID
⋮----
// Write components (handled by entity)
⋮----
// Write tags
⋮----
// End entity object
⋮----
EntityID Scene::deserializeEntity(Deserializer& deserializer)
⋮----
// Read entity ID
⋮----
// Read entity name
⋮----
// Read UUID
⋮----
// Create the entity with the correct UUID
⋮----
// Deserialize components
⋮----
// Read tags
⋮----
void Scene::registerEntityName(EntityID entity, const std::string& name)
⋮----
// Add to name map
⋮----
void Scene::unregisterEntityName(EntityID entity, const std::string& name)
⋮----
// Remove from name map
⋮----
void Scene::updateChunkMesh(const Voxel::ChunkCoord& coord)
⋮----
// Mark the chunk as dirty
⋮----
// This would trigger mesh regeneration in a real implementation
// For now, just log it
⋮----
std::string Scene::getSceneDirectory() const
⋮----
// Get the directory containing the scene
⋮----
// If the path doesn't have an extension, it's probably a directory itself
⋮----
// Create a scene directory based on the filename
⋮----
bool Scene::ensureSceneDirectoryExists() const
⋮----
// Also ensure the chunks directory exists
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/Serializer.cpp">
// -------------------------------------------------------------------------
// Serializer.cpp
⋮----
// Helper function to detect machine endianness
ByteOrder detectNativeByteOrder()
⋮----
// Constants for object and array markers
⋮----
Serializer::Serializer(std::ostream& stream, ByteOrder byteOrder)
⋮----
// Ensure all objects and arrays are properly closed
⋮----
void Serializer::setRegistry(std::weak_ptr<Registry> registry)
⋮----
void Serializer::write(const T& value)
⋮----
void Serializer::writeBool(bool value)
⋮----
void Serializer::writeInt16(int16_t value)
⋮----
void Serializer::writeUInt16(uint16_t value)
⋮----
void Serializer::writeInt32(int32_t value)
⋮----
void Serializer::writeUInt32(uint32_t value)
⋮----
void Serializer::writeInt64(int64_t value)
⋮----
void Serializer::writeUInt64(uint64_t value)
⋮----
void Serializer::writeFloat(float value)
⋮----
void Serializer::writeDouble(double value)
⋮----
void Serializer::writeString(const std::string& value)
⋮----
// Write string length
⋮----
// Write string data if non-empty
⋮----
void Serializer::writeBytes(const void* data, size_t size)
⋮----
// Write size
⋮----
// Write data if non-empty
⋮----
void Serializer::writeEntityRef(EntityID entity)
⋮----
// Write a null UUID
⋮----
// Get the entity's UUID from the registry and serialize it
// This converts volatile EntityIDs to persistent UUIDs for storage
⋮----
void Serializer::writeVec2(const glm::vec2& value)
⋮----
void Serializer::writeVec3(const glm::vec3& value)
⋮----
void Serializer::writeVec4(const glm::vec4& value)
⋮----
void Serializer::writeQuat(const glm::quat& value)
⋮----
void Serializer::writeMat4(const glm::mat4& value)
⋮----
// GLM matrices are column-major, serialize each column
⋮----
void Serializer::beginObject(const std::string& name)
⋮----
// Write object begin marker
⋮----
// Write object name
⋮----
// Push object name onto stack
⋮----
void Serializer::endObject()
⋮----
// Write object end marker
⋮----
// Pop object name from stack
⋮----
void Serializer::beginArray(const std::string& name, size_t size)
⋮----
// Write array begin marker
⋮----
// Write array name
⋮----
// Write array size
⋮----
// Push array name onto stack
⋮----
void Serializer::endArray()
⋮----
// Write array end marker
⋮----
// Pop array name from stack
⋮----
void Serializer::writeFlatBuffer(const flatbuffers::FlatBufferBuilder& builder)
⋮----
// Get the finished buffer
⋮----
// Write the size and data
⋮----
size_t Serializer::getPosition() const
⋮----
void Serializer::align(size_t alignment)
⋮----
void Serializer::writeVersion(uint32_t version)
⋮----
// Use a special version marker to indicate version info
⋮----
void Serializer::writeRaw(const void* data, size_t size)
⋮----
void Serializer::convertEndianness(T& value)
⋮----
// Byte swap the value
⋮----
bool Serializer::needByteSwap() const
⋮----
// Explicit template instantiations
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/System.cpp">
// -------------------------------------------------------------------------
// System.cpp
⋮----
System::System()
⋮----
// Initialize component mask to empty (no required components)
⋮----
bool System::initialize()
⋮----
// Default implementation does nothing
// Derived systems should override this to perform initialization
⋮----
void System::update(float deltaTime)
⋮----
// Derived systems should override this to perform per-frame updates
⋮----
void System::render()
⋮----
// Derived systems with visual output should override this
⋮----
void System::configure()
⋮----
// Derived systems should override this to set up required components
⋮----
// Store the component mask for efficient entity filtering
⋮----
void System::setWorld(std::weak_ptr<World> world)
⋮----
void System::preSerialize(World& world, Serializer& serializer)
⋮----
// Derived systems should override this to prepare for serialization
⋮----
void System::postDeserialize(World& world, Deserializer& deserializer)
⋮----
// Derived systems should override this to process after deserialization
⋮----
bool System::shouldSerialize() const
⋮----
// By default, systems participate in serialization
⋮----
void System::setPriority(int priority)
⋮----
void System::setSerializationPriority(int priority)
⋮----
void System::setActive(bool active)
⋮----
std::vector<Entity> System::getEntitiesWithComponents(const ComponentMask& mask)
⋮----
// Get world from weak pointer
⋮----
// Get registry from world
⋮----
// Iterate through all entities in the registry
⋮----
// Check if the entity's component mask matches the required mask
⋮----
Entity System::getEntity(EntityID id)
⋮----
return Entity(); // Return an invalid entity
⋮----
// Get entity from world
⋮----
// SystemFactory implementation
⋮----
SystemFactory& SystemFactory::getInstance()
⋮----
std::shared_ptr<System> SystemFactory::createSystem(const std::string& name)
⋮----
std::shared_ptr<System> SystemFactory::createSystem(const std::type_index& typeIndex)
⋮----
std::string SystemFactory::getSystemName(const std::type_index& typeIndex)
⋮----
std::type_index SystemFactory::getSystemTypeIndex(const std::string& name)
⋮----
// Return void type index for invalid name
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/UUID.cpp">
// -------------------------------------------------------------------------
// UUID.cpp
⋮----
// SHA-1 implementation for name-based UUIDs
⋮----
// Thread-local random number generator for UUID generation
⋮----
// Mutex for singleton initialization
⋮----
// Namespace for name-based UUIDs (using a standard namespace from RFC 4122)
// This is the namespace for DNS names
⋮----
// Ensure random engine is properly initialized for this thread
void ensureRandomEngineInitialized()
⋮----
std::lock_guard<std::mutex> lock(initMutex);
⋮----
// Seed with high-quality entropy
⋮----
// Also use the current time for added entropy
⋮----
// Initialize with good entropy from both sources
⋮----
// Use a short alias for the Logger to improve readability
⋮----
UUID::UUID()
⋮----
UUID::UUID(const UUID& other) : m_data(other.m_data)
⋮----
UUID::UUID(UUID&& other) noexcept : m_data(std::move(other.m_data))
⋮----
UUID::UUID(const std::array<uint8_t, 16>& bytes) : m_data(bytes)
⋮----
UUID UUID::fromString(const std::string& str)
⋮----
std::string UUID::toString() const
⋮----
bool UUID::isNull() const
⋮----
// Check if all bytes are zero
⋮----
// Lexicographical comparison of the byte arrays
⋮----
void UUID::serialize(Serializer& serializer)
⋮----
// Write the 16 bytes of raw UUID data
⋮----
void UUID::deserialize(Deserializer& deserializer)
⋮----
// Read the 16 bytes of raw UUID data
⋮----
UUID UUID::createRandom()
⋮----
// Ensure the random engine is initialized
⋮----
// Fill with random bytes
⋮----
// Set version to 4 (random)
⋮----
// Set variant to RFC 4122
⋮----
UUID UUID::createFromName(const std::string& name)
⋮----
// Version 5 UUIDs are created by hashing a namespace UUID and a name
⋮----
// Create a SHA-1 hash of the namespace concatenated with the name
⋮----
// Use the first 16 bytes of the hash for the UUID
⋮----
// Set version to 5 (name-based SHA-1)
⋮----
UUID UUID::createNull()
⋮----
// Fill with zeros
⋮----
void UUID::stringToBytes(const std::string& str, std::array<uint8_t, 16>& bytes)
⋮----
// Clear the bytes array first
⋮----
// Validate string format: 8-4-4-4-12 (36 chars total including hyphens)
⋮----
// Parse the string
⋮----
// Remove hyphens to get a continuous hex string
⋮----
// Convert each byte (2 hex chars)
⋮----
// Reset to null UUID on failure
⋮----
std::string UUID::bytesToString(const std::array<uint8_t, 16>& bytes)
⋮----
// Format: 8-4-4-4-12
// First 4 bytes
⋮----
// Next 2 bytes
⋮----
// Last 6 bytes
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/ECS/World.cpp">
// -------------------------------------------------------------------------
// World.cpp
⋮----
World::World() : m_savingEnabled(false), m_threadRunning(false), m_paused(false)
⋮----
// Create the registry
⋮----
// Shut down the background save thread if it's running
⋮----
// Wait for the thread to finish
⋮----
// Acquire exclusive lock for cleanup
std::unique_lock lock(m_worldMutex);
⋮----
// Clear all systems
⋮----
// Clear the active scene and registry
⋮----
bool World::initialize()
⋮----
// Initialize all registered systems
⋮----
void World::update(float deltaTime)
⋮----
// Early out if paused
⋮----
// Use a system execution lock to prevent concurrent update/render
std::lock_guard executionLock(m_systemExecutionMutex);
⋮----
// Get a copy of the systems vector to avoid holding the world lock during update
⋮----
std::shared_lock worldLock(m_worldMutex);
⋮----
// Update all systems in priority order
⋮----
void World::render()
⋮----
// Get a copy of the systems vector to avoid holding the world lock during render
⋮----
// Call render on all rendering systems
⋮----
EntityID World::createEntity(const std::string& name)
⋮----
// Delegate to Registry
EntityID entity = m_registry->createEntity(true); // Generate UUID by default
⋮----
// Set the entity name if provided
⋮----
// Notify systems about entity creation
⋮----
bool World::destroyEntity(EntityID entity)
⋮----
// Notify systems before destroying the entity
⋮----
// Remove from active scene if present
⋮----
std::shared_lock lock(m_worldMutex);
⋮----
void World::registerSystem(std::shared_ptr<System> system)
⋮----
// Set the system's world reference using weak_ptr
⋮----
// Add to systems list
⋮----
// Add to type map for fast lookups
⋮----
// Re-sort systems based on dependencies
⋮----
Entity World::getEntity(EntityID id)
⋮----
// Create and return an Entity object for the given ID
⋮----
std::shared_ptr<Scene> World::loadScene(const std::string& path)
⋮----
// Notify systems about scene unloading
⋮----
// Clear current scene data
⋮----
// Create new scene
⋮----
// Load the scene from file
⋮----
// Set as active scene
⋮----
// Notify systems about scene loaded
⋮----
bool World::saveScene(const std::string& path)
⋮----
// Get the active scene
⋮----
// If background saving is enabled, queue the save operation
⋮----
// Otherwise perform save immediately
⋮----
void World::serializeWorld(Serializer& serializer)
⋮----
// Call preSerialize on all systems
⋮----
// Serialize all entities and components
⋮----
void World::deserializeWorld(Deserializer& deserializer)
⋮----
// First deserialize all entities and components
⋮----
// Then deserialize system-specific data
⋮----
// Notify systems about world deserialization
⋮----
void World::enableBackgroundSaving(bool enable)
⋮----
// If already in the requested state, do nothing
⋮----
// Start the background save thread if it's not running
⋮----
// Signal the thread to stop and wait for it
⋮----
void World::backgroundSaveThread()
⋮----
// Wait for a task from the queue
⋮----
break; // Queue was shut down
⋮----
// Process the task based on its type
⋮----
// Use the scene's save method directly
⋮----
void World::sortSystems()
⋮----
// Check for cyclic dependencies first
⋮----
// Sort systems based on priority and dependencies
⋮----
// Higher priority comes first
⋮----
// Check dependencies
⋮----
// If a depends on b, b should come first
⋮----
// If b depends on a, a should come first
⋮----
// Otherwise, order by name for stability
⋮----
bool World::hasCyclicDependencies()
⋮----
// Implementation of cycle detection algorithm (DFS)
⋮----
// Initialize all systems as not visited
⋮----
// Helper function for DFS cycle detection
⋮----
// Mark current system as visited and add to recursion stack
⋮----
// Find the system by name
⋮----
// Check all dependencies
⋮----
// If dependent is not visited, check if it leads to cycle
⋮----
// If dependent is already in recursion stack, we found a cycle
⋮----
// Remove from recursion stack
⋮----
// Check for cycles starting from each system
⋮----
void World::notifySystems(const std::string& eventName)
⋮----
// Get a copy of the systems vector to avoid holding the lock during event processing
⋮----
// Notify each system
⋮----
} // namespace PixelCraft::ECS
</file>

<file path="src/Voxel/BiomeManager.cpp">
// -------------------------------------------------------------------------
// BiomeManager.cpp
⋮----
BiomeManager::BiomeManager()
⋮----
// Initialize some default biomes
⋮----
// Nothing specific to clean up
⋮----
int BiomeManager::registerBiome(const std::string& name)
⋮----
// Check if already registered
⋮----
// Generate new ID
⋮----
// Create biome info
⋮----
// Register it
⋮----
bool BiomeManager::removeBiome(int biomeId)
⋮----
// Remove from name map first
⋮----
// Remove from biomes map
⋮----
const BiomeManager::BiomeInfo* BiomeManager::getBiomeInfo(int biomeId) const
⋮----
const BiomeManager::BiomeInfo* BiomeManager::getBiomeInfo(const std::string& name) const
⋮----
std::vector<int> BiomeManager::getBiomeIds() const
⋮----
std::vector<std::string> BiomeManager::getBiomeNames() const
⋮----
bool BiomeManager::setBiomeNoise(int biomeId, const std::string& noiseLayerId, float threshold)
⋮----
bool BiomeManager::setBiomeTemperatureRange(int biomeId, float minTemp, float maxTemp)
⋮----
bool BiomeManager::setBiomeHumidityRange(int biomeId, float minHumidity, float maxHumidity)
⋮----
bool BiomeManager::setBiomeElevationRange(int biomeId, float minElevation, float maxElevation)
⋮----
bool BiomeManager::setVoxelProbability(int biomeId, const std::string& voxelType, float probability)
⋮----
float BiomeManager::getVoxelProbability(int biomeId, const std::string& voxelType) const
⋮----
bool BiomeManager::setFeatureProbability(int biomeId, const std::string& featureType, float probability)
⋮----
float BiomeManager::getFeatureProbability(int biomeId, const std::string& featureType) const
⋮----
bool BiomeManager::setBiomeWeight(int biomeId, float weight)
⋮----
float BiomeManager::getBiomeWeight(int biomeId) const
⋮----
bool BiomeManager::setBiomeEnabled(int biomeId, bool enabled)
⋮----
bool BiomeManager::isBiomeEnabled(int biomeId) const
⋮----
int BiomeManager::getBiomeAt(const glm::vec3& position, const GenerationContext& context) const
⋮----
// Get biome influences at this point
⋮----
// Find the biome with the highest influence
⋮----
std::unordered_map<int, float> BiomeManager::getBiomeInfluence(const glm::vec3& position, const GenerationContext& context) const
⋮----
// If no biomes or no noise generator, return empty
⋮----
// Get temperature and humidity at this position
⋮----
// Use temperature and humidity noise if specified
⋮----
// Try to get the noise generator from the procedural generation system
// Since we don't have direct access, we'll just use the context's noise generator
⋮----
temperature = temperature * 0.5f + 0.5f; // Normalize to [0,1]
⋮----
humidity = humidity * 0.5f + 0.5f; // Normalize to [0,1]
⋮----
// Calculate elevation (normalized to [0,1])
⋮----
// Calculate influence for each enabled biome
⋮----
// Normalize influences
⋮----
void BiomeManager::setBlendDistance(float distance)
⋮----
float BiomeManager::getBlendDistance() const
⋮----
bool BiomeManager::generateBiomeData(const ChunkCoord& chunkCoord, const GenerationContext& context, Chunk& chunk)
⋮----
// Get chunk world position
⋮----
// For each voxel in the chunk
⋮----
// Sample at surface level (for efficiency, we don't need to process every voxel)
// Find the highest non-air voxel
⋮----
{ // Not air
⋮----
continue; // No surface found in this column
⋮----
// Calculate world position
⋮----
// Get biome influences at this position
⋮----
// Apply biome-specific modifications to the voxel column
⋮----
continue; // Skip air voxels
⋮----
// Create a world position for this voxel
⋮----
// Based on influences, determine voxel type
⋮----
// If it's the surface voxel, apply biome-specific surface block
⋮----
// Find the dominant biome
⋮----
// Apply biome-specific surface block
// Example: use data value to store biome ID
⋮----
// Apply based on voxel probabilities
// This is simplified and would be more complex in a real implementation
⋮----
// Convert voxel type name to ID (simplified)
⋮----
// Apply with probability
⋮----
// Apply the modified voxel
⋮----
void BiomeManager::setTemperatureNoiseLayer(const std::string& noiseLayerId)
⋮----
std::string BiomeManager::getTemperatureNoiseLayer() const
⋮----
void BiomeManager::setHumidityNoiseLayer(const std::string& noiseLayerId)
⋮----
std::string BiomeManager::getHumidityNoiseLayer() const
⋮----
bool BiomeManager::applyPreset(const std::string& presetName)
⋮----
// Default is already set up in constructor
⋮----
// Clear existing biomes
⋮----
// Create realistic biome distribution based on temperature and humidity
⋮----
setVoxelProbability(desertId, "4", 0.9f); // Sand
⋮----
setVoxelProbability(savannaId, "1", 0.8f); // Dirt/Grass
⋮----
setVoxelProbability(jungleId, "1", 0.9f); // Dirt/Grass
⋮----
setVoxelProbability(plainId, "1", 1.0f); // Dirt/Grass
⋮----
setVoxelProbability(forestId, "1", 1.0f); // Dirt/Grass
⋮----
setVoxelProbability(taigaId, "1", 0.9f); // Dirt/Grass
setVoxelProbability(taigaId, "6", 0.1f); // Snow
⋮----
setVoxelProbability(tundraId, "6", 0.9f); // Snow
⋮----
// Mountains can appear in any climate
⋮----
setVoxelProbability(mountainsId, "5", 1.0f); // Stone
⋮----
// Ocean biome
⋮----
setVoxelProbability(oceanId, "2", 1.0f); // Sand/Gravel
⋮----
// Create fantasy biomes
⋮----
setVoxelProbability(magicForestId, "8", 0.9f); // Custom block type
⋮----
setVoxelProbability(lavaLandsId, "9", 0.8f); // Custom block type
⋮----
setVoxelProbability(crystalForestsId, "10", 0.7f); // Custom block type
⋮----
setVoxelProbability(cloudRealmId, "11", 1.0f); // Custom block type
⋮----
setVoxelProbability(abyssId, "12", 0.95f); // Custom block type
⋮----
// Preset not found
⋮----
void BiomeManager::serialize(ECS::Serializer& serializer) const
⋮----
// Serialize basic properties
⋮----
// Serialize biomes
⋮----
// Serialize voxel probabilities
⋮----
// Serialize feature probabilities
⋮----
void BiomeManager::deserialize(ECS::Deserializer& deserializer)
⋮----
// Clear existing data
⋮----
// Deserialize basic properties
⋮----
// Register the biome
⋮----
// Private helper methods
⋮----
int BiomeManager::getNextBiomeId() const
⋮----
float BiomeManager::calculateBiomeInfluence(int biomeId, const glm::vec3& position,
⋮----
// Calculate weight from temperature, humidity, and elevation
⋮----
// Check temperature range
⋮----
// Outside range, calculate falloff
⋮----
// Apply falloff
⋮----
// Check humidity range
⋮----
// Check elevation range
⋮----
// Combine weights
⋮----
// Apply biome weight
⋮----
// Apply noise factor if specified
⋮----
// Normalize noise to [0,1]
⋮----
// Apply threshold
⋮----
// Below threshold, calculate falloff
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/Chunk.cpp">
// -------------------------------------------------------------------------
// Chunk.cpp
⋮----
// Default empty voxel (for out-of-bounds access)
const Voxel EMPTY_VOXEL = {0, 0}; // Assuming Voxel has type and data fields
⋮----
// Neighbor offsets for the 6 directions (-x, +x, -y, +y, -z, +z)
⋮----
{-1, 0, 0},  // -X
{1, 0, 0},   // +X
{0, -1, 0},  // -Y
{0, 1, 0},   // +Y
{0, 0, -1},  // -Z
{0, 0, 1}    // +Z
⋮----
// Convert a direction to the opposite direction
constexpr int oppositeDirection(int dir)
⋮----
return dir ^ 1; // Flips the lowest bit
⋮----
Chunk::Chunk()
⋮----
// Clear neighbor array
⋮----
Chunk::Chunk(const ChunkCoord& coord)
⋮----
// Cancel any ongoing mesh generation
⋮----
bool Chunk::initialize(int chunkSize)
⋮----
// Allocate voxel data
⋮----
// Initialize all voxels to empty
⋮----
// Update bounding box
⋮----
m_empty = true; // Initially empty
⋮----
m_meshDirty = true; // Need to generate mesh
⋮----
const Voxel& Chunk::getVoxel(int x, int y, int z) const
⋮----
bool Chunk::setVoxel(int x, int y, int z, const Voxel& voxel)
⋮----
// Check if the voxel is actually changing
⋮----
return false; // No change
⋮----
// Update the voxel
⋮----
// Mark chunk as modified
⋮----
// Update empty state if adding a non-empty voxel
⋮----
// If setting to empty, we need to check if the entire chunk is now empty
⋮----
// Notify neighbors if this voxel is on a chunk boundary
⋮----
const Voxel& Chunk::getVoxelSafe(int x, int y, int z, const Voxel& defaultVoxel) const
⋮----
bool Chunk::isValidPosition(int x, int y, int z) const
⋮----
void Chunk::fill(const Voxel& voxel)
⋮----
// Notify neighbors as all boundaries have changed
⋮----
bool Chunk::generateMesh(bool forceRegenerate)
⋮----
// If empty, clear existing mesh and return
⋮----
// Skip if mesh is up to date and not forced
⋮----
// Reset cancellation flag
⋮----
// Create mesh if it doesn't exist
⋮----
// Generate mesh
⋮----
// Check if we have all required neighbors for seamless meshing
⋮----
// Full quality meshing with all neighbors
⋮----
// Simple meshing without all neighbors
⋮----
// Check if canceled
⋮----
bool Chunk::serialize(ECS::Serializer& serializer) const
⋮----
// Begin chunk object
⋮----
// Write basic properties
⋮----
// Write voxel data (skip if empty)
⋮----
// Write all voxels
⋮----
// End chunk object
⋮----
bool Chunk::deserialize(ECS::Deserializer& deserializer)
⋮----
// Read basic properties
⋮----
// Read empty flag
⋮----
// Read voxel data
⋮----
// Ensure array size matches what we expect
⋮----
// Read all voxels
⋮----
// Fill with empty voxels
⋮----
// Update state
⋮----
// Update bounds
⋮----
size_t Chunk::getMemoryUsage() const
⋮----
// Voxel data
⋮----
// Mesh data
⋮----
// Other member variables
⋮----
void Chunk::setNeighbor(int direction, std::weak_ptr<Chunk> chunk)
⋮----
// If we have a new neighbor, out mesh may need updating at the boundary
⋮----
std::weak_ptr<Chunk> Chunk::getNeighbor(int direction) const
⋮----
void Chunk::notifyNeighbors()
⋮----
// Mark neighboring chunks' meshes as dirty if they exist
⋮----
void Chunk::cancelMeshGeneration()
⋮----
void Chunk::updateLighting()
⋮----
// This would be a more complex implementation in a real engine
// For now, just mark mesh as dirty to trigger regeneration with lighting
⋮----
void Chunk::updateEmptyState()
⋮----
void Chunk::updateBounds()
⋮----
// Calculate world-space bounds based on chunk coordinates and size
⋮----
bool Chunk::isVoxelExposed(int x, int y, int z) const
⋮----
// If the voxel is empty, it's not exposed
⋮----
// Check the six adjacent voxels
⋮----
// If out of bounds, check the neighboring chunk
⋮----
// Get the direction and neighboring chunk
⋮----
// If no neighbor, consider the voxel exposed from this side
⋮----
// Convert to neighboring chunk's coordinate space
⋮----
// Check the voxel in the neighboring chunk
⋮----
return true; // Exposed on the side
⋮----
// If the adjacent voxel is empty, this voxel is exposed
⋮----
// Not exposed on any side
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/ChunkManager.cpp">
// -------------------------------------------------------------------------
// ChunkManager.cpp
⋮----
constexpr int MAX_CHUNKS_PER_FRAME = 4; // Maximum number of chunks to process in a single frame
⋮----
ChunkManager::ChunkManager()
⋮----
bool ChunkManager::initialize()
⋮----
// Create chunk storage with default world path
⋮----
// Start save thread
⋮----
// Get reference to streaming manager if available
⋮----
void ChunkManager::update(float deltaTime)
⋮----
// Process a limited number of dirty chunks per frame to avoid hitches
⋮----
std::lock_guard<std::mutex> lock(m_dirtyChunksMutex);
⋮----
// Make a copy of a subset of dirty chunks to process
⋮----
// Remove processed chunks from the dirty set
⋮----
// Add dirty chunks to save queue
⋮----
void ChunkManager::render()
⋮----
// Debug visualization could be added here
⋮----
void ChunkManager::shutdown()
⋮----
// Save all dirty chunks
⋮----
// Stop save thread
⋮----
m_saveQueue.push(nullptr); // Push null to wake up thread
⋮----
// Clear all chunks
⋮----
std::lock_guard<std::mutex> lock(m_chunksMutex);
⋮----
std::vector<std::string> ChunkManager::getDependencies() const
⋮----
std::shared_ptr<Chunk> ChunkManager::loadChunk(const ChunkCoord& coord)
⋮----
// Check if chunk is already loaded
⋮----
return it->second; // Already loaded
⋮----
// Create a new chunk
⋮----
// Try to load from storage
⋮----
// If we couldn't load from storage, it's a new chunk (already initialized with defaults)
⋮----
chunk->markDirty(); // Mark as dirty to save later
⋮----
// Add to loaded chunks map
⋮----
// Update neighbors
⋮----
// If this is a new chunk, add to dirty set for later saving
⋮----
bool ChunkManager::unloadChunk(const ChunkCoord& coord)
⋮----
// Get and remove the chunk from the loaded map
⋮----
return false; // Not loaded
⋮----
// If chunk is dirty, save it before unloading
⋮----
// Remove from dirty chunks set
⋮----
// Update neighbors of adjacent chunks
⋮----
// Update the neighbor to remove reference to this chunk
⋮----
std::shared_ptr<Chunk>ChunkManager::createChunk(const ChunkCoord& coord)
⋮----
// Check if chunk already exists
⋮----
return it->second; // Already exists
⋮----
// Create and initialize the chunk
⋮----
// Mark as dirty for saving
⋮----
std::shared_ptr<Chunk> ChunkManager::getChunk(const ChunkCoord& coord)
⋮----
bool ChunkManager::isChunkLoaded(const ChunkCoord& coord) const
⋮----
bool ChunkManager::serializeChunk(const Chunk& chunk)
⋮----
// Clear dirty flag if save was successful
// Note: const_cast is safe here because we're only modifying the dirty flag
⋮----
// Remove from dirty set
⋮----
bool ChunkManager::deserializeChunk(Chunk& chunk)
⋮----
// Update neighbors after loading
⋮----
void ChunkManager::saveModifiedChunks()
⋮----
// Get all dirty chunks
⋮----
// Save each dirty chunk
⋮----
// Flush storage
⋮----
void ChunkManager::backgroundSaveThread()
⋮----
// Wait for a chunk to save
⋮----
// Check for shutdown signal (null chunk) or if thread should stop
⋮----
// Save the chunk if it's still dirty
⋮----
std::vector<std::shared_ptr<Chunk>> ChunkManager::getChunksAroundPoint(const glm::vec3& position, float radius)
⋮----
// Convert world position to chunk coordinates
⋮----
// Calculate chunk radius
⋮----
// Iterate through chunks in the radius
⋮----
ChunkCoord coord(x, y, z);
⋮----
// Calculate center of this chunk
⋮----
// Calculate distance to chunk center
⋮----
// If chunk is within radius, add it to result
⋮----
{ // 0.866 = sqrt(3)/2 for diagonal
⋮----
bool ChunkManager::setWorldPath(const std::string& path)
⋮----
// Save any modified chunks first
⋮----
// Clear all loaded chunks
⋮----
// Create new chunk storage
⋮----
// Replace the storage
⋮----
const std::string& ChunkManager::getWorldPath() const
⋮----
void ChunkManager::setChunkSize(int size)
⋮----
void ChunkManager::updateChunkNeighbors(std::shared_ptr<Chunk> chunk)
⋮----
// Define neighbor offsets and directions
⋮----
std::make_pair(ChunkCoord(coord.x - 1, coord.y, coord.z), 0), // -X
std::make_pair(ChunkCoord(coord.x + 1, coord.y, coord.z), 1), // +X
std::make_pair(ChunkCoord(coord.x, coord.y - 1, coord.z), 2), // -Y
std::make_pair(ChunkCoord(coord.x, coord.y + 1, coord.z), 3), // +Y
std::make_pair(ChunkCoord(coord.x, coord.y, coord.z - 1), 4), // -Z
std::make_pair(ChunkCoord(coord.x, coord.y, coord.z + 1), 5)  // +Z
⋮----
// Set neighbor reference in this chunk
⋮----
// Set reference to this chunk in neighbor
⋮----
neighborChunk->setNeighbor(direction ^ 1, chunk); // Opposite direction
⋮----
// If neighbors changed, mark chunk as needing remesh
⋮----
bool ChunkManager::generateChunkMesh(const ChunkCoord& coord, bool forceRegenerate)
⋮----
// Update neighbors to ensure proper meshing
⋮----
// Generate mesh
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/ChunkMesh.cpp">
// -------------------------------------------------------------------------
// ChunkMesh.cpp
⋮----
// Constants for mesh generation
⋮----
// Constants for ambient occlusion
constexpr int AO_RAY_SAMPLES = 16;    // Number of rays per vertex
constexpr float AO_RAY_LENGTH = 8.0f; // Maximum ray length
constexpr float AO_RAY_BIAS = 0.05f;  // Bias to avoid self-intersection
⋮----
// Face directions (right, left, top, bottom, front, back)
⋮----
glm::vec3(1.0f, 0.0f, 0.0f),  // +X
glm::vec3(-1.0f, 0.0f, 0.0f), // -X
glm::vec3(0.0f, 1.0f, 0.0f),  // +Y
glm::vec3(0.0f, -1.0f, 0.0f), // -Y
glm::vec3(0.0f, 0.0f, 1.0f),  // +Z
glm::vec3(0.0f, 0.0f, -1.0f)  // -Z
⋮----
// Vertex positions for a unit cube
⋮----
glm::vec3(0.0f, 0.0f, 0.0f), // 0: left-bottom-back
glm::vec3(1.0f, 0.0f, 0.0f), // 1: right-bottom-back
glm::vec3(0.0f, 1.0f, 0.0f), // 2: left-top-back
glm::vec3(1.0f, 1.0f, 0.0f), // 3: right-top-back
glm::vec3(0.0f, 0.0f, 1.0f), // 4: left-bottom-front
glm::vec3(1.0f, 0.0f, 1.0f), // 5: right-bottom-front
glm::vec3(0.0f, 1.0f, 1.0f), // 6: left-top-front
glm::vec3(1.0f, 1.0f, 1.0f)  // 7: right-top-front
⋮----
// Indices for the 6 faces of a cube (CW winding)
⋮----
std::array<int, 4>{1, 3, 7, 5}, // Right face (+X)
std::array<int, 4>{0, 4, 6, 2}, // Left face (-X)
std::array<int, 4>{2, 6, 7, 3}, // Top face (+Y)
std::array<int, 4>{0, 1, 5, 4}, // Bottom face (-Y)
std::array<int, 4>{4, 5, 7, 6}, // Front face (+Z)
std::array<int, 4>{0, 2, 3, 1}  // Back face (-Z)
⋮----
// Texture coordinates for each face
⋮----
// Colors for each face (for debugging or simple coloring
⋮----
0xFFE57373, // Right face: Red
0xFF81C784, // Left face: Green
0xFF4FC3F7, // Top face: Blue
0xFFFFF176, // Bottom face: Yellow
0xFFFFB74D, // Front face: Orange
0xFFBA68C8  // Back face: Purple
⋮----
// Helper for 3D array access
⋮----
class Array3D
⋮----
Array3D() : m_data()
⋮----
Array3D(int sizeX, int sizeY, int sizeZ)
⋮----
T& at(int x, int y, int z)
⋮----
const T& at(int x, int y, int z) const
⋮----
void fill(const T& value)
⋮----
size_t index(int x, int y, int z) const
⋮----
// Holds edge data for mesh simplification
struct Edge
⋮----
Edge(uint32_t _v1, uint32_t _v2, float _error)
⋮----
return error > other.error; // Use > for min-heap
⋮----
ChunkMesh::ChunkMesh(const ChunkCoord& coord)
⋮----
// Clear all data
⋮----
bool ChunkMesh::generate(const Chunk& chunk,
⋮----
// Clear existing mesh data
⋮----
// If the chunk is empty, nothing to do
⋮----
// Generate using greedy meshing algorithm for better performance
⋮----
// Check if generation was canceled
⋮----
// Calculate ambient occlusion if generation was successful
⋮----
// Update the GPU mesh
⋮----
bool ChunkMesh::generateSimple(const Chunk& chunk, std::function<bool()> cancelCheck)
⋮----
// Generate using simple cube method (less efficient but doesn't need neighbors)
⋮----
size_t ChunkMesh::getMemoryUsage() const
⋮----
// Vertex and index data
⋮----
// Render mesh
⋮----
// Approximate rendering mesh memory
⋮----
// LOD meshes
⋮----
// Approximate each LOD mesh
⋮----
// Other member variables
⋮----
size_t ChunkMesh::getVertexCount() const
⋮----
size_t ChunkMesh::getIndexCount() const
⋮----
bool ChunkMesh::updateLOD(float distance)
⋮----
// Determine appropriate LOD level based on distance thresholds
⋮----
// If LOD hasn't changed, nothing to do
⋮----
// Update LOD level
⋮----
// Ensure we have LODs created
⋮----
// Use the appropriate LOD mesh
⋮----
m_renderMesh = m_lodMeshes[0]; // Fallback to base LOD
⋮----
bool ChunkMesh::createLODs()
⋮----
// Ensure we have the base mesh
⋮----
// Resize to hold LODs
⋮----
// LOD0 is the original mesh
⋮----
// Define progressively stronger simplification ratios
⋮----
// Create progressively simplified LODs
⋮----
// Perform mesh simplification using quadric error metrics
⋮----
// Skip if no vertices generated
⋮----
// Create mesh for this LOD level
⋮----
// Set up vertex attributes (same as in updateRenderMesh)
⋮----
// Set up attributes
⋮----
posAttr.type = 0x1406; // GL_FLOAT
⋮----
normAttr.type = 0x1406; // GL_FLOAT
⋮----
texCoordAttr.type = 0x1406; // GL_FLOAT
⋮----
colorAttr.type = 0x1401; // GL_UNSIGNED_BYTE
⋮----
materialAttr.type = 0x1403; // GL_UNSIGNED_SHORT
⋮----
occlusionAttr.type = 0x1403; // GL_UNSIGNED_SHORT
⋮----
// Create the LOD mesh
⋮----
void ChunkMesh::clear()
⋮----
bool ChunkMesh::raycastVoxel(const Chunk& chunk,
⋮----
// Initialize ray parameters
Utility::Ray ray(origin, direction);
⋮----
// Convert origin to voxel space
⋮----
// Calculate chunk bounds
⋮----
// Setup DDA ray casting
glm::vec3 deltaDist = glm::abs(glm::vec3(1.0f) / (voxelDir + glm::vec3(0.0001f))); // Avoid div by zero
⋮----
// Calculate step direction
⋮----
// Current voxel coordinates
⋮----
// Distance to next voxel boundary
⋮----
// Current distance traveled
⋮----
// DDA algorithm
⋮----
// Check current voxel
⋮----
// Inside the chunk
⋮----
// In a neighbor chunk
⋮----
neighborIdx = 1; // -X neighbor
⋮----
neighborIdx = 0; // +X neighbor
⋮----
neighborIdx = 3; // -Y neighbor
⋮----
neighborIdx = 2; // +Y neighbor
⋮----
neighborIdx = 5; // -Z neighbor
⋮----
neighborIdx = 4; // +Z neighbor
⋮----
// Get voxel from neighboring chunk
⋮----
// Step to next voxel
⋮----
// No hit within max distance
⋮----
// Create a rotation that aligns +Y to the normal
⋮----
// Normal already points up, no rotation needed
⋮----
// Normal points down, rotate 180 degrees around X
⋮----
// Create rotation from cross product
⋮----
// Generate rays using stratified sampling
⋮----
// Stratified position in grid
⋮----
// Convert to spherical coordinates - use cosine-weighted distribution
⋮----
float cosTheta = std::sqrt(v); // Cosine-weighted
⋮----
// Convert to cartesian coordinates in local space
⋮----
cosTheta,                  // Points up in local space
⋮----
// Rotate into world space
⋮----
bool ChunkMesh::updateRenderMesh()
⋮----
// Create render mesh
⋮----
// Set up vertex attributes
⋮----
// Add position attribute
⋮----
posAttr.size = 3;  // 3 components (x, y, z)
⋮----
// Add normal attribute
⋮----
normAttr.size = 3;  // 3 components (x, y, z)
⋮----
// Add texcoord attribute
⋮----
texCoordAttr.size = 2;  // 2 components (u, v)
⋮----
// Add color attribute
⋮----
colorAttr.size = 4;  // 4 components (r, g, b, a) packed in uint32
⋮----
// Add material attribute (custom)
⋮----
materialAttr.size = 1;  // 1 component
⋮----
// Add occlusion attribute (custom)
⋮----
occlusionAttr.size = 1;  // 1 component
⋮----
// Set mesh data
⋮----
// Store this as the full detail LOD
⋮----
bool ChunkMesh::generateGreedyMesh(const Chunk& chunk,
⋮----
// Prepare merged face tracking
// For each face direction, we need a 2D mask to track which faces have been merged
⋮----
// World offset for this chunk
⋮----
// Process each direction separately
⋮----
// Check for cancellation periodically
⋮----
// Get neighbor in this direction if available
⋮----
// Get normal for this face direction
⋮----
// Determine the primary and secondary axes for this face
⋮----
// Iterate through each slice along the primary axis
⋮----
// For each voxel in the slice
⋮----
// Convert to x,y,z
⋮----
// Skip if already processed
⋮----
// Get the current voxel
⋮----
// Skip empty voxels
⋮----
// Check if the face is visible (adjacent voxel is empty or different material)
⋮----
// Calculate adjacent position
⋮----
// Check if adjacent position is out of bounds
⋮----
// Check neighbor chunk if available
⋮----
// Convert to neighbor local coordinates
⋮----
// Get voxel from neighbor
⋮----
// No neighbor, face is visible
⋮----
// Check adjacent voxel in this chunk
⋮----
// Skip non-visible faces
⋮----
// Greedy meshing: Try to expand this face in both secondary and tertiary axes
⋮----
// Expand along tertiary axis first
⋮----
// Check if this voxel matches and has a visible face
⋮----
// If already processed, different type, or not visible, stop expansion
⋮----
// Check visiblity of the face
⋮----
// Expand
⋮----
// Now try to expand along secondary axis
⋮----
// For each position in the expanded tertiary axis, check if it can be included
⋮----
// Combined position
⋮----
// Check visibility of the face
⋮----
// If expansion is valid, update the end position
⋮----
// Mark all included faces as processed
⋮----
// Create vertices for the merged face
⋮----
// Calculate merged face dimensions
⋮----
// Create quad vertices
⋮----
// Set positions based on face direction
glm::vec3 basePos(x * VOXEL_SIZE, y * VOXEL_SIZE, z * VOXEL_SIZE);
⋮----
{ // +X
⋮----
{ // -X
⋮----
{ // +Y
⋮----
{ // -Y
⋮----
{ // +Z
⋮----
{ // -Z
⋮----
// Set shared attributes for all vertices
⋮----
quadVertices[i].occlusion = 0; // Will be calculated later
⋮----
// Add indices for the quad (two triangles)
⋮----
// Add vertices
⋮----
bool ChunkMesh::generateCubeMesh(const Chunk& chunk, std::function<bool()> cancelCheck)
⋮----
// Process each voxel
⋮----
// Check for cancellation every 1000 voxels
⋮----
// Get the voxel
⋮----
// Create voxel cube
glm::vec3 pos(x * VOXEL_SIZE, y * VOXEL_SIZE, z * VOXEL_SIZE);
⋮----
// Check each face
⋮----
// Check if face is visible
⋮----
// If adjacent voxel is outside chunk, face is visible
⋮----
// If adjacent voxel is inside chunk, check if it's empty
⋮----
// If face is not visible, skip
⋮----
// Create face vertices
⋮----
// Add vertices for the face
⋮----
// Set positions based on cube vertices for this face
⋮----
faceVertices[i].occlusion = 0; // Will be calculated later
⋮----
// Add indices for the face (two triangles)
⋮----
void ChunkMesh::simplifyMesh(const std::vector<Vertex>& vertices,
⋮----
// Early exit if mesh is too small
⋮----
// Create output vertices (start with a copy)
⋮----
// Build adjacency information
⋮----
// Calculate face normal
⋮----
// Calculates how many vertices to remove
⋮----
// Build edge collapse priority queue
⋮----
// Process each triangle
⋮----
// Ensure consistent ordering
⋮----
// Calculate edge collapse error
⋮----
// Sum squared distances to face planes
⋮----
// Skip faces already counted
⋮----
// Also consider texture coordinates and other attributes
⋮----
// Add to queue
⋮----
// Track vertices that have been collapsed
⋮----
// Process edges in order of increasing order
⋮----
// Skip if either vertex has been removed
⋮----
// Collapse v2 into v1
⋮----
// Merge vertex attributes
⋮----
// For simplicity, keep other attributes from v1
⋮----
// Build new index buffer
⋮----
// Remap vertices
⋮----
// Skip degenerate triangles
⋮----
// Compact vertex buffer (optional)
⋮----
void ChunkMesh::calculateAmbientOcclusion(const Chunk& chunk,
⋮----
// Skip if empty
⋮----
// Get world position of chunk
⋮----
// Get light direction (assuming light comes from above and slightly to the side)
⋮----
// Process each vertex
⋮----
// Get vertex in local space
⋮----
// Add small bias to prevent self-intersection
⋮----
// Generate cosine-weighted ray directions in hemisphere
⋮----
// Calculate occlusion value by ray casting
⋮----
// Add bias toward primary light direction
⋮----
primaryLightDir + vertex.normal * 0.5f); // Blend with normal
rayDirs[0] = biasedLightDir; // Replace first ray
⋮----
// Cast rays and count hits
⋮----
// Weight by distance - closer hits contribute more to occlusion
⋮----
occlusion += weight * weight; // Square for more dramatic fallof
⋮----
// Normalize occlusion
⋮----
// Add directional component - add more occlusion if normal faces away from light
⋮----
float directionalFactor = 1.0f - nDotL * 0.5f; // Scale to [0.5, 1.0]
⋮----
// Combine ambient occlusion with directional occlusion
⋮----
// Scale and convert to uint16
⋮----
// Invert for lighting (higher = brighter)
⋮----
// No hits - fully lit
⋮----
void ChunkMesh::updateBounds()
⋮----
int chunkSize = 16; // Default size
⋮----
// Calculate bounds based on chunk coordinates
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/ChunkStorage.cpp">
// -------------------------------------------------------------------------
// ChunkStorage.cpp
⋮----
constexpr char FILE_MAGIC[] = "PCVX"; // PixelCraft Voxel
⋮----
constexpr int REGION_SIZE = 32; // 32x32 chunks per region
⋮----
// Utility function to compute region indices
std::pair<int, int> getRegionIndices(const ChunkCoord& coord)
⋮----
ChunkStorage::ChunkStorage(const std::string& worldPath, Format format)
⋮----
bool ChunkStorage::initialize()
⋮----
// Ensure directories exist
⋮----
bool ChunkStorage::saveChunk(const Chunk& chunk)
⋮----
fs::path path(filepath);
⋮----
// Open file for writing
⋮----
// Write file header
⋮----
// Write chunk coordinates
⋮----
// Write timestamp
⋮----
// Get chunk data
⋮----
// Depending on format, write data directly or compress it
⋮----
// Allocate buffer for compressed data
⋮----
std::vector<uint8_t> compressedData(compressedSize);
⋮----
// Compress the data
⋮----
// Resize to actual compressed size
⋮----
// Write data size and compressed data
⋮----
// Write data size and raw data
⋮----
// Update metadata cache
⋮----
// Mark as no longer pending
⋮----
std::lock_guard<std::mutex> lock(m_pendingWritesMutex);
⋮----
bool ChunkStorage::loadChunk(const ChunkCoord& coord, Chunk& chunk)
⋮----
// Open file for reading
std::ifstream file(filepath, std::ios::binary);
⋮----
// Read and verify file header
⋮----
// Read version
⋮----
// Read coordinates
⋮----
// Verify coordinates match
⋮----
// Skip timestamp
⋮----
// Read data sizes
⋮----
// Read compressed data
⋮----
// Allocate buffer for decompressed data
std::vector<uint8_t> chunkData(originalSize);
⋮----
// Decompress the data
⋮----
// Deserialize chunk data
⋮----
// Read data size
⋮----
// Read raw data
std::vector<uint8_t> chunkData(dataSize);
⋮----
// Ensure the chunk has the correct coordinate
⋮----
bool ChunkStorage::chunkExists(const ChunkCoord& coord) const
⋮----
bool ChunkStorage::deleteChunk(const ChunkCoord& coord)
⋮----
return true; // Already doesn't exist
⋮----
// Remove from caches
⋮----
std::lock_guard<std::mutex> lock(m_metadataCacheMutex);
⋮----
void ChunkStorage::setMetadataCacheSize(size_t size)
⋮----
// If the new size is smaller than current cache size, trim the cache
⋮----
// This is a simple approach - in a real implementation,
// you might want to remove least recently used entries first
⋮----
void ChunkStorage::flush()
⋮----
// Currently no buffered writes to flush
// This method would be ued if we implemented a write buffer
⋮----
std::vector<ChunkCoord> ChunkStorage::getAllChunkCoords() const
⋮----
// Recursively iterate through all files in the chunks directory
⋮----
// Parse filename to extract coordinates
⋮----
// Format is expected to be "c.x.y.z.chunk"
⋮----
bool ChunkStorage::getChunkMetadata(const ChunkCoord& coord, int64_t& lastModified, size_t& size) const
⋮----
// Check cache first
⋮----
// Cache miss, get from filesystem
⋮----
// Cache the result
⋮----
void ChunkStorage::setCompressionLevel(int level)
⋮----
// Ensure level is in valid range
⋮----
size_t ChunkStorage::getTotalStorageSize() const
⋮----
bool ChunkStorage::repairChunk(const ChunkCoord& coord)
⋮----
// Basic repair functionality - check if file is valid
⋮----
return false; // File doesn't exist, can't repair
⋮----
// Try to validate the file
⋮----
return true; // File is already valid
⋮----
// If we have a backup, try to restore from it
⋮----
// If repair failed, delete the corrupted file
⋮----
void ChunkStorage::forEachChunkInRegion(const ChunkCoord& minCoord, const ChunkCoord& maxCoord,
⋮----
// Iterate through all potential chunk coordinates in the region
⋮----
ChunkCoord coord(x, y, z);
⋮----
// Check if chunk exists before calling the callback
⋮----
std::string ChunkStorage::getChunkFilePath(const ChunkCoord& coord) const
⋮----
// Create a directory structure based on chunk coordinates
// to avoid having too many files in a single directory
⋮----
// Create filename from coordinates
⋮----
std::string ChunkStorage::getRegionFilePath(const ChunkCoord& coord) const
⋮----
bool ChunkStorage::ensureDirectoriesExist() const
⋮----
// Create world directory if it doesn't exist
⋮----
// Create chunks directory
⋮----
// Create regions directory (for future region-based storage)
⋮----
bool ChunkStorage::isValidChunkFile(const std::string& filepath) const
⋮----
// Check file size
⋮----
{ // Minimum size for a valid header
⋮----
// If we get here, the file seems valid
⋮----
void ChunkStorage::cacheMetadata(const ChunkCoord& coord, int64_t lastModified, size_t size) const
⋮----
// If cache is full, remove oldest entry
⋮----
// Add to cache
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/DistributionControl.cpp">
// -------------------------------------------------------------------------
// DistributionControl.cpp
⋮----
DistributionControl::DistributionControl()
⋮----
// Nothing specific to initialize
⋮----
// Clean up any resources
⋮----
void DistributionControl::setPattern(PatternType pattern)
⋮----
DistributionControl::PatternType DistributionControl::getPattern() const
⋮----
void DistributionControl::setGlobalDensity(float density)
⋮----
float DistributionControl::getGlobalDensity() const
⋮----
void DistributionControl::setFeatureDensity(const std::string& featureType, float density)
⋮----
float DistributionControl::getFeatureDensity(const std::string& featureType) const
⋮----
void DistributionControl::setInfluenceRadius(float radius)
⋮----
float DistributionControl::getInfluenceRadius() const
⋮----
void DistributionControl::setClusterSize(float size)
⋮----
float DistributionControl::getClusterSize() const
⋮----
void DistributionControl::setClusterSpacing(float spacing)
⋮----
float DistributionControl::getClusterSpacing() const
⋮----
void DistributionControl::setClusterFalloff(float falloff)
⋮----
float DistributionControl::getClusterFalloff() const
⋮----
void DistributionControl::setSeed(uint32_t seed)
⋮----
uint32_t DistributionControl::getSeed() const
⋮----
float DistributionControl::getDensityAt(const glm::vec3& position, const std::string& featureType) const
⋮----
// Calculate base density
⋮----
// Apply region modifiers
⋮----
// Apply cluster effects
⋮----
// Apply gradient effects
⋮----
// Apply custom distribution function if set
⋮----
// Ensure result is in valid range
⋮----
int DistributionControl::addDensityRegion(const glm::vec3& centerPosition, float radius, float multiplier,
⋮----
bool DistributionControl::removeDensityRegion(int regionId)
⋮----
int DistributionControl::addCluster(const glm::vec3& position, float strength, const std::string& featureType)
⋮----
bool DistributionControl::removeCluster(int clusterId)
⋮----
void DistributionControl::clearClusters()
⋮----
void DistributionControl::setDensityThreshold(float threshold, const std::string& featureType)
⋮----
float DistributionControl::getDensityThreshold(const std::string& featureType) const
⋮----
std::vector<glm::vec3> DistributionControl::generateDistributionPoints(const ChunkCoord& chunkCoord,
⋮----
// Generate points based on the selected pattern
⋮----
// Filter points based on density threshold
⋮----
// Get density threshold for this feature type
⋮----
void DistributionControl::setNoiseDistribution(const std::string& noiseLayerId, float threshold,
⋮----
std::string DistributionControl::getNoiseDistribution(const std::string& featureType) const
⋮----
float DistributionControl::getNoiseThreshold(const std::string& featureType) const
⋮----
int DistributionControl::setGradient(const glm::vec3& startPosition, const glm::vec3& endPosition,
⋮----
bool DistributionControl::removeGradient(int gradientId)
⋮----
bool DistributionControl::registerCustomDistribution(const std::string& name,
⋮----
// Check if already registered
⋮----
bool DistributionControl::setActiveCustomDistribution(const std::string& name)
⋮----
std::string DistributionControl::getActiveCustomDistribution() const
⋮----
void DistributionControl::serialize(ECS::Serializer& serializer) const
⋮----
// Serialize basic properties
⋮----
// Serialize feature densities
⋮----
// Serialize density regions
⋮----
// Serialize clusters
⋮----
// Serialize gradients
⋮----
// Serialize noise distributions
⋮----
// Serialize density thresholds
⋮----
// Custom distribution functions cannot be serialized
// Just serialize the names for reference
⋮----
void DistributionControl::deserialize(ECS::Deserializer& deserializer)
⋮----
// Clear existing data
⋮----
// Deserialize basic properties
⋮----
// Deserialize feature densities
⋮----
// Deserialize density regions
⋮----
// Deserialize clusters
⋮----
// Deserialize gradients
⋮----
// Deserialize noise distributions
⋮----
// Deserialize density thresholds
⋮----
// Custom distribution functions need to be registered at runtime
// because they cannot be serialized
⋮----
// Private helper methods
⋮----
float DistributionControl::calculateBaseDensity(const glm::vec3& position, const std::string& featureType) const
⋮----
// Apply feature-specific density if available
⋮----
float DistributionControl::applyRegionModifiers(const glm::vec3& position, float baseDensity, const std::string& featureType) const
⋮----
// Apply density region modifiers
⋮----
// Skip if not applicable to this feature type
⋮----
// Linear falloff from center to edge
⋮----
// Apply region multiplier
⋮----
float DistributionControl::applyClusterEffect(const glm::vec3& position, float density, const std::string& featureType) const
⋮----
// Calculate falloff
⋮----
// Increase density based on cluster strength
⋮----
float DistributionControl::applyGradientEffect(const glm::vec3& position, float density, const std::string& featureType) const
⋮----
// Calculate distance along gradient line
⋮----
continue; // Skip zero-length gradients
⋮----
// Project position onto gradient line
⋮----
// Calculate how far along the gradient we are [0-1]
⋮----
// Interpolate between start and end densisies
⋮----
// Blend with current density (stronger wins)
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsUniform(const ChunkCoord& chunkCoord, int count) const
⋮----
// Set up RNG with seed derived from chunk coords and global seed
⋮----
std::mt19937 rng(chunkSeed);
std::uniform_real_distribution<float> distChunk(0.0f, 16.0f); // Assuming 16x16x16 chunks
⋮----
// Calculate chunk world position
glm::vec3 chunkWorldPos = chunkCoord.toWorldPosition(16); // Assuming 16x16x16 chunks
⋮----
// Generate random position within the chunk
⋮----
// Convert to world space
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsClustered(const ChunkCoord& chunkCoord, int count) const
⋮----
// Generate cluster centers
⋮----
// Generate points around cluster centers
⋮----
// Generate point with radial distribution around cluster center
⋮----
float dy = distCluster(rng) - distCluster(rng); // More vertical spread in the middle
⋮----
glm::vec3 offset(dx, dy, dz);
⋮----
// Add remaining points
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsStratified(const ChunkCoord& chunkCoord, int count) const
⋮----
// Determine grid size
⋮----
// Generate one point per grid cell with jitter
⋮----
// Skip if we already have enough points
⋮----
// Calculate base position
⋮----
// Add jitter
⋮----
// Final position
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsVoronoi(const ChunkCoord& chunkCoord, int count) const
⋮----
// For this simplified implementation, generate random points
// that will be used as Voronoi cell centers
⋮----
// In a full implementation, we'd generate more points and select
// those that are closest to Voronoi cell centers
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsBlueNoise(const ChunkCoord& chunkCoord, int count) const
⋮----
// Blue noise generation is complex, so this is a simplified version
// that uses rejection sampling based on minimum distance
⋮----
// Minimum distance between points (based on count)
⋮----
// Maximum attempts before giving up on a point
⋮----
// Generate points
⋮----
// Generate candidate point
⋮----
// Check if it's far enough from existing points
⋮----
// If we don't have enough points, just generate random ones
⋮----
std::vector<glm::vec3> DistributionControl::generatePointsFibonacci(const ChunkCoord& chunkCoord, int count) const
⋮----
// Fibonacci spherical distribution constants
const float phi = (1.0f + std::sqrt(5.0f)) / 2.0f; // Golden ratio
⋮----
std::uniform_real_distribution<float> distRadius(0.0f, 8.0f); // Radius within chunk
std::uniform_real_distribution<float> distOffset(0.0f, 16.0f); // Center position within chunk
⋮----
// Generate random center within chunk
⋮----
// Generate point using Fibonacci spherical distribution
⋮----
// Scale by radius and add center
⋮----
// Ensure point is within chunk bounds
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/FeaturePlacement.cpp">
// -------------------------------------------------------------------------
// FeaturePlacement.cpp
⋮----
FeaturePlacement::FeaturePlacement()
⋮----
// Nothing specific to initialize
⋮----
// Clean up any resources
⋮----
bool FeaturePlacement::canPlaceFeature(const glm::vec3& position, const std::string& featureType,
⋮----
// Check if feature type is registered
⋮----
// Check spacing from existing features
⋮----
// Check standard constraints
⋮----
// Check custom constraints
⋮----
bool FeaturePlacement::placeFeature(const glm::vec3& position, const std::string& featureType,
⋮----
// Get the feature generator function
⋮----
// Call the generator function
⋮----
// If successful, record the placement
⋮----
std::vector<glm::vec3> FeaturePlacement::findPlacementsInChunk(const ChunkCoord& chunkCoord,
⋮----
// Generate potential positions
⋮----
// Check each position against constraints
⋮----
bool FeaturePlacement::registerFeatureType(const std::string& featureType,
⋮----
// Check if already registered
⋮----
// Create new feature type info
⋮----
bool FeaturePlacement::hasFeatureType(const std::string& featureType) const
⋮----
std::vector<std::string> FeaturePlacement::getFeatureTypes() const
⋮----
bool FeaturePlacement::addConstraint(const std::string& featureType, ConstraintType constraint, const std::vector<float>& params)
⋮----
// Create constraint
⋮----
// Add to feature type
⋮----
bool FeaturePlacement::removeConstraint(const std::string& featureType, ConstraintType constraint)
⋮----
bool FeaturePlacement::clearConstraints(const std::string& featureType)
⋮----
std::vector<FeaturePlacement::ConstraintType> FeaturePlacement::getConstraints(const std::string& featureType) const
⋮----
std::vector<float> FeaturePlacement::getConstraintParams(const std::string& featureType, ConstraintType constraint) const
⋮----
bool FeaturePlacement::addCustomConstraint(const std::string& featureType, const std::string& name,
⋮----
// Check if constraint already exists
⋮----
// Add new constraint
⋮----
bool FeaturePlacement::removeCustomConstraint(const std::string& featureType, const std::string& name)
⋮----
bool FeaturePlacement::registerPointOfInterest(const glm::vec3& position, const std::string& type, float radius)
⋮----
bool FeaturePlacement::removePointOfInterest(const glm::vec3& position, const std::string& type)
⋮----
std::vector<glm::vec3> FeaturePlacement::findNearbyPointsOfInterest(const glm::vec3& position,
⋮----
void FeaturePlacement::clearPointsOfInterest()
⋮----
void FeaturePlacement::setFeatureSpacing(const std::string& featureType, float spacing)
⋮----
float FeaturePlacement::getFeatureSpacing(const std::string& featureType) const
⋮----
void FeaturePlacement::setSeed(uint32_t seed)
⋮----
uint32_t FeaturePlacement::getSeed() const
⋮----
void FeaturePlacement::serialize(ECS::Serializer& serializer) const
⋮----
// Serialize basic properties
⋮----
// Serialize feature types
⋮----
// Feature spacing
⋮----
// Serialize params
⋮----
// Custom contraints cannot be serialized (functions)
// Just serialize their names for reference
⋮----
// Serialize points of interest
⋮----
// Placed features are not serialized (runtime state)
⋮----
void FeaturePlacement::deserialize(ECS::Deserializer& deserializer)
⋮----
// Clear existing data
⋮----
// Deserialize basic properties
⋮----
//// Serialize feature types
//size_t featureArraySize;
//deserializer.beginArray("featureTypes", featureArraySize);
//for (const auto& [typeName, typeInfo] : m_featureTypes)
//{
//    deserializer.beginObject("Feature");
⋮----
//    // Feature spacing
//    deserializer.read(typeInfo.spacing);
⋮----
//    size_t constraintsArraySize;
//    deserializer.beginArray("constraints", constraintsArraySize);
//    for (size_t i = 0; i < typeInfo.constraints.size(); i++)
//    {
//        const FeatureConstraint& constraint;
//        deserializer.beginObject("Constraint");
⋮----
//        int type;
//        deserializer.read(type);
//        constraint.type = static_cast<ConstraintType>(type);
⋮----
//        // Serialize params
//        size_t paramsArraySize;
//        deserializer.beginArray("params", paramsArraySize);
//        for (size_t j = 0; j < constraint.params.size(); j++)
//        {
//            deserializer.read(constraint.params[j]);
//        }
//        deserializer.endArray();
//        deserializer.endObject();
//    }
//    deserializer.endArray();
⋮----
//    // Custom contraints cannot be serialized (functions)
//    // Just serialize their names for reference
//    size_t customArraySize;
//    deserializer.beginArray("customConstraints", customArraySize);
//    for (size_t i = 0; i < typeInfo.customConstraints.size(); i++)
⋮----
//        deserializer.readString(typeInfo.customConstraints[i].name);
⋮----
//    deserializer.endObject();
//}
//deserializer.endArray();
⋮----
// Feature types and constraints need to be registered at runtime
// because generator and constraint functions cannot be serialized
⋮----
// Private helper methods
⋮----
bool FeaturePlacement::checkConstraint(const FeatureConstraint& constraint, const glm::vec3& position,
⋮----
// Requires params: [minHeight, maxHeight]
⋮----
return true; // Invalid constraint params, allow placement
⋮----
// Requires params: [refX, refY, refZ, minDist, maxDist]
⋮----
// Biome constraint, requires a biome manager
⋮----
return true; // No biome manager, allow placement
⋮----
// Requires params: [biomeId1, biomeId2, ...]
⋮----
return true; // No biome IDs specified, allow placement
⋮----
return false; // No biome at this position
⋮----
// Check if biome ID is in the allowed list
⋮----
// Requires params: [maxSlopeAngleDegrees]
⋮----
// Calculate terrain normal at this point
// Approximate by sampling nearby points
⋮----
// Calculate height differences
⋮----
// Calculate normal
⋮----
// Calculate angle between normal and up vector
⋮----
// Requires params: [maxDistance]
⋮----
// Check surrounding points for water
⋮----
// Water type is 3
⋮----
// Requires params: [minDistance]
⋮----
// Water is type 3
⋮----
// Requires params: [maxDistance, featureTypeIndex1, featureTypeIndex2, ...]
⋮----
// Check all points of interest for matching feature types
⋮----
// Check if the POI type matches any of the specified feature types
⋮----
// Convert type index to name (simplified)
⋮----
// Requires params: [minDistance, featureTypeIndex1, featureTypeIndex2, ...]
⋮----
// Requires params: [theshold, cutoff]
⋮----
return true; // No noise generator, allow placement
⋮----
// Requires params: [radius, maxCount]
⋮----
// Convert world position to chunk space
⋮----
// Check already placed features in this and neighboring chunks
⋮----
// Get chunks that could contain features within radius
⋮----
// Count all features within radius
⋮----
// Custom constraints are handled separately
⋮----
std::vector<glm::vec3> FeaturePlacement::generatePotentialPositions(const ChunkCoord& chunkCoord,
⋮----
// Set up RNG with seed derived from chunk coords and global seed
⋮----
std::mt19937 rng(chunkSeed);
⋮----
// Calculate chunk world position
⋮----
// Generate random position within the chunk
⋮----
// Convert to world space
⋮----
bool FeaturePlacement::isNearExistingFeature(const glm::vec3& position, const std::string& featureType, float spacing) const
⋮----
ChunkCoord chunkCoord = ChunkCoord::fromWorldPosition(position, 16); // Default chunk size
⋮----
// Check if the same feature type is placed nearby
⋮----
// Check distance to each placed feature
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/FileChunkStorage.cpp">
// -------------------------------------------------------------------------
// FileChunkStorage.cpp
⋮----
FileChunkStorage::FileChunkStorage(const std::string& basePath)
⋮----
// Ensure the base directory exists
⋮----
// Nothing to clean up
⋮----
bool FileChunkStorage::saveChunk(const Chunk& chunk)
⋮----
// Get the file path for this chunk
⋮----
// Ensure the directory exists
⋮----
// Open the file for writing
std::ofstream file(path, std::ios::binary);
⋮----
// Create a serializer for the file
Serializer serializer(file);
⋮----
// Serialize the chunk data
⋮----
bool FileChunkStorage::loadChunk(Chunk& chunk)
⋮----
// Check if the file exists
⋮----
// Open the file for reading
std::ifstream file(path, std::ios::binary);
⋮----
// Create a deserializer for the file
Deserializer deserializer(file);
⋮----
// Deserialize the chunk data
⋮----
bool FileChunkStorage::chunkExists(const ChunkCoord& coord)
⋮----
bool FileChunkStorage::deleteChunk(const ChunkCoord& coord)
⋮----
// File doesn't exist, consider it "deleted"
⋮----
std::string FileChunkStorage::getChunkPath(const ChunkCoord& coord) const
⋮----
// Create a region-based file structure for better file system performance
// A region contains 32x32 chunks
⋮----
// Create a path in the format: basePath/regionX.regionZ/x.y.z.chunk
⋮----
bool FileChunkStorage::ensureDirectoryExists(const std::string& path) const
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/GenerationParameters.cpp">
// -------------------------------------------------------------------------
// GenerationParameters.cpp
⋮----
GenerationParameters::GenerationParameters()
⋮----
// Nothing specific to clean up
⋮----
void GenerationParameters::setTerrainMode(TerrainMode mode)
⋮----
GenerationParameters::TerrainMode GenerationParameters::getTerrainMode() const
⋮----
void GenerationParameters::setHeightRange(float min, float max)
⋮----
float GenerationParameters::getMinHeight() const
⋮----
float GenerationParameters::getMaxHeight() const
⋮----
void GenerationParameters::setWaterLevel(float level)
⋮----
float GenerationParameters::getWaterLevel() const
⋮----
void GenerationParameters::enableWater(bool enable)
⋮----
bool GenerationParameters::isWaterEnabled() const
⋮----
void GenerationParameters::enableCaves(bool enable)
⋮----
bool GenerationParameters::areCavesEnabled() const
⋮----
void GenerationParameters::setCaveDensity(float density)
⋮----
float GenerationParameters::getCaveDensity() const
⋮----
void GenerationParameters::setCaveSize(float size)
⋮----
float GenerationParameters::getCaveSize() const
⋮----
void GenerationParameters::setTerrainNoiseLayer(const std::string& layerId)
⋮----
std::string GenerationParameters::getTerrainNoiseLayer() const
⋮----
void GenerationParameters::setCaveNoiseLayer(const std::string& layerId)
⋮----
std::string GenerationParameters::getCaveNoiseLayer() const
⋮----
void GenerationParameters::setFeatureNoiseLayer(const std::string& layerId)
⋮----
std::string GenerationParameters::getFeatureNoiseLayer() const
⋮----
void GenerationParameters::setBiomeNoiseLayer(const std::string& layerId)
⋮----
std::string GenerationParameters::getBiomeNoiseLayer() const
⋮----
void GenerationParameters::setTerrainRoughness(float roughness)
⋮----
float GenerationParameters::getTerrainRoughness() const
⋮----
void GenerationParameters::setTerrainErosion(float erosion)
⋮----
float GenerationParameters::getTerrainErosion() const
⋮----
void GenerationParameters::setFeaturePlacementPattern(PlacementPattern pattern)
⋮----
GenerationParameters::PlacementPattern GenerationParameters::getFeaturePlacementPattern() const
⋮----
void GenerationParameters::setFeatureDensity(float density)
⋮----
float GenerationParameters::getFeatureDensity() const
⋮----
void GenerationParameters::setBiomeBlendDistance(float distance)
⋮----
float GenerationParameters::getBiomeBlendDistance() const
⋮----
void GenerationParameters::setFeaturePlacementControl(const std::string& controlId)
⋮----
std::string GenerationParameters::getFeaturePlacementControl() const
⋮----
void GenerationParameters::setDistributionControl(const std::string& controlId)
⋮----
std::string GenerationParameters::getDistributionControl() const
⋮----
void GenerationParameters::enableFeatureType(const std::string& featureType, bool enable)
⋮----
bool GenerationParameters::isFeatureTypeEnabled(const std::string& featureType) const
⋮----
// Default to enabled if not specifically set
⋮----
void GenerationParameters::setFeatureTypeDensity(const std::string& featureType, float density)
⋮----
float GenerationParameters::getFeatureTypeDensity(const std::string& featureType, float defaultValue) const
⋮----
void GenerationParameters::setFloatParam(const std::string& name, float value)
⋮----
float GenerationParameters::getFloatParam(const std::string& name, float defaultValue) const
⋮----
void GenerationParameters::setIntParam(const std::string& name, int value)
⋮----
int GenerationParameters::getIntParam(const std::string& name, int defaultValue) const
⋮----
void GenerationParameters::setBoolParam(const std::string& name, bool value)
⋮----
bool GenerationParameters::getBoolParam(const std::string& name, bool defaultValue) const
⋮----
void GenerationParameters::setStringParam(const std::string& name, const std::string& value)
⋮----
std::string GenerationParameters::getStringParam(const std::string& name, const std::string& defaultValue) const
⋮----
void GenerationParameters::setVec3Param(const std::string& name, const glm::vec3& value)
⋮----
glm::vec3 GenerationParameters::getVec3Param(const std::string& name, const glm::vec3& defaultValue) const
⋮----
bool GenerationParameters::applyPreset(const std::string& presetName)
⋮----
// Reset to defaults first
⋮----
// Default parameters already set
⋮----
// Preset not found
⋮----
void GenerationParameters::serialize(ECS::Serializer& serializer) const
⋮----
// Serialize basic properties
⋮----
// Serialize feature type enabled flags
⋮----
// Serialize feature type densities
⋮----
// Serialize custom parameters
⋮----
void GenerationParameters::deserialize(ECS::Deserializer& deserializer)
⋮----
// Deserialize basic properties
⋮----
// Deseserialize feature type enabled flags
⋮----
// Deserialize feature type densities
⋮----
// Deserialize custom parameters
⋮----
void GenerationParameters::initializeDefaults()
⋮----
// Basic properties
⋮----
// Clear all maps
⋮----
// Set common feature types to enabled by default
⋮----
// Set default densities for common feature types
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/Grid.cpp">
// -------------------------------------------------------------------------
// Grid.cpp
⋮----
Grid::Grid(int chunkSize)
⋮----
// Initialize bounds to a large volume
⋮----
bool Grid::initialize()
⋮----
// Get the ChunkManager from the application
⋮----
void Grid::shutdown()
⋮----
// Release reference to chunks
⋮----
Voxel Grid::getVoxel(const glm::vec3& worldPosition) const
⋮----
// Convert world position to chunk and local coordinates
⋮----
// Get the chunk
⋮----
// Get the voxel from the chunk
⋮----
Voxel Grid::getVoxel(int x, int y, int z) const
⋮----
// Convert grid coordinates to chunk and local coordinates
⋮----
bool Grid::setVoxel(const glm::vec3& worldPosition, const Voxel& voxel)
⋮----
// Check if the position is within the grid bounds
⋮----
// Get or create the chunk
⋮----
// Set the voxel in the chunk
⋮----
bool Grid::setVoxel(int x, int y, int z, const Voxel& voxel)
⋮----
// Convert grid position to world position to check bounds
glm::vec3 worldPos(
⋮----
std::shared_ptr<Chunk> Grid::getChunk(const ChunkCoord& coord) const
⋮----
std::shared_ptr<Chunk> Grid::getChunkAt(const glm::vec3& worldPosition) const
⋮----
// Convert world position to chunk coordinates
⋮----
std::shared_ptr<Chunk> Grid::createChunk(const ChunkCoord& coord)
⋮----
bool Grid::unloadChunk(const ChunkCoord& coord)
⋮----
bool Grid::raycast(const glm::vec3& origin, const glm::vec3& direction, float maxDistance,
⋮----
// Create ray and initialize DDA algorithm parameters
⋮----
// Transform ray to grid space
⋮----
// Ray starting parameters
⋮----
// Direction of the ray (sign of each component)
⋮----
// Calculate delta distance for each axis
⋮----
// Calculate distance to next voxel boundary
⋮----
// Perform DDA algorithm
⋮----
// Determine which voxel boundary to cross next
⋮----
// X boundary
⋮----
// Y boundary
⋮----
// Z boundary
⋮----
// Check if we've gone out of bounds
⋮----
// Get the voxel at the current position
⋮----
// If not empty, we've hit something
⋮----
// Begin grid object
⋮----
// Write grid properties
⋮----
// Write bounds
⋮----
// Write default voxel
⋮----
// Write loaded chunks
⋮----
// End grid object
⋮----
// Read grid properties
⋮----
// Read bounds
⋮----
// Read default voxel
⋮----
// Read chunks
⋮----
// Get all loaded chunks from the chunk manager
⋮----
// Extract coordinates
⋮----
// World to grid is a straight conversion since we use 1:1 scale
⋮----
void Grid::gridToChunkAndLocal(int gridX, int gridY, int gridZ, ChunkCoord& chunkCoord,
⋮----
// Calculate chunk coordinate by dividing by chunk size
⋮----
// Calculate local coordinates within the chunk
⋮----
void Grid::worldToChunkAndLocal(const glm::vec3& worldPos, ChunkCoord& chunkCoord,
⋮----
// Convert to grid coordinates first
⋮----
// Then convert to chunk and local coordinates
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/NoiseGenerator.cpp">
// -------------------------------------------------------------------------
// NoiseGenerator.cpp
⋮----
NoiseGenerator::NoiseGenerator()
⋮----
// Initialize with default values
⋮----
// Nothing to clean up
⋮----
float NoiseGenerator::generate(float x, float y, float z) const
⋮----
// Apply scale and offset to coordinates
⋮----
// Apply domain warping if enabled
⋮----
// If there are layers, use them
⋮----
// Start with the first layer as the base
⋮----
// Apply the layer's scale and offset
⋮----
// Apply the layer's warping if enabled
⋮----
// Generate noise value for this layer
⋮----
// Scale by amplitude
⋮----
// Combine with previous result
⋮----
// Normalize if total weight is not zero
⋮----
// Apply custom modifier if set
⋮----
// No layers, use the base settings
⋮----
// Scale coordinates by frequency
⋮----
// Generate noise value
⋮----
float NoiseGenerator::generate(const glm::vec3& position) const
⋮----
float NoiseGenerator::generate2D(float x, float y) const
⋮----
// Just use the 3D generator with z=0
⋮----
void NoiseGenerator::setSeed(uint32_t seed)
⋮----
uint32_t NoiseGenerator::getSeed() const
⋮----
void NoiseGenerator::setNoiseType(NoiseType type)
⋮----
NoiseGenerator::NoiseType NoiseGenerator::getNoiseType() const
⋮----
void NoiseGenerator::setFractalType(FractalType type)
⋮----
NoiseGenerator::FractalType NoiseGenerator::getFractalType() const
⋮----
void NoiseGenerator::setOctaves(int octaves)
⋮----
int NoiseGenerator::getOctaves() const
⋮----
void NoiseGenerator::setLacunarity(float lacunarity)
⋮----
float NoiseGenerator::getLacunarity() const
⋮----
void NoiseGenerator::setPersistence(float persistence)
⋮----
float NoiseGenerator::getPersistence() const
⋮----
void NoiseGenerator::setFrequency(float frequency)
⋮----
float NoiseGenerator::getFrequency() const
⋮----
void NoiseGenerator::setAmplitude(float amplitude)
⋮----
float NoiseGenerator::getAmplitude() const
⋮----
void NoiseGenerator::setScale(const glm::vec3& scale)
⋮----
glm::vec3 NoiseGenerator::getScale() const
⋮----
void NoiseGenerator::setOffset(const glm::vec3& offset)
⋮----
glm::vec3 NoiseGenerator::getOffset() const
⋮----
void NoiseGenerator::enableWarp(bool enable)
⋮----
bool NoiseGenerator::isWarpEnabled() const
⋮----
void NoiseGenerator::setWarpType(WarpType type)
⋮----
NoiseGenerator::WarpType NoiseGenerator::getWarpType() const
⋮----
void NoiseGenerator::setWarpAmplitude(float amplitude)
⋮----
float NoiseGenerator::getWarpAmplitude() const
⋮----
void NoiseGenerator::setWarpFrequency(float frequency)
⋮----
float NoiseGenerator::getWarpFrequency() const
⋮----
void NoiseGenerator::setInterpolation(InterpolationType interp)
⋮----
NoiseGenerator::InterpolationType NoiseGenerator::getInterpolation() const
⋮----
bool NoiseGenerator::createLayer(const std::string& name)
⋮----
// Check if layer already exists
⋮----
// Create new layer with default values
⋮----
// Add to layers list
⋮----
bool NoiseGenerator::removeLayer(const std::string& name)
⋮----
// Remove the layer
⋮----
// Update indices of remaining layers
⋮----
bool NoiseGenerator::setLayerEnabled(const std::string& name, bool enabled)
⋮----
bool NoiseGenerator::isLayerEnabled(const std::string& name) const
⋮----
bool NoiseGenerator::setLayerNoiseType(const std::string& name, NoiseType type)
⋮----
bool NoiseGenerator::setLayerFractalType(const std::string& name, FractalType type)
⋮----
bool NoiseGenerator::setLayerFrequency(const std::string& name, float frequency)
⋮----
bool NoiseGenerator::setLayerAmplitude(const std::string& name, float amplitude)
⋮----
bool NoiseGenerator::setLayerOctaves(const std::string& name, int octaves)
⋮----
bool NoiseGenerator::setLayerPersistence(const std::string& name, float persistence)
⋮----
bool NoiseGenerator::setLayerLacunarity(const std::string& name, float lacunarity)
⋮----
bool NoiseGenerator::setLayerOffset(const std::string& name, const glm::vec3& offset)
⋮----
bool NoiseGenerator::setLayerScale(const std::string& name, const glm::vec3& scale)
⋮----
bool NoiseGenerator::setLayerWeight(const std::string& name, float weight)
⋮----
bool NoiseGenerator::getLayerWeight(const std::string& name, float& weight) const
⋮----
bool NoiseGenerator::setLayerCombineOperation(const std::string& name, CombineOperation operation)
⋮----
bool NoiseGenerator::getLayerCombineOperation(const std::string& name, CombineOperation& operation) const
⋮----
std::vector<std::string> NoiseGenerator::getLayerNames() const
⋮----
size_t NoiseGenerator::getLayerCount() const
⋮----
void NoiseGenerator::setModifier(std::function<float(float)> modifier)
⋮----
void NoiseGenerator::clearModifier()
⋮----
bool NoiseGenerator::presetTerrain(bool mountainous)
⋮----
// Clear existing layers
⋮----
// Set base properties
⋮----
// Create base terrain layer
⋮----
// Create detail layer
⋮----
// Create ridge layer for mountains
⋮----
// Add warping to make mountains more interesting
⋮----
bool NoiseGenerator::presetCaves()
⋮----
// Create base cave layer
⋮----
// Create cave shape layer
⋮----
// Add warping for more natural cave systems
⋮----
bool NoiseGenerator::presetOreDistribution()
⋮----
// Create base layer for overall distribution
⋮----
// Create vein layer for ore veins
⋮----
// Create detail layer for smaller deposits
⋮----
bool NoiseGenerator::presetBiomeBlend()
⋮----
// Create temperature layer
⋮----
// Create humidity layer
⋮----
setLayerOffset("humidity", glm::vec3(123.0f, 456.0f, 789.0f)); // Offset to make it different from temperature
⋮----
// Create altitude variation layer
⋮----
bool NoiseGenerator::presetDetailTexture()
⋮----
// Create base detail layer
⋮----
// Create fine detail layer
⋮----
// Create spots layer
⋮----
void NoiseGenerator::serialize(ECS::Serializer& serializer) const
⋮----
// Serialize base properties
⋮----
// Serialize layers
⋮----
void NoiseGenerator::deserialize(ECS::Deserializer& deserializer)
⋮----
// Clear existing data
⋮----
// Deserialize base properties
⋮----
// Deserialize layers
⋮----
// Private helper methods
⋮----
float NoiseGenerator::generateSingle(NoiseType type, float x, float y, float z) const
⋮----
// Simple Worley (cellular) noise implementation
⋮----
// Determine cell coordinates
⋮----
// Search neighboring cells
⋮----
// Generate feature point for this cell
⋮----
// Use the seed to generate a feature point
⋮----
// Compute distance to feature point
⋮----
// Convert to [-1, 1] range
⋮----
// Value noise implementation
⋮----
// Get values at corners
⋮----
// Interpolate
⋮----
// Cubic noise (similar to value noise but with cubic interpolation)
⋮----
// Simple white noise implementation
⋮----
// Combine coordinates and seed
⋮----
// Convert to float in range [-1, 1]
⋮----
// Ridged multi-fractal noise based on Perlin
⋮----
// Billow noise based on Perlin
⋮----
// Voronoi noise implementation (similar to Worley but different distance metric)
⋮----
// Compute Manhattan distance to feature point
⋮----
// Use the closest point to generate a value in [-1, 1]
⋮----
// Domain warping noise based on Perlin
⋮----
float NoiseGenerator::generateFractal(NoiseType noiseType, FractalType fractalType, float x, float y, float z,
⋮----
// Fractal Brownian Motion
⋮----
// Normalize the result
⋮----
// Rigid multi-fractal
⋮----
// Billowy noise
⋮----
// Multi-fractal
⋮----
// Hybrid multi-fractal
⋮----
// De Carpentier voxel terrain formula
⋮----
float NoiseGenerator::computeWarp(WarpType type, float x, float y, float z, float amplitude, float frequency) const
⋮----
// Basic domain warping using Perlin noise
⋮----
// Derivative-based warping
⋮----
// Fractal warping
⋮----
float NoiseGenerator::interpolate(InterpolationType type, float a, float b, float t) const
⋮----
float NoiseGenerator::combineValues(float a, float b, CombineOperation op, float weight) const
⋮----
float t = (b + 1.0f) * 0.5f * weight; // Map b from [-1,1] to [0,1]
⋮----
glm::vec3 NoiseGenerator::applyScaleAndOffset(float x, float y, float z, const glm::vec3& scale, const glm::vec3& offset) const
⋮----
void NoiseGenerator::validateParameters()
⋮----
// Ensure parameters are within valid ranges
⋮----
// Ensure scale is non-zero
⋮----
// Validate all layers
⋮----
// Helper function for value noise
float NoiseGenerator::valueNoise(int x, int y, int z) const
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/ProceduralGenerationSystem.cpp">
// -------------------------------------------------------------------------
// ProceduralGenerationSystem.cpp
⋮----
ProceduralGenerationSystem::ProceduralGenerationSystem() : m_shutdownThread(false)
⋮----
// Constructor implementation
⋮----
bool ProceduralGenerationSystem::initialize()
⋮----
// Create biome manager
⋮----
// Create a default noise generator
⋮----
// Create default terrain noise generator
⋮----
// Create default cave noise generator
⋮----
// Create default feature placement
⋮----
// Create default distribution control
⋮----
// Create default generation parameters
⋮----
// Set active parameters
⋮----
// Set default seeds
⋮----
// Start generation thread
⋮----
void ProceduralGenerationSystem::update(float deltaTime)
⋮----
// Process any immediate generation tasks
⋮----
void ProceduralGenerationSystem::render()
⋮----
// Render debug visualization if needed
⋮----
void ProceduralGenerationSystem::shutdown()
⋮----
// Signal generation thread to stop
⋮----
// Join the generation thread
⋮----
// Clear all generation tasks
⋮----
std::lock_guard<std::mutex> lock(m_taskMutex);
⋮----
// Clear all parameters
⋮----
// Clear all generators
⋮----
// Clear biome manager
⋮----
// Clear feature generators
⋮----
std::vector<std::string> ProceduralGenerationSystem::getDependencies() const
⋮----
bool ProceduralGenerationSystem::generateChunk(const ChunkCoord& coord, Chunk& chunk, const std::string& parametersId)
⋮----
// Create generation context
⋮----
// Check if context is valid
⋮----
// Generate terrain
⋮----
// Generate biomes
⋮----
// Continue anyway
⋮----
// Generate features
⋮----
int ProceduralGenerationSystem::generateRegion(const ChunkCoord& min, const ChunkCoord& max, Grid& grid, const std::string& parametersId)
⋮----
// Iterate through all chunks in the region
⋮----
ChunkCoord coord(x, y, z);
⋮----
// Get or create the chunk
⋮----
// Generate the chunk
⋮----
// Update neighbor chunks
⋮----
int ProceduralGenerationSystem::generateAroundPoint(const glm::vec3& center, float radius, Grid& grid, const std::string& parametersId)
⋮----
// Calculate the chunk coordinates range
⋮----
// Iterate through all chunks in the range
⋮----
// Calculate chunk center in world space
⋮----
// Check if chunk is within the radius
⋮----
std::shared_ptr<GenerationParameters> ProceduralGenerationSystem::createParameters(const std::string& id)
⋮----
// Check if parameters already exist
⋮----
// Create new parameters
⋮----
// Set default values
⋮----
std::shared_ptr<GenerationParameters> ProceduralGenerationSystem::getParameters(const std::string& id) const
⋮----
bool ProceduralGenerationSystem::setActiveParameters(const std::string& id)
⋮----
std::shared_ptr<GenerationParameters> ProceduralGenerationSystem::getActiveParameters() const
⋮----
std::shared_ptr<NoiseGenerator> ProceduralGenerationSystem::createNoiseGenerator(const std::string& id)
⋮----
// Check if generator already exists
⋮----
// Create new generator
⋮----
std::shared_ptr<NoiseGenerator> ProceduralGenerationSystem::getNoiseGenerator(const std::string& id) const
⋮----
std::shared_ptr<FeaturePlacement> ProceduralGenerationSystem::createFeaturePlacement(const std::string& id)
⋮----
// Check if placement already exists
⋮----
// Create new placement
⋮----
std::shared_ptr<FeaturePlacement> ProceduralGenerationSystem::getFeaturePlacement(const std::string& id) const
⋮----
std::shared_ptr<DistributionControl> ProceduralGenerationSystem::createDistributionControl(const std::string& id)
⋮----
// Check if control already exists
⋮----
// Create new control
⋮----
std::shared_ptr<DistributionControl> ProceduralGenerationSystem::getDistributionControl(const std::string& id) const
⋮----
std::shared_ptr<GenerationParameters> ProceduralGenerationSystem::loadParameters(const std::string& path, const std::string& id)
⋮----
// Create parameters object
⋮----
// Ensure file exists
⋮----
// Load from file
⋮----
// Open file for reading
std::ifstream file(path, std::ios::binary);
⋮----
// Create a deserializer
ECS::Deserializer deserializer(file);
⋮----
// Deserialize the params
⋮----
bool ProceduralGenerationSystem::saveParameters(const std::string& id, const std::string& path)
⋮----
// Get parameters
⋮----
// Save to file
⋮----
// Open the file
std::ofstream file(path, std::ios::binary);
⋮----
// Create a serializer
ECS::Serializer serializer(file);
⋮----
// Serialize the params
⋮----
std::shared_ptr<BiomeManager> ProceduralGenerationSystem::getBiomeManager() const
⋮----
uint32_t ProceduralGenerationSystem::getSeed() const
⋮----
void ProceduralGenerationSystem::setSeed(uint32_t seed)
⋮----
// Update seeds in all systems
⋮----
bool ProceduralGenerationSystem::registerFeatureGenerator(const std::string& name,
⋮----
// Check if already registered
⋮----
std::function<bool(const GenerationContext&, Chunk&)> ProceduralGenerationSystem::getFeatureGenerator(const std::string& name) const
⋮----
int ProceduralGenerationSystem::preGenerateChunks(const ChunkCoord& min, const ChunkCoord& max, int priority)
⋮----
// Create a new task
⋮----
bool ProceduralGenerationSystem::isPreGenerationComplete(int taskId)
⋮----
// If task not found, assume it's complete
⋮----
bool ProceduralGenerationSystem::cancelPreGeneration(int taskId)
⋮----
void ProceduralGenerationSystem::setPaused(bool paused)
⋮----
bool ProceduralGenerationSystem::isPaused() const
⋮----
GenerationContext ProceduralGenerationSystem::createContext(const ChunkCoord& coord, const std::string& parametersId)
⋮----
context.chunkSize = 16; // Default size, should be obtained from ChunkManager
context.worldBounds = Utility::AABB(glm::vec3(-1000000.0f), glm::vec3(1000000.0f)); // Default large bounds
⋮----
// Set parameters
⋮----
// Set noise generator
⋮----
// Set feature placement
⋮----
// Set distribution control
⋮----
// Set biome manager
⋮----
bool ProceduralGenerationSystem::generateTerrainForChunk(const GenerationContext& context, Chunk& chunk)
⋮----
// Get height range
⋮----
// Get water level
⋮----
// Get cave parameters
⋮----
// Get cave noise generator
⋮----
// Get chunk world position
⋮----
// Generate terrain based on mode
⋮----
// Flat terrain at a fixed height
float flatHeight = minHeight + heightRange * 0.5f; // Middle of range
⋮----
// Terrain
⋮----
voxel.type = 1; // Solid type
⋮----
// If below water level and water enabled, use different type
⋮----
voxel.type = 2; // Underwater type
⋮----
// Water
⋮----
voxel.type = 3; // Water type
⋮----
// Air
⋮----
voxel.type = 0; // Air type
⋮----
// Height map based terrain
⋮----
// Calculate world coordinates
⋮----
// Get terrain height from noise
⋮----
// Check if we need to generate caves
⋮----
// Full 3D volumetric terrain with caves
⋮----
// Get density from noise
⋮----
// Adjust density based on height (gradually less dense with height)
⋮----
// Apply cave noise if enabled
⋮----
// Apply height adjustment
⋮----
// Solid terrain
⋮----
// Floating islands
⋮----
// Get 3D noise for islands
⋮----
// Create floating island effect
⋮----
// Adjust noise based on height (islands concentrated in the middle)
⋮----
// Solid island terrain
⋮----
// Mountainous terrain
⋮----
// Get mountain height from noise
⋮----
// Adjust for more dramatic mountains
float mountainFactor = (baseNoise + 1.0f) * 0.5f; // [0, 1]
mountainFactor = std::pow(mountainFactor, 3.0f); // Steeper mountains
⋮----
// Different types based on height
⋮----
voxel.type = 4; // Top layer type
⋮----
voxel.type = 5; // Mountain type
⋮----
// Default to height map if not implemented
⋮----
bool ProceduralGenerationSystem::generateFeaturesForChunk(const GenerationContext& context, Chunk& chunk)
⋮----
// If no registered feature types, nothing to generate
⋮----
// Create a grid reference for feature placement constraints
// This would be obtained from the application in a real implementation
⋮----
// For each feature type
⋮----
// Check if feature type is enabled
⋮----
// Get feature density
⋮----
// Calculate max count based on density
⋮----
maxCount = std::max(1, maxCount); // At least 1
⋮----
// Find valid placements
⋮----
// Generate features at valid positions
⋮----
bool ProceduralGenerationSystem::generateBiomesForChunk(const GenerationContext& context, Chunk& chunk)
⋮----
// Generate biome data for the chunk
⋮----
void ProceduralGenerationSystem::processGenerationQueue()
⋮----
// Sleep to avoid high CPU usage
⋮----
// Get the highest priority task
⋮----
// Find the highest priority task
⋮----
// Process the task
⋮----
// Mark task as complete
⋮----
// Generate chunks in the region
⋮----
void ProceduralGenerationSystem::updateNeighborChunks(const ChunkCoord& coord, Grid& grid)
⋮----
// Check all 6 neighbors and update them if needed
⋮----
// Update mesh or notify chunk of neighbor change
// In a real implementation, this would likely call:
// chunk->markMeshDirty();
⋮----
} // namespace PixelCraft::Voxel
</file>

<file path="src/Voxel/StreamingManager.cpp">
// -------------------------------------------------------------------------
// StreamingManager.cpp
⋮----
// Constants
constexpr size_t DEFAULT_CHUNK_MEMORY = 512 * 1024 * 1024;  // 512 MB
constexpr size_t DEFAULT_MESH_MEMORY = 256 * 1024 * 1024;   // 256 MB
constexpr size_t DEFAULT_RESERVE_MEMORY = 64 * 1024 * 1024; // 64 MB
constexpr float DEFAULT_UPDATE_INTERVAL = 0.5f;             // 500ms
⋮----
// Helper to convert ChunkCoord to vec3 for distance calculation
glm::vec3 coordToWorldPosition(const ChunkCoord& coord)
⋮----
// Assuming ChunkCoord has x, y, z and we have a constant chunk size
constexpr int CHUNK_SIZE = 16; // This should match your actual chunk size
⋮----
// Default estimation of chunk memory (should be replaced with more accurate calculations)
constexpr size_t ESTIMATED_CHUNK_MEMORY = 64 * 1024;      // 64 KB per chunk
constexpr size_t ESTIMATED_CHUNK_MESH_MEMORY = 128 * 1024; // 128 KB per mesh
⋮----
// Lower priority value = higher priority
⋮----
return priority > other.priority; // Note the reversed comparison for priority queue
⋮----
// If same priority, use timestamp (older tasks first)
⋮----
StreamingManager::StreamingManager()
⋮----
// Initialize memory budget with defaults
⋮----
bool StreamingManager::initialize()
⋮----
// Get dependencies
⋮----
// Start worker threads
⋮----
void StreamingManager::update(float deltaTime)
⋮----
// Accumulate time since last full update
⋮----
// Check if it's time for a full update of chunk requests
⋮----
// Process any completed tasks and update statistics
std::lock_guard<std::mutex> lock(m_taskMutex);
⋮----
// Remove completed or canceled active tasks
⋮----
void StreamingManager::render()
⋮----
// Debug visualization can be added here if needed
// For example, visualizing loaded chunks with different colors based on priority
⋮----
void StreamingManager::shutdown()
⋮----
// Stop all worker threads
⋮----
// Clear all pending tasks
⋮----
std::vector<std::string> StreamingManager::getDependencies() const
⋮----
bool StreamingManager::requestChunk(const ChunkCoord& coord, Priority priority)
⋮----
// Check if the chunk is already loaded
⋮----
return true; // Already loaded, no need to request
⋮----
// Check if there's already a pending task for this chunk
⋮----
// We could update priority here if needed
⋮----
// Determine if we need to load or generate
⋮----
// Check if the chunk exists on disk before deciding to generate
⋮----
bool StreamingManager::requestChunkMesh(const ChunkCoord& coord, Priority priority)
⋮----
// Ensure the chunk is loaded first
⋮----
// Request the chunk first, then mesh will be generated after
⋮----
bool StreamingManager::requestChunkSave(const ChunkCoord& coord, Priority priority)
⋮----
return false; // Can't save what isn't loaded
⋮----
bool StreamingManager::requestChunkUnload(const ChunkCoord& coord, Priority priority)
⋮----
return true; // Already unloaded
⋮----
int StreamingManager::cancelChunkTasks(const ChunkCoord& coord)
⋮----
// Cancel any pending tasks for this chunk
⋮----
// Mark any active tasks for this chunk as cancelled
⋮----
m_taskCondition.notify_all(); // Wake up worker threads to check for cancellation
⋮----
void StreamingManager::setFocusPoint(const glm::vec3& position, float radius)
⋮----
// This change should trigger a re-evaluation of priorities
m_timeSinceLastUpdate = m_updateInterval; // Force update on next frame
⋮----
int StreamingManager::addFocusPoint(const glm::vec3& position, float radius, Priority priority)
⋮----
// Force update on next frame
⋮----
bool StreamingManager::removeFocusPoint(int focusPointId)
⋮----
void StreamingManager::setMemoryBudget(size_t chunkMemory, size_t meshMemory, size_t reserveMemory)
⋮----
std::lock_guard<std::mutex> lock(m_memoryMutex);
⋮----
// Log current memory usage vs budget
⋮----
const StreamingManager::MemoryBudget& StreamingManager::getMemoryUsage() const
⋮----
void StreamingManager::setWorkerThreadCount(int numThreads)
⋮----
return; // No change needed
⋮----
// stop existing threads
⋮----
// Start new threads
⋮----
size_t StreamingManager::getPendingTaskCount() const
⋮----
size_t StreamingManager::getActiveTaskCount() const
⋮----
bool StreamingManager::isChunkProcessing(const ChunkCoord& coord) const
⋮----
// Check pending tasks
⋮----
// Check active tasks
⋮----
void StreamingManager::workerThread(int threadIndex)
⋮----
std::unique_lock<std::mutex> lock(m_taskMutex);
⋮----
// Wait for a task or shutdown signal
⋮----
// Get a copy of the top task
⋮----
// Check if task is canceled
⋮----
// Remove from pending map
⋮----
// Add to active tasks
⋮----
// Process the task outside the lokc
⋮----
void StreamingManager::updateChunkRequests()
⋮----
// Get chunks around primary focus point
⋮----
// Determine chunks to load
⋮----
// Request chunk and mesh based on priority
⋮----
// Determine chunks to unload (those too far from any focus point
⋮----
// If chunk is too far from all focus points, schedule for unloading
⋮----
{ // Add buffer to avoid thrashing
⋮----
bool StreamingManager::processTask(StreamingTask& task)
⋮----
// Process based on operation type
⋮----
bool StreamingManager::generateChunk(const ChunkCoord& coord, StreamingTask& task)
⋮----
// Check memory budget
⋮----
// Requeue with lower priority if not critical
⋮----
// Generate the chunk
⋮----
// Update memory usage
⋮----
// Request mesh generation automatically
⋮----
bool StreamingManager::loadChunk(const ChunkCoord& coord, StreamingTask& task)
⋮----
// Load the chunk
⋮----
// If loading failed but chunk should exist, try generating instead
⋮----
bool StreamingManager::generateChunkMesh(const ChunkCoord& coord, StreamingTask& task)
⋮----
// Check if chunk is loaded
⋮----
// Generate mesh
⋮----
bool StreamingManager::saveChunk(const ChunkCoord& coord, StreamingTask& task)
⋮----
// Save the chunk
⋮----
bool StreamingManager::unloadChunk(const ChunkCoord& coord, StreamingTask& task)
⋮----
// Save if modified
⋮----
// Calculate memory to free
⋮----
// Unload the chunk
⋮----
// Update memory usage (negative to reduce)
⋮----
StreamingManager::Priority StreamingManager::calculatePriority(const ChunkCoord& coord) const
⋮----
// Convert distance to priority based on thresholds
⋮----
bool StreamingManager::checkMemoryBudget(size_t chunkMemory, size_t meshMemory, bool isHighPriority)
⋮----
// Calculate total memory required
⋮----
// High priority operations can use reserved memory
⋮----
// Check if we have enough budget
⋮----
void StreamingManager::updateMemoryUsage(int64_t chunkDelta, int64_t meshDelta)
⋮----
// Update current usage
⋮----
float StreamingManager::calculateDistanceToFocus(const ChunkCoord& coord) const
⋮----
// Start with distance to primary focus
⋮----
// Check all secondary focus points
⋮----
size_t StreamingManager::estimatedChunkMemory(const ChunkCoord& coord) const
⋮----
// In a real implementation, this might consider chunk contents or terrain complexity
// For simplicity, we use a constant estimation
⋮----
size_t StreamingManager::estimateChunkMeshMemory(const ChunkCoord& coord) const
⋮----
// In a real implementation, this might vary based on chunk contents
⋮----
bool StreamingManager::addTask(const ChunkCoord& coord, ChunkOperation operation, Priority priority)
⋮----
// Check if we have too many tasks queued
⋮----
// Create the task
⋮----
// Estimate memory requirements
⋮----
// Add the task to the queue
⋮----
// Store a pointer to this task in the pending map
// This is a simplification that works because we have direct access to the task
// In a real implementation, you'd need a more robust way to track tasks by coordinate
⋮----
// Notify one worker thread
⋮----
void StreamingManager::startWorkerThreads(int numThreads)
⋮----
void StreamingManager::stopWorkerThreads()
⋮----
// Signal threads to stop
⋮----
// Wait for all threads to finish
⋮----
} // namespace PixelCraft::Voxel
</file>

</files>
