// scene.fbs
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef SCENE_GENERATED_H
#define SCENE_GENERATED_H

#include "flatbuffers/flatbuffers.h"

namespace PixelCraft
{
    namespace ECS
    {

        struct EntityNameMapEntry;
        struct EntityTagMapEntry;
        struct SceneData;

        // Entry in the entity name map - mapping string names to entity IDs
        struct EntityNameMapEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
        {
            typedef EntityNameMapEntryBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
            {
                VT_NAME = 4,
                VT_ENTITY_ID = 6
            };
            const flatbuffers::String* name() const
            {
                return GetPointer<const flatbuffers::String*>(VT_NAME);
            }
            uint32_t entity_id() const
            {
                return GetField<uint32_t>(VT_ENTITY_ID, 0);
            }
            bool Verify(flatbuffers::Verifier& verifier) const
            {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT_NAME) &&
                    verifier.VerifyString(name()) &&
                    VerifyField<uint32_t>(verifier, VT_ENTITY_ID, 4) &&
                    verifier.EndTable();
            }
        };

        struct EntityNameMapEntryBuilder
        {
            typedef EntityNameMapEntry Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add_name(flatbuffers::Offset<flatbuffers::String> name)
            {
                fbb_.AddOffset(EntityNameMapEntry::VT_NAME, name);
            }
            void add_entity_id(uint32_t entity_id)
            {
                fbb_.AddElement<uint32_t>(EntityNameMapEntry::VT_ENTITY_ID, entity_id, 0);
            }
            flatbuffers::Offset<EntityNameMapEntry> Finish()
            {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<EntityNameMapEntry>(end);
                return o;
            }
        };

        inline flatbuffers::Offset<EntityNameMapEntry> CreateEntityNameMapEntry(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<flatbuffers::String> name = 0,
            uint32_t entity_id = 0)
        {
            EntityNameMapEntryBuilder builder_(_fbb);
            builder_.add_entity_id(entity_id);
            builder_.add_name(name);
            return builder_.Finish();
        }

        // Entry in the entity tag map - mapping tags to collections of entity IDs
        struct EntityTagMapEntry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
        {
            typedef EntityTagMapEntryBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
            {
                VT_TAG = 4,
                VT_ENTITIES = 6
            };
            const flatbuffers::String* tag() const
            {
                return GetPointer<const flatbuffers::String*>(VT_TAG);
            }
            const flatbuffers::Vector<uint32_t>* entities() const
            {
                return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ENTITIES);
            }
            bool Verify(flatbuffers::Verifier& verifier) const
            {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT_TAG) &&
                    verifier.VerifyString(tag()) &&
                    VerifyOffset(verifier, VT_ENTITIES) &&
                    verifier.VerifyVector(entities()) &&
                    verifier.EndTable();
            }
        };

        struct EntityTagMapEntryBuilder
        {
            typedef EntityTagMapEntry Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add_tag(flatbuffers::Offset<flatbuffers::String> tag)
            {
                fbb_.AddOffset(EntityTagMapEntry::VT_TAG, tag);
            }
            void add_entities(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> entities)
            {
                fbb_.AddOffset(EntityTagMapEntry::VT_ENTITIES, entities);
            }
            flatbuffers::Offset<EntityTagMapEntry> Finish()
            {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<EntityTagMapEntry>(end);
                return o;
            }
        };

        inline flatbuffers::Offset<EntityTagMapEntry> CreateEntityTagMapEntry(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<flatbuffers::String> tag = 0,
            flatbuffers::Offset<flatbuffers::Vector<uint32_t>> entities = 0)
        {
            EntityTagMapEntryBuilder builder_(_fbb);
            builder_.add_entities(entities);
            builder_.add_tag(tag);
            return builder_.Finish();
        }

        // The main Scene data structure
        struct SceneData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table
        {
            typedef SceneDataBuilder Builder;
            enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE
            {
                VT_NAME = 4,
                VT_PATH = 6,
                VT_SCHEMA_VERSION = 8,
                VT_MAIN_CAMERA = 10,
                VT_ROOT_ENTITIES = 12,
                VT_ENTITY_NAME_MAP = 14,
                VT_ENTITY_TAG_MAP = 16,
                VT_DIRTY_CHUNKS = 18
            };
            const flatbuffers::String* name() const
            {
                return GetPointer<const flatbuffers::String*>(VT_NAME);
            }
            const flatbuffers::String* path() const
            {
                return GetPointer<const flatbuffers::String*>(VT_PATH);
            }
            uint32_t schema_version() const
            {
                return GetField<uint32_t>(VT_SCHEMA_VERSION, 1);
            }
            uint32_t main_camera() const
            {
                return GetField<uint32_t>(VT_MAIN_CAMERA, 0);
            }
            const flatbuffers::Vector<uint32_t>* root_entities() const
            {
                return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ROOT_ENTITIES);
            }
            const flatbuffers::Vector<flatbuffers::Offset<EntityNameMapEntry>>* entity_name_map() const
            {
                return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EntityNameMapEntry>> *>(VT_ENTITY_NAME_MAP);
            }
            const flatbuffers::Vector<flatbuffers::Offset<EntityTagMapEntry>>* entity_tag_map() const
            {
                return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<EntityTagMapEntry>> *>(VT_ENTITY_TAG_MAP);
            }
            const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::Vector<int32_t>>>* dirty_chunks() const
            {
                return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::Vector<int32_t>>> *>(VT_DIRTY_CHUNKS);
            }
            bool Verify(flatbuffers::Verifier& verifier) const
            {
                return VerifyTableStart(verifier) &&
                    VerifyOffset(verifier, VT_NAME) &&
                    verifier.VerifyString(name()) &&
                    VerifyOffset(verifier, VT_PATH) &&
                    verifier.VerifyString(path()) &&
                    VerifyField<uint32_t>(verifier, VT_SCHEMA_VERSION, 4) &&
                    VerifyField<uint32_t>(verifier, VT_MAIN_CAMERA, 4) &&
                    VerifyOffset(verifier, VT_ROOT_ENTITIES) &&
                    verifier.VerifyVector(root_entities()) &&
                    VerifyOffset(verifier, VT_ENTITY_NAME_MAP) &&
                    verifier.VerifyVector(entity_name_map()) &&
                    verifier.VerifyVectorOfTables(entity_name_map()) &&
                    VerifyOffset(verifier, VT_ENTITY_TAG_MAP) &&
                    verifier.VerifyVector(entity_tag_map()) &&
                    verifier.VerifyVectorOfTables(entity_tag_map()) &&
                    VerifyOffset(verifier, VT_DIRTY_CHUNKS) &&
                    verifier.VerifyVector(dirty_chunks()) &&
                    verifier.EndTable();
            }
        };

        struct SceneDataBuilder
        {
            typedef SceneData Table;
            flatbuffers::FlatBufferBuilder& fbb_;
            flatbuffers::uoffset_t start_;
            void add_name(flatbuffers::Offset<flatbuffers::String> name)
            {
                fbb_.AddOffset(SceneData::VT_NAME, name);
            }
            void add_path(flatbuffers::Offset<flatbuffers::String> path)
            {
                fbb_.AddOffset(SceneData::VT_PATH, path);
            }
            void add_schema_version(uint32_t schema_version)
            {
                fbb_.AddElement<uint32_t>(SceneData::VT_SCHEMA_VERSION, schema_version, 1);
            }
            void add_main_camera(uint32_t main_camera)
            {
                fbb_.AddElement<uint32_t>(SceneData::VT_MAIN_CAMERA, main_camera, 0);
            }
            void add_root_entities(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> root_entities)
            {
                fbb_.AddOffset(SceneData::VT_ROOT_ENTITIES, root_entities);
            }
            void add_entity_name_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityNameMapEntry>>> entity_name_map)
            {
                fbb_.AddOffset(SceneData::VT_ENTITY_NAME_MAP, entity_name_map);
            }
            void add_entity_tag_map(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityTagMapEntry>>> entity_tag_map)
            {
                fbb_.AddOffset(SceneData::VT_ENTITY_TAG_MAP, entity_tag_map);
            }
            void add_dirty_chunks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::Vector<int32_t>>>> dirty_chunks)
            {
                fbb_.AddOffset(SceneData::VT_DIRTY_CHUNKS, dirty_chunks);
            }
            flatbuffers::Offset<SceneData> Finish()
            {
                const auto end = fbb_.EndTable(start_);
                auto o = flatbuffers::Offset<SceneData>(end);
                return o;
            }
        };

        inline flatbuffers::Offset<SceneData> CreateSceneData(
            flatbuffers::FlatBufferBuilder& _fbb,
            flatbuffers::Offset<flatbuffers::String> name = 0,
            flatbuffers::Offset<flatbuffers::String> path = 0,
            uint32_t schema_version = 1,
            uint32_t main_camera = 0,
            flatbuffers::Offset<flatbuffers::Vector<uint32_t>> root_entities = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityNameMapEntry>>> entity_name_map = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<EntityTagMapEntry>>> entity_tag_map = 0,
            flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::Vector<int32_t>>>> dirty_chunks = 0)
        {
            SceneDataBuilder builder_(_fbb);
            builder_.add_dirty_chunks(dirty_chunks);
            builder_.add_entity_tag_map(entity_tag_map);
            builder_.add_entity_name_map(entity_name_map);
            builder_.add_root_entities(root_entities);
            builder_.add_main_camera(main_camera);
            builder_.add_schema_version(schema_version);
            builder_.add_path(path);
            builder_.add_name(name);
            return builder_.Finish();
        }

        inline const SceneData* GetSceneData(const void* buf)
        {
            return flatbuffers::GetRoot<SceneData>(buf);
        }

        inline bool VerifySceneDataBuffer(
            flatbuffers::Verifier& verifier)
        {
            return verifier.VerifyBuffer<SceneData>(nullptr);
        }

        inline bool VerifySceneDataBufferWithIdentifier(
            flatbuffers::Verifier& verifier, const char* identifier)
        {
            return verifier.VerifyBuffer<SceneData>(identifier);
        }

        inline const char* SceneDataIdentifier()
        {
            return "SCNE";
        }

        inline bool SceneDataBufferHasIdentifier(const void* buf)
        {
            return flatbuffers::BufferHasIdentifier(
                buf, SceneDataIdentifier());
        }

    }  // namespace ECS
}  // namespace PixelCraft

#endif  // SCENE_GENERATED_H